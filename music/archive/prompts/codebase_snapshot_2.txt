index.html
```html
<!DOCTYPE html>
<!--------------------------------------*
* - iTunes api - searching
* - lyrics.ovh - lyrics
* - youtube data v3 - player
* - RapidAPI (rapidapi.com/ytdlfree/api/youtube-v3-alternative) - cycling player
*--------------------------------------->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Music Player</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.min.js"></script>
    <link rel="stylesheet" href="css/all.css" />

    <link rel="icon" href="img/favicon.png" type="image/x-icon">
  </head>
  <body>
    <div class="app-container"> 
        <div class="main-content">
            <div class="search-container">
            <input
                type="text"
                class="search-input"
                placeholder="Search for any song..."
                id="searchInput"
                autocomplete="off"
            />
            <div class="search-results" id="searchResults">
            </div>
            </div>

            

            <div class="player-area">
                <div class="player">
                    <div class="album-art">
                        <img
                        src="img/empty_art.png"
                        alt="Album"
                        id="albumCover"
                        crossorigin="anonymous"
                        />
                    </div>
                    <div class="info" id="playerInfo">
                        <div class="track-title" id="trackTitle">Not Playing</div>
                        <div class="artist" id="artistName">Not Playing</div>
                        <div class="controls">
                            <i id="prevBtn" class="icon icon-prev"></i>
                            <i id="playPause" class="icon icon-play"></i>
                            <i id="nextBtn" class="icon icon-next"></i>
                            <i id="volumeBtn" class="icon icon-volume"></i>
                            <i id="loopBtn" class="icon icon-loop"></i>
                            <i id="shuffleBtn" class="icon icon-shuffle"></i> 
                            <i id="likeBtn" class="icon icon-heart-empty"></i>
                            <i id="addToPlaylistBtn" class="icon icon-plus-circle"></i>
                        </div>
                        <div id="seekbar" class="seekbar"><div id="progress"></div></div>
                        <div class="timecodes">
                        <span id="currentTime">0:00</span>
                        <span id="remainingTime">-0:00</span>
                        </div>
                    </div>

                    <div class="lyrics-info" id="lyricsInfo">
                        <div class="lyrics-header">
                        <div>
                            <div class="lyrics-title" id="lyricsSongTitle">Not Playing</div>
                            <div class="lyrics-artist" id="lyricsArtistName">Not Playing</div>
                        </div>
                        </div>
                        <div class="lyrics-content" id="lyricsContent">
                        No lyrics available.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="playlist-sidebar" id="playlistSidebar">
          <div class="playlist-sidebar-header">
              <button id="backToPlaylistsBtn" class="sidebar-back-button icon-button" title="Back to playlists" style="display: none;">
                <i class="icon icon-arrow-left"></i>
              </button>
              <h3 id="sidebarTitle">Your Playlists</h3>
              <button id="createNewPlaylistBtn" class="create-playlist-btn">+</button>
          </div>
          <div class="playlist-content" id="playlistDisplayArea">
          </div>
      </div>


    </div>


    <!-- Bottom Controls Bar -->
    <div class="bottom-controls-bar">
      <div class="lyrics-toggle" id="lyricsToggle">
          <i class="icon icon-lyrics"></i>
      </div>
      <div class="settings-toggle" id="settingsToggle" title="Settings">
          <i class="icon icon-settings"></i>
      </div>
    </div>


    <div id="player-container">
      <div id="ytPlayer"></div>
    </div>

    <div id="addToPlaylistModal" class="modal" style="display:none;">
      <div class="modal-content">
          <span class="close-modal-btn" id="closeAddToPlaylistModal">×</span>
          <h4>Add to Playlist</h4>
          <div id="modalPlaylistList">
              <!-- Playlists will be dynamically inserted here -->
          </div>
      </div>
    </div>

    <div id="generalModal" class="modal" style="display:none;">
      <div class="modal-content">
          <span class="close-modal-btn" id="closeGeneralModal">×</span>
          <h4 id="generalModalTitle">Notification</h4>
          <p id="generalModalMessage" style="text-align: center; margin-bottom: 20px;"></p>
          <div id="generalModalActions" style="text-align: center;">
              <!-- Buttons will be dynamically inserted here -->
          </div>
      </div>
  </div>

   <!-- Create Playlist Modal -->
  <div id="createPlaylistModal" class="modal" style="display:none;">
    <div class="modal-content">
        <span class="close-modal-btn" id="closeCreatePlaylistModal">×</span>
        <h4 id="createPlaylistModalTitle">Create New Playlist</h4>
        <div class="modal-artwork-section">
            <div class="playlist-artwork-editor" id="createPlaylistArtworkEditor">
                <img src="img/empty_art.png" alt="Playlist Artwork" id="createPlaylistArtworkPreview" class="modal-artwork-preview">
                <div class="edit-overlay">
                    <i class="icon icon-edit"></i>
                    <span>Click or drag image</span>
                </div>
            </div>
            <button id="clearCreatePlaylistArtworkBtn" class="modal-button tertiary clear-artwork-btn" style="display:none;">Clear Artwork</button>
        </div>
        <input type="file" id="createPlaylistArtworkInput" accept="image/*" style="display:none;">

        <div class="form-group" style="margin-bottom: 20px;">
            <label for="newPlaylistNameInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Playlist Name:</label>
            <input type="text" id="newPlaylistNameInput" class="modal-input" placeholder="My Awesome Playlist">
        </div>
        <div id="createPlaylistModalActions" style="text-align: right;">
            <button id="cancelCreatePlaylistBtn" class="modal-button secondary" style="margin-right: 10px;">Cancel</button>
            <button id="confirmCreatePlaylistBtn" class="modal-button success">Create</button>
        </div>
    </div>
  </div>

  <!-- Edit Playlist Modal (formerly Rename Playlist Modal) -->
  <div id="editPlaylistModal" class="modal" style="display:none;">
    <div class="modal-content">
        <span class="close-modal-btn" id="closeEditPlaylistModal">×</span>
        <h4 id="editPlaylistModalTitle">Edit Playlist</h4>
        <div class="modal-artwork-section">
            <div class="playlist-artwork-editor" id="editPlaylistArtworkEditor">
                <img src="img/empty_art.png" alt="Playlist Artwork" id="editPlaylistArtworkPreview" class="modal-artwork-preview">
                <div class="edit-overlay">
                    <i class="icon icon-edit"></i>
                    <span>Click or drag image</span>
                </div>
            </div>
            <button id="clearEditPlaylistArtworkBtn" class="modal-button tertiary clear-artwork-btn" style="display:none;">Clear Artwork</button>
        </div>
        <input type="file" id="editPlaylistArtworkInput" accept="image/*" style="display:none;">

        <div class="form-group" style="margin-bottom: 20px;">
            <label for="editPlaylistNameInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Playlist Name:</label>
            <input type="text" id="editPlaylistNameInput" class="modal-input" placeholder="Enter new name">
        </div>
        <div id="editPlaylistModalActions" style="text-align: right;">
            <button id="cancelEditPlaylistBtn" class="modal-button secondary" style="margin-right: 10px;">Cancel</button>
            <button id="confirmEditPlaylistBtn" class="modal-button success">Save Changes</button>
        </div>
    </div>
  </div>

  <!-- Settings Modal -->
    <div id="settingsModal" class="modal" style="display:none;">
      <div class="modal-content">
          <span class="close-modal-btn" id="closeSettingsModal">×</span>
          <h4 id="settingsModalTitle">Settings</h4>
          
          <div class="settings-section">
              <h5>Export Data</h5>
              <p class="settings-description">Download your playlists and app data as a JSON file.</p>
              <button id="exportDataBtn" class="modal-button secondary">Export My Data</button>
          </div>

          <!-- <hr class="settings-divider"> -->

          <div class="settings-section last-content-section">
              <h5>Import Data</h5>
              <p class="settings-description">Import data from a previously exported file.
                  <br><strong>Warning:</strong> This will overwrite your current playlists and data. This action cannot be undone.
              </p>
              <div id="importFileDropZone" class="file-drop-zone">
                  <input type="file" id="importDataInput" accept=".json,application/json" style="display: none;">
                  <span class="drop-zone-prompt">Drag & drop your .json file here, or click to select</span>
              </div>
              <button id="importDataBtn" class="modal-button primary" style="margin-top: 10px;" disabled>Import Selected File</button>
              <p id="selectedFileName" class="selected-file-name-display"></p>
          </div>
          

          <!-- GitHub Commit Info Footer -->
          <div class="settings-modal-footer">
            <i class="icon icon-github"></i>
            <a href="https://github.com/Hydrovolter/Music" target="_blank" rel="noopener noreferrer" class="commit-link" id="githubCommitLink">
                <span id="latestCommitSha" title="View commit on GitHub"></span>
            </a>
            <span class="commit-separator">·</span>
            <span id="latestCommitTimeAgo" title=""></span>
          </div>

      </div>
    </div>

  <div id="toastContainer" class="toast-container">
    <!-- Toasts will be dynamically added here -->
  </div>

  <!-- Credits Footer -->
  <div class="credits-footer">
    <span>Made with </span>
    <span class="credit-heart">❤️</span>
    <span> by </span>
    <a href="https://hydrovolter.com" target="_blank" rel="noopener noreferrer" class="credit-link">Hydrovolter</a>
  </div>
  
    <script src="js/endpoints.js"></script>
    <script src="js/init.js"></script>
    <script src="js/modals.js"></script>
    <script src="js/toast.js"></script>
    <script src="js/bg.js"></script>
    <script src="js/playlist.js"></script>
    <script src="js/player.js"></script>
    <script src="js/history.js"></script> 
    <script src="js/search.js"></script>
    <script src="js/play.js"></script>
    <script src="js/getYT.js"></script>
    <script src="js/lyrics.js"></script>
    <script src="js/playback.js"></script>

    <script>
      document.addEventListener("click", function (e) {
        // Ensure searchInput and searchResults are defined before accessing contains
        if (typeof searchInput !== 'undefined' && typeof searchResults !== 'undefined' &&
            !searchResults.contains(e.target) && e.target !== searchInput) {
          if (typeof hideSearchResults === 'function') hideSearchResults();
        }
      });

      document.addEventListener('DOMContentLoaded', () => {
        if (typeof initializeModals === 'function') { // Initialize the new modal system
            initializeModals();
        } else {
            console.error("initializeModals function not found.");
        }
        if (typeof initializePlaylistSystem === 'function') { // Initialize the playlist system
            initializePlaylistSystem();
        } else {
            console.error("initializePlaylistSystem function not found.");
        }

      });
    </script>
  </body>
</html>
```

archive/sf.html
```html
<!DOCTYPE html>
<!--------------------------------------* 
*  Credits:
* - iTunes api - searching
* - lyrics.ovh - lyrics
* - youtube data v3 - player
*--------------------------------------->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>arcora</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://vapor.my/_a/fa/css/all.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.min.js"></script>
    <style>:root {
        --bg-start: #747474;
        --bg-end: #4b4b4b;
        --card-width: 540px;
        --card-height: 220px;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        color: #fff;
        padding: 20px;
        transition: background 0.8s ease;
      }
      .search-container {
        width: 100%;
        max-width: 560px;
        margin-bottom: 20px;
        z-index: 100;
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
      }
      .search-input {
        width: 100%;
        padding: 12px 20px;
        border-radius: 12px;
        border: none;
        font-family: "Inter", sans-serif;
        font-size: 16px;
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
        outline: none;
        transition: all 0.2s ease;
        backdrop-filter: blur(5px);
      }
      .search-input::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }
      .search-input:focus {
        background: rgba(255, 255, 255, 0.25);
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      }
      .search-results {
        width: 100%;
        max-width: 560px;
        max-height: 400px;
        background: rgba(30, 30, 30, 0.65);
        backdrop-filter: blur(10px);
        border-radius: 8px;
        overflow-y: auto;
        opacity: 0;
        transform: translateY(-7px);
        visibility: hidden;
        transition: all 0.2s ease;
        z-index: 99;
        position: absolute;
        top: 75px;
        left: 50%;
        transform: translateX(-50%) translateY(-7px);
      }
      .search-results.active {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
        visibility: visible;
      }
      .result-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        cursor: pointer;
        transition: background 0.2s;
        overflow: hidden;
      }
      .result-item:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      .result-img {
        width: 60px;
        height: 60px;
        border-radius: 6px;
        overflow: hidden;
        margin-right: 16px;
        flex-shrink: 0;
      }
      .result-img img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .result-info {
        flex: 1;
      }
      .result-title {
        font-weight: 600;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .result-artist {
        font-size: 14px;
        opacity: 0.7;
      }
      .player {
        width: 100%;
        width: 570px;
        display: flex;
        align-items: center;
        gap: 28px;
        padding: 24px;
        margin: 0 auto;
      }
      .album-art {
        flex: 0 0 220px;
        height: 220px;
        border-radius: 12px;
        overflow: hidden;
      }
      .album-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .info {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        padding-left: 0px;
        text-shadow: 0px 0px 12px rgba(0, 0, 0, 0.3);
      }
      .top-icons {
        width: 100%;
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
      }
      .top-icons i {
        font-size: 20px;
        opacity: 0.6;
      }
      
      .track-title {
        font-size: 34px;
        font-weight: 700;
        margin-bottom: 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 300px;
      }
      .artist {
        font-size: 20px;
        opacity: 0.75;
        margin-bottom: 45px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 300px;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 18px;
      }
      .controls i {
        font-size: 32px;
        cursor: pointer;
        transition: 0.12s ease;
      }
      .controls i:active {
        transform: scale(0.94);
      }
      .seekbar {
        height: 6px;
        background: rgba(255, 255, 255, 0.25);
        border-radius: 6px;
        position: relative;
        cursor: pointer;
        transition: height 0.2s ease;
      }
      .seekbar.active {
        height: 8px;
      }
      #progress {
        height: 100%;
        width: 0%;
        background: #fff;
        border-radius: 3px;
      }
      .timecodes {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        opacity: 0.7;
        margin-top: 4px;
      }
      #ytPlayer {
        position: absolute;
        top: 0;
        left: 0;
        width: 1px;
        height: 1px;
        opacity: 0.01;
      }
      .loading {
        text-align: center;
        padding: 20px;
        color: rgba(255, 255, 255, 0.7);
      }
      .search-results::-webkit-scrollbar {
        width: 6px;
      }
      .search-results::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }
      .search-results::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
      }
      
      .lyrics-toggle {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.15);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        z-index: 100;
      }
      
      .lyrics-toggle:hover {
        background: rgba(255, 255, 255, 0.25);
      }
      
      .lyrics-toggle i {
        font-size: 18px;
        color: white;
      }
      
      /* Lyrics view */
      .lyrics-info {
        flex: 1;
        display: none;
        flex-direction: column;
        justify-content: flex-start;
        padding-left: 0px;
        text-shadow: 0px 0px 12px rgba(0, 0, 0, 0.3);
      }
      
      .lyrics-content {
        max-height: 220px;
        overflow-y: auto;
        text-align: left;
        white-space: pre-line;
        padding-right: 10px;
        font-size: 16px;
        line-height: 1.6;
      }
      
      .lyrics-content::-webkit-scrollbar {
        width: 4px;
      }
      
      .lyrics-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }
      
      .lyrics-content::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
      }
      
      .lyrics-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        display: none;
      }
      
      .lyrics-title {
        font-size: 30px;
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 300px;
      }
      
      .lyrics-artist {
        font-size: 16px;
        opacity: 0.75;
        margin-bottom: 15px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 300px;
      }
      
      #volumeBtn {
        font-size: 20px;
      }
      </style>
  </head>
  <body>
    <div class="search-container">
      <input
        type="text"
        class="search-input"
        placeholder="Search for any song..."
        id="searchInput"
      />
    </div>

    <div class="search-results" id="searchResults">
    </div>

    <div class="player">
      <div class="album-art">
        <img
          src="/img/empty_art.png"
          alt="Album"
          id="albumCover"
          crossorigin="anonymous"
        />
      </div>
      <div class="info" id="playerInfo">
        <div class="track-title" id="trackTitle">Not Playing</div>
        <div class="artist" id="artistName">Not Playing</div>
        <div class="controls">
          <i id="playPause" class="fa-solid fa-play fa-lg control-btn"></i>
          <i id="volumeBtn" class="fa-solid fa-volume-high control-btn"></i>
        </div>
        <div id="seekbar" class="seekbar"><div id="progress"></div></div>
        <div class="timecodes">
          <span id="currentTime">0:00</span>
          <span id="remainingTime">-0:00</span>
        </div>
      </div>

      <div class="lyrics-info" id="lyricsInfo">
        <div class="lyrics-header">
          <div>
            <div class="lyrics-title" id="lyricsSongTitle">Not Playing</div>
            <div class="lyrics-artist" id="lyricsArtistName">Not Playing</div>
          </div>
        </div>
        <div class="lyrics-content" id="lyricsContent">
          No lyrics available.
        </div>
      </div>
    </div>

    <div class="lyrics-toggle" id="lyricsToggle">
      <i class="fa-solid fa-align-left"></i>
    </div>

    <div id="player-container">
      <div id="ytPlayer"></div>
    </div>

    <!-- Endpoints, By Bombardino Crocodilo-->
    <script>const YT_KEY = "AIzaSyDyS3-fRybg6VCIAoRzAt47PNnEVMOsODs";
        
        const LYRIC_EP = "https://api.lyrics.ovh/v1/";
        const YT_EP = "https://www.googleapis.com/youtube/v3/search?part=snippet&q=";
        const SEARCH_EP = "https://itunes.apple.com/search?term=";
        </script>

    <script>const searchInput = document.getElementById("searchInput");
        const searchResults = document.getElementById("searchResults");
        const trackTitle = document.getElementById("trackTitle");
        const artistName = document.getElementById("artistName");
        const albumCover = document.getElementById("albumCover");
        const playPauseBtn = document.getElementById("playPause");
        const volumeBtn = document.getElementById("volumeBtn");
        const seekBar = document.getElementById("seekbar");
        const progressBar = document.getElementById("progress");
        const currentTimeSpan = document.getElementById("currentTime");
        const remainingTimeSpan = document.getElementById("remainingTime");
        const lyricsToggle = document.getElementById("lyricsToggle");
        const playerInfo = document.getElementById("playerInfo");
        const lyricsInfo = document.getElementById("lyricsInfo");
        const lyricsSongTitle = document.getElementById("lyricsSongTitle");
        const lyricsArtistName = document.getElementById("lyricsArtistName");
        const lyricsContent = document.getElementById("lyricsContent");
        
        let showingLyrics = false;
        let isMuted = false;
        
        let player;
        let isPlaying = false;
        let isDragging = false;
        let searchTimeout;
        let currentTrack = {
          title: "Not Playing",
          artist: "Not Playing",
          artwork: "/img/empty_art.png",
        };
        
        const colorThief = new ColorThief();
        
        let currentColor = { r: 115, g: 98, b: 86 };
        let targetColor = { r: 115, g: 98, b: 86 };
        let animationId = null;
        </script>
    <script>function applyColors(color) {
        if (!color || !Array.isArray(color) || color.length < 3) {
          return;
        }
      
        targetColor = { r: color[0], g: color[1], b: color[2] };
      
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
      
        applyAnimation();
      }
      
      function applyAnimation() {
        const dr = (targetColor.r - currentColor.r) * 0.1;
        const dg = (targetColor.g - currentColor.g) * 0.1;
        const db = (targetColor.b - currentColor.b) * 0.1;
      
        currentColor.r += dr;
        currentColor.g += dg;
        currentColor.b += db;
      
        const r = Math.round(currentColor.r);
        const g = Math.round(currentColor.g);
        const b = Math.round(currentColor.b);
      
        const darkenAmount = 30;
        const endR = Math.max(0, r - darkenAmount);
        const endG = Math.max(0, g - darkenAmount);
        const endB = Math.max(0, b - darkenAmount);
      
        document.documentElement.style.setProperty(
          "--bg-start",
          `rgb(${r}, ${g}, ${b})`
        );
        document.documentElement.style.setProperty(
          "--bg-end",
          `rgb(${endR}, ${endG}, ${endB})`
        );
      
        const tolerance = 0.5;
        if (
          Math.abs(targetColor.r - currentColor.r) > tolerance ||
          Math.abs(targetColor.g - currentColor.g) > tolerance ||
          Math.abs(targetColor.b - currentColor.b) > tolerance
        ) {
          animationId = requestAnimationFrame(applyAnimation);
        } else {
          currentColor = { ...targetColor };
        }
      }
      </script>
    <script>const tag = document.createElement("script");
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName("script")[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        
        function onYouTubeIframeAPIReady() {
          player = new YT.Player("ytPlayer", {
            height: "360",
            width: "640",
            videoId: "-",
            playerVars: {
              playsinline: 1,
              controls: 0,
              enablejsapi: 1,
              modestbranding: 1,
              rel: 0,
              showinfo: 0,
            },
            events: {
              onReady: onPlayerReady,
              onStateChange: onPlayerStateChange,
            },
          });
        }
        
        function onPlayerReady(event) {
          console.log("Player is ready");
        
          playPauseBtn.addEventListener("click", togglePlayback);
          volumeBtn.addEventListener("click", toggleMute);
        
          seekBar.addEventListener("mousedown", startSeek);
          document.addEventListener("mousemove", dragSeek);
          document.addEventListener("mouseup", endSeek);
        
          setInterval(updateProgress, 500);
        
          if (albumCover.complete) {
            try {
              const dominantColor = colorThief.getColor(albumCover);
              applyColors(dominantColor);
            } catch (e) {
              console.error("Initial color extraction failed:", e);
            }
          } else {
            albumCover.onload = function () {
              try {
                const dominantColor = colorThief.getColor(albumCover);
                applyColors(dominantColor);
              } catch (e) {
                console.error("Initial color extraction failed:", e);
              }
            };
          }
        }
        
        function onPlayerStateChange(event) {
          console.log("Player state changed:", event.data);
        
          if (event.data === YT.PlayerState.PLAYING) {
            isPlaying = true;
            playPauseBtn.classList.remove("fa-play");
            playPauseBtn.classList.add("fa-pause");
          } else if (
            event.data === YT.PlayerState.PAUSED ||
            event.data === YT.PlayerState.ENDED
          ) {
            isPlaying = false;
            playPauseBtn.classList.remove("fa-pause");
            playPauseBtn.classList.add("fa-play");
          }
        }
        // Toggle Mute function
        function toggleMute() {
          if (!player) return;
        
          if (isMuted) {
            player.unMute();
            volumeBtn.className = "fa-solid fa-volume-high control-btn";
            isMuted = false;
          } else {
            player.mute();
            volumeBtn.className = "fa-solid fa-volume-xmark control-btn";
            isMuted = true;
          }
        }
        </script>
    <script>searchInput.addEventListener("input", function () {
        clearTimeout(searchTimeout);
      
        searchTimeout = setTimeout(() => {
          const query = searchInput.value.trim();
          if (query.length > 1) {
            searchSongs(query);
          } else {
            hideSearchResults();
          }
        }, 500);
      });
      
      searchInput.addEventListener("keypress", function (e) {
        if (e.key === "Enter") {
          clearTimeout(searchTimeout);
          const query = searchInput.value.trim();
          if (query.length > 1) {
            searchSongs(query);
          }
        }
      });
      
      function searchSongs(query) {
        searchResults.innerHTML = '<div class="loading">Searching...</div>';
        showSearchResults();
      
        const url = `${SEARCH_EP}${encodeURIComponent(query)}&media=music&limit=10`;
      
        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            console.log("iTunes search results:", data);
            displaySearchResults(data.results);
          })
          .catch((error) => {
            console.error("Error searching iTunes:", error);
            searchResults.innerHTML =
              '<div class="loading">Search failed. Please try again.</div>';
          });
      }
      
      function displaySearchResults(results) {
        if (!results || results.length === 0) {
          searchResults.innerHTML = '<div class="loading">No results found</div>';
          return;
        }
      
        searchResults.innerHTML = "";
      
        results.forEach((item) => {
          if (!item.trackName || !item.artistName) return;
      
          const resultElement = document.createElement("div");
          resultElement.className = "result-item";
          resultElement.innerHTML = `
            <div class="result-img">
              <img src="${item.artworkUrl100}" alt="${item.trackName}" crossorigin="anonymous">
            </div>
            <div class="result-info">
              <div class="result-title">${item.trackName}</div>
              <div class="result-artist">${item.artistName}</div>
            </div>
          `;
      
          resultElement.addEventListener("click", () => {
            playSong(item.trackName, item.artistName, item.artworkUrl100);
            hideSearchResults();
            searchInput.value = "";
          });
      
          searchResults.appendChild(resultElement);
        });
      }
      
      function showSearchResults() {
        searchResults.classList.add("active");
      }
      
      function hideSearchResults() {
        searchResults.classList.remove("active");
      }
      </script>
    <script>function playSong(title, artist, artwork) {
        trackTitle.textContent = title;
        artistName.textContent = artist;
      
        lyricsSongTitle.textContent = title;
        lyricsArtistName.textContent = artist;
      
        if (showingLyrics) {
          fetchLyrics(artist, title);
        }
      
        const highResArtwork = artwork.replace("100x100", "600x600");
      
        albumCover.crossOrigin = "anonymous";
        albumCover.src = highResArtwork;
      
        albumCover.onload = function () {
          try {
            const dominantColor = colorThief.getColor(albumCover);
            applyColors(dominantColor);
          } catch (e) {
            console.error("Color extraction failed:", e);
          }
        };
      
        currentTrack = {
          title: title,
          artist: artist,
          artwork: artwork,
        };
      
        const searchQuery = `${title} - ${artist}`;
        getYT(searchQuery);
      }
      
      function getYT(query) {
        const url = `${YT_EP}${encodeURIComponent(
          query
        )}&type=video&key=${YT_KEY}&maxResults=1`;
      
        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            console.log("YouTube search results:", data);
            if (data.items && data.items.length > 0) {
              const videoId = data.items[0].id.videoId;
              loadVid(videoId);
            } else {
              console.error("No YouTube results found");
            }
          })
          .catch((error) => {
            console.error("Error searching YouTube:", error);
          });
      }
      
      function loadVid(videoId) {
        if (player && player.loadVideoById) {
          player.loadVideoById(videoId);
          player.playVideo();
      
          if (isMuted) {
            player.mute();
          } else {
            player.unMute();
          }
        } else {
          console.error("YouTube player not ready");
        }
      }
      </script>
    <script>lyricsToggle.addEventListener("click", function () {
        showingLyrics = !showingLyrics;
      
        if (showingLyrics) {
          playerInfo.style.display = "none";
          lyricsInfo.style.display = "flex";
          fetchLyrics(currentTrack.artist, currentTrack.title);
          lyricsToggle.innerHTML = '<i class="fa-solid fa-music"></i>';
        } else {
          playerInfo.style.display = "flex";
          lyricsInfo.style.display = "none";
          lyricsToggle.innerHTML = '<i class="fa-solid fa-align-left"></i>';
        }
      });
      
      function fetchLyrics(artist, title) {
        lyricsSongTitle.textContent = title;
        lyricsArtistName.textContent = artist;
        lyricsContent.textContent = "Loading lyrics...";
      
        const cleanArtist = encodeURIComponent(artist.trim());
        const cleanTitle = encodeURIComponent(title.trim());
      
        fetch(`${LYRIC_EP}${cleanArtist}/${cleanTitle}`)
          .then((response) => {
            if (!response.ok) {
              throw new Error("Lyrics not found");
            }
            return response.json();
          })
          .then((data) => {
            if (data.lyrics) {
              const normalizedLyrics = data.lyrics.replace(/\n{3,}/g, "\n\n");
              const formattedLyrics = normalizedLyrics.replace(/\n/g, "<br>");
              lyricsContent.innerHTML = formattedLyrics;
            } else {
              lyricsContent.textContent = "No lyrics available.";
            }
          })
          .catch((error) => {
            console.error("Error fetching lyrics:", error);
            lyricsContent.textContent = "No lyrics available.";
          });
      }
      </script>
    <script>function togglePlayback() {
        console.log("Toggle playback called");
        if (!player) return;
      
        if (isPlaying) {
          player.pauseVideo();
        } else {
          player.playVideo();
        }
      }
      
      function startSeek(e) {
        isDragging = true;
        seekBar.classList.add("active");
        updateSeekPosition(e);
      }
      
      function dragSeek(e) {
        if (isDragging) {
          updateSeekPosition(e);
        }
      }
      
      function endSeek() {
        if (isDragging) {
          isDragging = false;
          seekBar.classList.remove("active");
        }
      }
      
      function updateSeekPosition(e) {
        if (!player || !player.getDuration) return;
      
        const rect = seekBar.getBoundingClientRect();
        const position = (e.clientX - rect.left) / rect.width;
        const percent = Math.min(Math.max(position, 0), 1);
      
        progressBar.style.width = percent * 100 + "%";
      
        const duration = player.getDuration();
        player.seekTo(percent * duration, true);
      }
      
      function updateProgress() {
        if (!player || !player.getDuration || isDragging) return;
      
        try {
          const duration = player.getDuration() || 0;
          const currentTime = player.getCurrentTime() || 0;
          const percent = (currentTime / duration) * 100;
      
          progressBar.style.width = percent + "%";
      
          currentTimeSpan.textContent = formatTime(currentTime);
          remainingTimeSpan.textContent = "-" + formatTime(duration - currentTime);
        } catch (error) {
          console.error("Error updating progress:", error);
        }
      }
      
      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60)
          .toString()
          .padStart(2, "0");
        return `${minutes}:${secs}`;
      }
      </script>

    <script>
      document.addEventListener("click", function (e) {
        if (!searchResults.contains(e.target) && e.target !== searchInput) {
          hideSearchResults();
        }
      });
    </script>
  </body>
</html>

```

css/all.css
```css
:root {
  --bg-start: #747474;
  --bg-end: #4b4b4b;
  --card-width: 540px; /* Not directly used by player anymore, but keep for reference */
  --card-height: 220px; /* Not directly used by player anymore */
  --sidebar-width: 300px; /* New variable for playlist sidebar */
}
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
body {
  min-height: 100vh;
  background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    sans-serif;
  color: #fff;
  transition: background 0.8s ease;
  overflow-x: hidden; /* Prevent horizontal scroll if content is too wide */
}

.app-container {
  display: flex;
  padding: 20px;
  width: 100%;
  /* min-height: calc(100vh - 40px); /* This sets a minimum, but flex items can still grow it */
  height: calc(100vh - 40px); /* Try setting a fixed height for the container */
  max-height: calc(100vh - 40px); /* And a max-height to prevent overflow */
  gap: 20px;
  box-sizing: border-box; /* Ensure padding is included in height calculation */
}

.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  /* Crucial: Allow main content to scroll if its content is too tall,
     but try to keep it from expanding app-container beyond viewport height. */
  overflow-y: auto;
  min-height: 0; /* Fix for flex item overflow issues in some browsers */
}

.search-container {
  width: 100%;
  max-width: 560px;
  margin-bottom: 20px;
  z-index: 100;
  position: relative; /* Changed from absolute */
}
.search-input {
  width: 100%;
  padding: 12px 20px;
  border-radius: 12px;
  border: none;
  font-family: "Inter", sans-serif;
  font-size: 16px;
  background: rgba(255, 255, 255, 0.15);
  color: #fff;
  outline: none;
  transition: all 0.2s ease;
  backdrop-filter: blur(5px);
}
.search-input::placeholder {
  color: rgba(255, 255, 255, 0.6);
}
.search-input:focus {
  background: rgba(255, 255, 255, 0.25);
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
}
.search-results {
  width: 100%; /* Match search input width */
  max-width: 560px; /* Match search input width */
  max-height: 400px;
  background: rgba(30, 30, 30, 0.65);
  backdrop-filter: blur(10px);
  border-radius: 8px;
  overflow-y: auto;
  opacity: 0;
  visibility: hidden;
  transition: all 0.2s ease;
  z-index: 99;
  position: absolute;
  top: calc(100% + 5px); /* Position below search input */
  left: 0;
  transform: translateY(-7px);
}
.search-results.active {
  opacity: 1;
  transform: translateY(0);
  visibility: visible;
}

/* Title for "Recent Searches" section in the dropdown */
.recent-searches-title {
  padding: 10px 16px 5px 16px;
  font-size: 12px; /* Made it slightly smaller */
  font-weight: 600; /* Made it a bit bolder */
  color: rgba(255, 255, 255, 0.7); /* Slightly more visible */
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08); /* Softer border */
  margin-bottom: 5px;
}

/* Individual recent search item */
.recent-search-item {
  /* .result-item class is also applied for base flex styling */
  display: flex;
  justify-content: space-between; /* Query left, button right */
  align-items: center;
  padding: 10px 16px; /* Consistent padding */
  /* cursor: default; /* Optional: override .result-item's cursor if only text is clickable */
}

.recent-search-item:hover {
  background-color: rgba(255, 255, 255, 0.08); /* Consistent hover */
}

/* The clickable query text */
.recent-search-query {
  flex-grow: 1;
  cursor: pointer;
  font-size: 15px; /* Match song title size or adjust */
  color: #fff; /* Brighter for better readability */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-right: 10px; /* Space before the X button */
}

/* The remove button for a recent search item */
.remove-recent-search-btn {
  /* .icon-action-btn class is applied for base styling (padding, border-radius) */
  /* We removed margin-left: auto from .icon-action-btn for this specific case if it was there,
     or ensure it doesn't apply if it's not needed due to justify-content: space-between */
  margin-left: 0; /* Explicitly override if .icon-action-btn has margin-left: auto */
  flex-shrink: 0;
}

.remove-recent-search-btn .icon.icon-close {
  /* .icon-action-btn .icon might set a default size (e.g., 16px) */
  width: 14px;  /* Adjust size as needed for the 'x' */
  height: 14px;
  background-color: rgba(255, 255, 255, 0.5); /* Dimmer for 'x' */
}

.remove-recent-search-btn:hover .icon.icon-close {
  background-color: #ff8080; /* Softer red on hover for 'x' */
}

.result-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  cursor: pointer;
  transition: background 0.2s;
  overflow: hidden;
}
.result-item:hover {
  background: rgba(255, 255, 255, 0.1);
}
.result-img {
  width: 60px;
  height: 60px;
  border-radius: 6px;
  overflow: hidden;
  margin-right: 16px;
  flex-shrink: 0;
}
.result-img img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.result-info {
  flex: 1;
  overflow: hidden; /* Ensure text ellipsis works */
  flex-grow: 1;
  margin-right: 8px;
}
.result-title {
  font-weight: 600;
  margin-bottom: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.result-artist {
  font-size: 14px;
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.player-area {
  display: flex;
  justify-content: center; /* Center the player itself */
  align-items: center; /* Vertically center if player-area has more height */
  width: 100%;
  margin-top: 20px; /* Space from search results or search bar */
  flex-grow: 1; /* Allow it to take space if main-content is taller */
}

.player {
  width: 570px; /* Fixed width for player */
  display: flex;
  align-items: center;
  gap: 28px;
  padding: 24px; /* Padding inside the player card */
  /* background: rgba(0,0,0,0.1); Optional: subtle background for player card */
  /* border-radius: 12px; Optional: rounded corners for player card */
}
.album-art {
  flex: 0 0 220px;
  height: 220px;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 20px rgba(0,0,0,0.3);
}
.album-art img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.info {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding-left: 0px;
  text-shadow: 0px 0px 12px rgba(0, 0, 0, 0.3);
  min-width: 0; /* Fix for flex item text overflow */
}

.track-title {
  font-size: 34px;
  font-weight: 700;
  margin-bottom: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; /* Let flexbox handle width */
}
.artist {
  font-size: 20px;
  opacity: 0.75;
  margin-bottom: 45px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; Let flexbox handle width */
}

.seekbar {
  height: 6px;
  background: rgba(255, 255, 255, 0.25);
  border-radius: 6px;
  position: relative;
  cursor: pointer;
  transition: height 0.2s ease;
}
.seekbar.active {
  height: 8px;
}
#progress {
  height: 100%;
  width: 0%;
  background: #fff;
  border-radius: 3px;
}
.timecodes {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  opacity: 0.7;
  margin-top: 4px;
}
#ytPlayer {
  position: absolute;
  top: -9999px; /* Move way off screen */
  left: -9999px;
  width: 1px;
  height: 1px;
  opacity: 0; /* Keep hidden */
}
.loading {
  text-align: center;
  padding: 20px;
  color: rgba(255, 255, 255, 0.7);
}
/* Custom Scrollbar Styles (these should already be present and apply to .playlist-content) */
.search-results::-webkit-scrollbar,
.lyrics-content::-webkit-scrollbar,
.playlist-content::-webkit-scrollbar {
  width: 8px; /* Slightly wider for better grab-ability if desired */
}
.search-results::-webkit-scrollbar-track,
.lyrics-content::-webkit-scrollbar-track,
.playlist-content::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px; /* Match thumb radius */
}
.search-results::-webkit-scrollbar-thumb,
.lyrics-content::-webkit-scrollbar-thumb,
.playlist-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.35); /* Slightly more visible thumb */
  border-radius: 4px;
}

/*
.playlist-content::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}
*/


/* Lyrics view */
.lyrics-info {
  flex: 1;
  display: none;
  flex-direction: column;
  justify-content: flex-start;
  text-shadow: 0px 0px 12px rgba(0, 0, 0, 0.3);
  min-width: 0;
  max-height: 220px; /* This should already be set to match album art */
  overflow: hidden; /* Ensures content that overflows max-height doesn't push parent */
}

.lyrics-content {
  flex-grow: 1;
  overflow-y: auto; /* This should already be there for lyrics scrolling */
  text-align: left;
  white-space: pre-line;
  padding-right: 10px;
  font-size: 16px;
  line-height: 1.6;
}

.lyrics-header {
  /* display: flex; */ /* Already flex from .lyrics-info if shown */
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  /* display: none; */ /* Control via .lyrics-info display */
}

.lyrics-title {
  font-size: 30px;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; */
}

.lyrics-artist {
  font-size: 16px;
  opacity: 0.75;
  margin-bottom: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; */
}


.controls {
  display: flex;
  align-items: center;
  gap: 16px; /* Adjusted gap if needed */
  margin-bottom: 18px;
}
.controls i { /* Base icon style in controls */
  cursor: pointer;
  transition: 0.12s ease;
}
.controls i:active {
  transform: scale(0.94);
}

#playPause { font-size: 32px; }
#prevBtn, #nextBtn { font-size: 26px; display: none; }
#volumeBtn { font-size: 20px; }
#loopBtn { font-size: 22px; } /* Assuming you want loop button size */
#likeBtn { font-size: 22px; }
#addToPlaylistBtn { font-size: 22px; } /* New Add to Playlist button */

/* Bottom Controls Bar (wrapper for lyrics and settings toggles) */
.bottom-controls-bar {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px; /* Space between toggles */
  z-index: 100; /* Ensure it's above other content but below modals */
}

.lyrics-toggle, .settings-toggle { /* Shared styles for these toggles */
  width: 40px;
  height: 40px;
  background: rgba(255, 255, 255, 0.15);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(5px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: all 0.2s ease;
}

.lyrics-toggle:hover, .settings-toggle:hover {
  background: rgba(255, 255, 255, 0.25);
}

.lyrics-toggle i, .settings-toggle i {
  background-color: white;
  width: 22px; /* Adjust if needed */
  height: 22px; /* Adjust if needed */
}



.icon {
display: inline-block;
width: 32px; /* Default width, can be overridden by ID */
height: 32px; /* Default height, can be overridden by ID */
background-color: white;
mask-repeat: no-repeat;
mask-position: center;
mask-size: contain;
-webkit-mask-repeat: no-repeat;
-webkit-mask-position: center;
-webkit-mask-size: contain;
transition: transform 0.1s ease, background-color 0.1s ease;
}

.icon:active {
transform: scale(0.94);
}

/* Optional: common styling for icon-only buttons if you have more */
.icon-button { /* You added this class to the button in HTML */
  background: none;
  border: none;
  cursor: pointer;
  padding: 6px; /* Example padding */
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}
.icon-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}
.icon-button .icon {
  width: 20px; /* Default icon size for icon-buttons */
  height: 20px;
  background-color: white;
}

/* New/Refined Styles for Action Buttons within list items */
.icon-action-btn { /* Common style for small icon buttons like remove/edit */
  background: none;
  border: none;
  padding: 5px; /* Adjust padding to control clickable area and spacing */
  cursor: pointer;
  display: inline-flex; /* Helps align icon inside */
  align-items: center;
  justify-content: center;
  border-radius: 50%; /* Make it circular */
  transition: background-color 0.2s ease;
  /* Position it to the right if desired within the playlist item flex layout */
  margin-left: auto; /* Pushes button to the far right of its flex container if .playlist-item is display:flex */
}

.icon-action-btn:hover {
  background-color: rgba(255, 255, 255, 0.1); /* Subtle hover effect */
}


.icon-action-btn .icon { /* Style for the icon INSIDE these action buttons */
  width: 16px;
  height: 16px;
  background-color: rgba(255, 255, 255, 0.7);
  transition: background-color 0.2s ease;
  pointer-events: none; /* <<<<<<<<<<<<<<<<<<< ADD THIS LINE */
}

.icon-action-btn:hover .icon {
  background-color: #ff6b6b; /* Change icon color on hover - e.g., red for delete */
}

.add-to-playlist-search-btn {
  flex-shrink: 0; /* Prevents the button from shrinking */
  /* .icon-action-btn already provides margin-left: auto and other base styles */
}

/* 4. Style the icon INSIDE the button for specific size */
.add-to-playlist-search-btn .icon.icon-plus-circle {
  width: 18px;  /* Or 16px to match other .icon-action-btn .icon, or 20px. Adjust to taste. */
  height: 18px; /* Match width */
}

.icon-github {
  mask-image: url('../img/icons/github.svg');
  -webkit-mask-image: url('../img/icons/github.svg');
  width: 16px; /* Adjust size as needed */
  height: 16px;
  background-color: rgba(255, 255, 255, 0.6); /* Adjust color for visibility in modal */
  flex-shrink: 0; /* Prevent shrinking */
}

.icon-settings {
  mask-image: url('../img/icons/settings.svg');
  -webkit-mask-image: url('../img/icons/settings.svg');
}

.icon-close {
  mask-image: url('../img/icons/close.svg');
  -webkit-mask-image: url('../img/icons/close.svg');
}

.icon-arrow-left {
  mask-image: url('../img/icons/arrow-left.svg');
  -webkit-mask-image: url('../img/icons/arrow-left.svg');
  /* background-color will be inherited or set by .sidebar-back-button .icon */
}
.icon-edit {
  mask-image: url('../img/icons/edit.svg');
  -webkit-mask-image: url('../img/icons/edit.svg');
}
.icon-trash {
  mask-image: url('../img/icons/trash.svg');
  -webkit-mask-image: url('../img/icons/trash.svg');
}

/* Add near other icon definitions */
.icon-shuffle {
  mask-image: url('../img/icons/shuffle.svg');
  -webkit-mask-image: url('../img/icons/shuffle.svg');
}

/* Add near .icon-loop.loop-active for active state styling */
.icon-shuffle.shuffle-active {
  background-color: #00ff88; /* Green color, same as active loop */
  transform: scale(1.1); /* Optional: visual feedback */
}

/* Adjust size for these small action buttons if needed */
.playlist-item-actions .icon {
    width: 1em; /* Or a fixed px value like 14px */
    height: 1em;
    background-color: currentColor; /* Inherit color from button */
}
.icon-play { mask-image: url('../img/icons/play.svg'); -webkit-mask-image: url('../img/icons/play.svg'); }
.icon-pause { mask-image: url('../img/icons/pause.svg'); -webkit-mask-image: url('../img/icons/pause.svg'); }
.icon-volume { mask-image: url('../img/icons/volume-loud.svg'); -webkit-mask-image: url('../img/icons/volume-loud.svg'); }
.icon-muted { mask-image: url('../img/icons/mute.svg'); -webkit-mask-image: url('../img/icons/mute.svg'); }
.icon-lyrics { mask-image: url('../img/icons/lyrics.svg'); -webkit-mask-image: url('../img/icons/lyrics.svg'); }
.icon-lyrics-on { mask-image: url('../img/icons/music.svg'); -webkit-mask-image: url('../img/icons/music.svg'); }
.icon-plus-circle {
  mask-image: url('../img/icons/plus-circle.svg');
  -webkit-mask-image: url('../img/icons/plus-circle.svg');

}
.icon-loop { /* Base style for the loop button - uses repeat.svg */
  mask-image: url('../img/icons/repeat.svg');
  -webkit-mask-image: url('../img/icons/repeat.svg');
  /* Default color is white (from .icon) */
}

/* New: Loop Playlist State (repeat.svg but green) */
.icon-loop.loop-playlist-active {
  /* Uses the default repeat.svg mask from .icon-loop */
  background-color: #00ff88; /* Green color */
  transform: scale(1.1); /* Optional: visual feedback, matches loop-song */
}

.icon-loop.loop-active { /* This class now specifically means "loop current song" */
  mask-image: url('../img/icons/repeat-1.svg'); /* with the "1" on it */
  -webkit-mask-image: url('../img/icons/repeat-1.svg');
  background-color: #00ff88; /* Green color */
  transform: scale(1.1); /* You already had this, good */
}

/* New Playlist Icons */
.icon-heart-empty {
mask-image: url('../img/icons/heart-empty.svg');
-webkit-mask-image: url('../img/icons/heart-empty.svg');

}
.icon-heart-filled {
mask-image: url('../img/icons/heart-filled.svg');
-webkit-mask-image: url('../img/icons/heart-filled.svg');
background-color: #ff6b6b; /* Liked color */

}

.icon-action-btn .icon-heart-filled {
  background-color: #ff6b6b; /* Use !important as a last resort, but often needed if other .icon styles are too general */
                                      /* Or try without !important first if the specificity is enough */
}

.icon-prev {
mask-image: url('../img/icons/prev.svg');
-webkit-mask-image: url('../img/icons/prev.svg');

}
.icon-next {
mask-image: url('../img/icons/next.svg');
-webkit-mask-image: url('../img/icons/next.svg');

}

/* Playlist Sidebar Styles - Focus here */
.playlist-sidebar {
  width: var(--sidebar-width);
  min-width: 280px;
  /* Important: Set a specific height or max-height for the sidebar.
     It should take available space in the flex container but not exceed it. */
  display: flex; /* Keep this to allow flex-grow on playlist-content */
  flex-direction: column; /* Keep this */
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(8px);
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  /* Core change: ensure sidebar doesn't grow beyond available vertical space */
  height: 100%; /* Take full height of its flex container slot if possible */
  max-height: 100%; /* Prevent it from exceeding the allocated height */
  overflow: hidden; /* This will hide any direct children overflow, forcing .playlist-content to scroll */
  min-height: 0; /* Another flexbox fix for potential overflow issues */
}

.playlist-sidebar-header {
  display: flex;
  /* justify-content: space-between; Keep this for overall structure */
  align-items: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  flex-shrink: 0;
  position: relative; /* <<<< ADD THIS: For absolute positioning of title if needed, or for easier centering with flex */
}

.playlist-sidebar-header h3 { /* The #sidebarTitle element */
  font-size: 18px;
  font-weight: 600;
  margin: 0; /* Reset default margins */

  /* --- Centering Logic --- */
  position: absolute;       /* <<<< METHOD 1: Absolute Positioning */
  left: 50%;                /* <<<< METHOD 1 */
  transform: translateX(-50%); /* <<<< METHOD 1 */
  /* OR */
  /* flex-grow: 1;          /* <<<< METHOD 2: Flexbox Centering (Remove if using METHOD 1) */
  /* text-align: center;    /* <<<< METHOD 2 (Remove if using METHOD 1) */

  /* Ensure it doesn't overlap buttons if title is too long */
  max-width: calc(100% - 80px); /* Adjust 80px based on combined width of your back and create buttons + margins */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Styles for the sidebar back button - REFINED (Ensure this part is correct) */
.playlist-sidebar-header .sidebar-back-button {
  background: none;
  border: none;
  cursor: pointer;
  /* margin-right: auto; REMOVE THIS LINE. We want the title to push against the create button. */
  margin-right: 10px; /* <<<< ADD THIS: Add some space between back button and title */
  
  /* --- Key changes for perfect circle and centering --- */
  width: 32px;
  height: 32px;
  padding: 0;
  border-radius: 50%;
  
  display: flex;
  align-items: center;
  justify-content: center;
  
  transition: background-color 0.2s ease;
  flex-shrink: 0; /* <<<< ADD THIS: Prevent back button from shrinking */
}

.playlist-sidebar-header .sidebar-back-button:hover {
  /* opacity: 0.8; Remove this, use background-color change instead for icon buttons */
  background-color: rgba(255, 255, 255, 0.1);
}

.playlist-sidebar-header .sidebar-back-button .icon {
  /* Icon size should be smaller than the button's width/height
     to fit comfortably within the circle. */
  width: 18px;  /* Adjust icon size */
  height: 18px; /* Adjust icon size */
  background-color: white; /* Icon color */
  /* No need for margins on the icon if the button is using flex to center it */
}


.playlist-sidebar-header .create-playlist-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  color: white;
  font-size: 20px;
  font-weight: bold;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  cursor: pointer;
  line-height: 28px; /* Align plus vertically */
  text-align: center;
  margin-left: auto; /* <<<< ADD THIS: Add some space between title and create button */
  flex-shrink: 0;   /* <<<< ADD THIS: Prevent create button from shrinking */
}

/* General list display for playlists and songs in playlist */
.playlist-list-container { /* Wrapper for the ul if needed, or style #playlistDisplayArea directly */
  flex-grow: 1;
  overflow-y: auto;
  min-height: 0;
  padding-right: 8px; /* Gap for scrollbar */
}
.playlist-list-container ul {
  list-style: none;
  padding: 0;
  margin: 0;
}


.create-playlist-btn:hover {
  background: rgba(255,255,255,0.2);
}

/* Individual Playlist Item (in the list of playlists) */
.playlist-overview-item {
  display: flex;
  align-items: center; /* Vertically align all children */
  padding: 12px 8px;
  margin-bottom: 8px;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: relative; /* For absolutely positioned elements if any, or just good practice */
}
.playlist-overview-item:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

.playlist-overview-item-artwork {
  width: 50px;
  height: 50px;
  border-radius: 4px;
  margin-right: 15px;
  object-fit: cover;
  flex-shrink: 0; /* Prevent artwork from shrinking */
}

.playlist-overview-item-info {
  flex-grow: 1;     /* Allow info to take available space */
  overflow: hidden;   /* Crucial: This will contain the ellipsis */
  min-width: 0;       /* ADD THIS: Important for flex items that need to shrink and allow ellipsis */
  margin-right: 8px; /* ADD THIS: Add some space between info and action buttons */
}
.playlist-overview-item-name {
  font-size: 16px;
  font-weight: 500;
  white-space: nowrap;         /* Keep on one line */
  overflow: hidden;            /* Hide overflow */
  text-overflow: ellipsis;     /* Show ellipsis */
  margin-bottom: 3px;
  /* max-width: is not strictly needed here if parent (.playlist-overview-item-info) handles overflow */
}

.playlist-overview-item-name.playing-playlist-title,
#sidebarTitle.playing-playlist-title { /* Target the h3 directly by its ID */
  color: #00ff88; /* Same green as playing song titles in playlist items */
  /* Optionally, add a bit more visual weight if desired */
  /* font-weight: 600; */ /* Or whatever your playing song title weight is */
}

.playlist-overview-item-count {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.7);
  white-space: nowrap; /* Prevent count from wrapping if playlist name is very short */
}

.playlist-item-actions {
  display: flex;        /* Ensure buttons are in a row */
  align-items: center;  /* Vertically align buttons if they have different heights */
  flex-shrink: 0;       /* Prevent the actions container from shrinking */
  margin-left: auto;    /* This pushes it to the right if not already there due to structure */
                          /* If it's already visually to the right, this might not be needed,
                             but it's a common pattern. We can remove it if .playlist-overview-item-info
                             with flex-grow:1 and min-width:0 handles the spacing correctly. */
}

/* Individual buttons inside actions */
.playlist-item-actions button {
  background: none;
  border: none;
  color: rgba(255,255,255,0.6);
  cursor: pointer;
  padding: 3px; /* Keep padding small */
  font-size: 14px; /* Or adjust to match icon size */
  /* margin-left: 5px; Remove individual margin if using gap on parent */
}

.playlist-item-actions button:not(:last-child) {
  margin-right: 4px; /* Space between buttons, or use gap on .playlist-item-actions if supported */
}


.playlist-item-actions button:hover {
    color: white;
}

/* Styling for input field when creating/renaming */
.playlist-name-input {
  width: calc(100% - 60px); /* Adjust based on sibling elements if any */
  padding: 8px;
  margin-bottom: 5px;
  background-color: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: white;
  border-radius: 4px;
  font-size: 16px;
}
.playlist-overview-item-info .playlist-name-input { /* When renaming inline */
  font-size: 16px;
  font-weight: 500;
  width: 100%;
}

/* Playlist content scrollbar (ensure it's styled nicely) */
#playlistDisplayArea::-webkit-scrollbar { width: 8px; }
#playlistDisplayArea::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 4px; }
#playlistDisplayArea::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.35); border-radius: 4px; }
#playlistDisplayArea {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.35) rgba(255, 255, 255, 0.05);
}

.playlist-content {
  flex-grow: 1; /* Allows this to take up remaining space in .playlist-sidebar - GOOD */
  overflow-y: auto; /* This enables the internal scrollbar - GOOD */
  min-height: 0; /* Flex item fix, ensures it can shrink and show scrollbar */
  padding-right: 8px; /* Adjust if scrollbar overlaps content slightly */
  scrollbar-width: thin; /* "auto" or "thin" */
  scrollbar-color: rgba(255, 255, 255, 0.35) rgba(255, 255, 255, 0.05); /* thumb track */
}


.playlist-item {
  display: flex;
  align-items: center;
  padding: 10px 5px; /* Base padding */
  margin-bottom: 8px;
  border-radius: 6px;
  cursor: pointer;
  background-color: transparent;
  user-select: none;
  /* Add transitions for smooth "sliding" and opacity change */
  transition: padding-top 0.15s ease-out, 
              padding-bottom 0.15s ease-out, 
              background-color 0.2s ease,
              opacity 0.15s ease-out; /* Added opacity transition */
}

.playlist-item:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

.playlist-item.playing {
  background-color: rgba(255, 255, 255, 0.15);
}
.playlist-item.playing .playlist-item-title {
    color: #00ff88;
}

.playlist-item-artwork {
  width: 45px;
  height: 45px;
  border-radius: 4px;
  margin-right: 12px;
  object-fit: cover;
  flex-shrink: 0;
  pointer-events: none; /* Make sure drag events go to the li */
}

.playlist-item-info {
  flex-grow: 1;
  overflow: hidden;
  pointer-events: none; /* Make sure drag events go to the li */
}

/* Styles for the item being dragged */
.playlist-item.dragging {
  opacity: 0.5; /* Make it semi-transparent */
  background: rgba(255,255,255,0.1); /* Optional: slight background change */
  /* box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Optional: lift effect */
}

/* Styles to create visual space when dragging over an item */
.playlist-item.show-gap-above {
  padding-top: 55px; /* Adjust this value: item height (approx 45px) + margin (8px) + small buffer */
                      /* This pushes the content of *this* item down, making space above it. */
}

.playlist-item.show-gap-below {
  padding-bottom: 55px; /* Same logic, makes space below this item's content. */
}

/* Styles for the playlist overview item being dragged */
.playlist-overview-item.dragging {
  opacity: 0.5;
  background: rgba(255,255,255,0.2); /* Consistent with song dragging */
  /* box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Optional */
}

/* Styles to create visual space when dragging over a playlist overview item */
.playlist-overview-item.show-gap-above {
  /* Adjust padding based on typical height of .playlist-overview-item */
  /* .playlist-overview-item padding: 12px 8px; margin-bottom: 8px; artwork height: 50px */
  /* Roughly 50px (art) + 2*12px (padding) + 8px (margin) = 82px. Let's use a bit less. */
  padding-top: 75px;
}

.playlist-overview-item.show-gap-below {
  padding-bottom: 75px;
}

.playlist-item-title {
font-size: 15px;
font-weight: 500;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
margin-bottom: 2px;
}

.playlist-item-artist {
font-size: 13px;
color: rgba(255, 255, 255, 0.7);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}

.empty-playlist-message {
text-align: center;
color: rgba(255, 255, 255, 0.6);
margin-top: 30px;
font-style: italic;
}

.playlist-item.dragging {
opacity: 0.5;
background: rgba(255,255,255,0.2);
}

/* Modal Styles - Updated for Glassmorphism */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  /* The overlay itself remains semi-transparent black to dim the background */
  background-color: rgba(0,0,0,0.4); /* Slightly less dark overlay maybe */
  /* backdrop-filter: blur(2px); /* Optional: blur the entire page behind the modal - can be performance heavy */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px; /* Add some padding so modal doesn't hit screen edges on small viewports */
}

.modal-content {
  /* Glassmorphism Background */
  background-color: rgba(255, 255, 255, 0.1); /* Very light, semi-transparent white */
  backdrop-filter: blur(15px) saturate(150%); /* Key for the frosted glass effect, adjust blur amount */
  -webkit-backdrop-filter: blur(15px) saturate(150%); /* For Safari */

  color: #f0f0f0; /* Adjust text color for readability on the new background */
  
  padding: 25px 30px;
  border-radius: 12px; /* Slightly larger radius can look nice */
  
  /* Subtle Border to define edges */
  border: 1px solid rgba(255, 255, 255, 0.18);

  width: 90%;
  max-width: 380px;
  
  /* Softer Shadow */
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.17); /* Softer, more diffused shadow */
  /* Or a simpler one: box-shadow: 0 4px 15px rgba(0,0,0,0.2); */

  position: relative;
  text-align: left;
  /* overflow: hidden; /* Can help if content inside tries to break border-radius with its own bg */
}

.close-modal-btn {
  color: rgba(255, 255, 255, 0.7); /* Adjust for new background */
  position: absolute;
  top: 12px; /* Adjust position slightly if needed */
  right: 15px;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
  transition: color 0.2s ease;
}
.close-modal-btn:hover,
.close-modal-btn:focus {
  color: white;
}

.modal-content h4 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 20px;
  font-weight: 600;
  text-align: center;
  color: #ffffff; /* Ensure title is clearly visible */
}

#modalPlaylistList {
  max-height: 200px;
  overflow-y: auto;
  margin-top: 10px;
  padding-right: 5px; /* Space for scrollbar if items are wide */
}

#modalPlaylistList .modal-playlist-item {
  padding: 10px 12px;
  cursor: pointer;
  border-radius: 6px; /* Match overall aesthetic */
  margin-bottom: 6px;
  font-size: 15px;
  color: #e0e0e0; /* Slightly softer than pure white */
  transition: background-color 0.2s ease, color 0.2s ease;
  /* Optional: add a very subtle divider if needed, or rely on hover */
  /* border-bottom: 1px solid rgba(255,255,255,0.05); */
}
/* #modalPlaylistList .modal-playlist-item:last-child {
  border-bottom: none; 
} */

#modalPlaylistList .modal-playlist-item:hover {
  background-color: rgba(255,255,255,0.15); /* Slightly lighter hover */
  color: #ffffff;
}

/* Scrollbar for modal playlist list - keep it subtle */
#modalPlaylistList::-webkit-scrollbar { width: 6px; }
#modalPlaylistList::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 3px; }
#modalPlaylistList::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.25); border-radius: 3px; } /* Slightly lighter thumb */
#modalPlaylistList::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.4); }
#modalPlaylistList {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.25) rgba(255, 255, 255, 0.05);
}

/* Styles for action buttons within the general modal */
#generalModalActions {
  margin-top: 20px;
  display: flex; /* For button layout */
  justify-content: center; /* Center buttons, or space-around/space-between */
  gap: 15px; /* Space between buttons */
}

.modal-button {
  padding: 10px 20px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-size: 15px;
  font-weight: 500;
  transition: background-color 0.2s ease, opacity 0.2s ease;
  min-width: 80px; /* Minimum width for buttons */
}

.modal-button.primary { /* For primary actions like "Delete", "Confirm" */
  background-color: #e53e3e; /* Example: Red for delete */
  color: white;
}
.modal-button.primary:hover {
  background-color: #c53030;
}

.modal-button.success { /* NEW: For positive actions like "Create", "Save" */
  background-color: #38A169; /* Green (Tailwind's green-600) */
  color: white;
}
.modal-button.success:hover {
  background-color: #2F855A; /* Darker Green (Tailwind's green-700) */
}

.modal-button.secondary { /* For secondary actions like "Cancel", "OK" for info */
  background-color: rgba(255, 255, 255, 0.15);
  color: #f0f0f0;
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.modal-button.secondary:hover {
  background-color: rgba(255, 255, 255, 0.25);
}

/* Styles for input fields within modals */
.modal-input {
  width: 100%;
  padding: 10px 12px;
  background-color: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #f0f0f0;
  border-radius: 6px;
  font-size: 15px;
  box-sizing: border-box; /* Ensure padding and border don't add to width */
}
.modal-input:focus {
  outline: none;
  border-color: rgba(255, 255, 255, 0.4);
  background-color: rgba(255, 255, 255, 0.1);
}

/* Specific styling for the create playlist modal actions if needed,
   otherwise the general #generalModalActions styling might be sufficient if adapted.
   The HTML above used text-align: right directly on #createPlaylistModalActions.
*/
#createPlaylistModalActions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px;
}

/* Adjust modal content for new layout if needed */
#createPlaylistModal .modal-content,
#editPlaylistModal .modal-content {
    max-width: 420px; /* Slightly wider if needed */
}

/* Styles for Modal Artwork Editor */
.modal-artwork-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-bottom: 20px;
}

/* Settings Modal Styles */
#settingsModal .modal-content {
  max-width: 480px; /* Or adjust as needed */
}

.settings-section {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid rgba(255,255,255,0.1); /* Apply border to ALL sections by default */
}

/* Now, specifically REMOVE the border from the section we marked */
.settings-section.last-content-section {
  border-bottom: none;
}

/* The footer's top border is still active and will create the line */
.settings-modal-footer {
  margin-top: 25px;
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.1); /* This is the key separator */
}


.settings-section h5 {
  font-size: 16px;
  font-weight: 600;
  margin-top: 0;
  margin-bottom: 8px;
  color: #f0f0f0;
}

.settings-description {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
  line-height: 1.5;
  margin-bottom: 12px;
}
.settings-description strong {
    color: #ffc107; /* Warning yellow or similar */
}

/* Settings Modal Footer for GitHub Info */
.settings-modal-footer {
  margin-top: 25px;
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
}

.settings-modal-footer .icon-github {
  margin-right: 2px; /* Slight adjustment from gap for visual balance */
}

.settings-modal-footer .commit-link {
  color: rgba(255, 255, 255, 0.7);
  text-decoration: none;
  transition: color 0.2s ease;
}
.settings-modal-footer .commit-link:hover {
  color: #ffffff;
  text-decoration: underline;
}

.settings-modal-footer #latestCommitSha {
  font-family: 'Courier New', Courier, monospace; /* Monospaced for SHA */
  background-color: rgba(255,255,255,0.08);
  padding: 2px 5px;
  border-radius: 3px;
}

.settings-modal-footer .commit-separator {
  color: rgba(255, 255, 255, 0.4);
}

.settings-modal-footer #latestCommitTimeAgo {
  min-width: 50px; /* Prevent layout jump as time string changes */
  text-align: left;
}


.file-drop-zone {
  border: 2px dashed rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 25px;
  text-align: center;
  cursor: pointer;
  background-color: rgba(255, 255, 255, 0.05);
  transition: background-color 0.2s ease, border-color 0.2s ease;
  margin-bottom: 10px;
}

.file-drop-zone:hover, .file-drop-zone.drag-over {
  background-color: rgba(255, 255, 255, 0.1);
  border-color: #00ff88; /* Accent color on hover/drag */
}

.drop-zone-prompt {
  color: rgba(255, 255, 255, 0.6);
  font-size: 14px;
}

#importDataBtn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.selected-file-name-display {
    font-size: 13px;
    color: rgba(255,255,255,0.7);
    margin-top: 8px;
    text-align: center;
    min-height: 1.2em; /* Prevent layout shift when text appears/disappears */
    word-break: break-all;
}



.playlist-artwork-editor {
  width: 120px; /* Adjust size as needed */
  height: 120px;
  border-radius: 8px;
  overflow: hidden;
  position: relative;
  cursor: pointer;
  background-color: rgba(0,0,0,0.2); /* Placeholder bg */
  margin-bottom: 10px;
  border: 1px dashed rgba(255,255,255,0.2); /* Visual cue for drop */
}

.modal-artwork-preview {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: filter 0.2s ease-in-out;
}

.playlist-artwork-editor .edit-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 0.2s ease-in-out;
  color: white;
  text-align: center;
  pointer-events: none; /* Let clicks pass through to editor div */
}

.playlist-artwork-editor:hover .edit-overlay {
  opacity: 1;
}
.playlist-artwork-editor:hover .modal-artwork-preview {
  filter: brightness(0.7);
}

.playlist-artwork-editor .edit-overlay .icon {
  width: 24px;
  height: 24px;
  margin-bottom: 5px;
}
.playlist-artwork-editor .edit-overlay span {
  font-size: 12px;
  padding: 0 5px;
}

.playlist-artwork-editor.drag-over {
  border-color: #00ff88; /* Highlight when dragging over */
  background-color: rgba(0,255,136,0.1);
}

.clear-artwork-btn {
  font-size: 13px;
  padding: 6px 12px !important; /* Ensure smaller padding */
  min-width: auto; /* Override general modal button min-width */
}

.modal-button.tertiary { /* For "Clear Artwork" button */
  background-color: rgba(255, 255, 255, 0.1);
  color: #ccc;
  border: 1px solid rgba(255, 255, 255, 0.15);
}
.modal-button.tertiary:hover {
  background-color: rgba(255, 255, 255, 0.18);
  color: white;
}

.form-group label { /* Style for labels above inputs */
    color: #ccc; /* Lighter than main text */
}

/* Toast Notifications (add towards the end of all.css) */
.toast-container {
  position: fixed;
  bottom: 20px; /* Adjust as needed, consider lyrics toggle */
  left: 50%;
  transform: translateX(-50%);
  z-index: 2000; /* Above most other elements */
  display: flex;
  flex-direction: column-reverse; /* New toasts appear above older ones if multiple */
  align-items: center;
  gap: 10px;
  pointer-events: none; /* Allow clicks to pass through the container itself */
}

.toast-message {
  /* Glassmorphism */
  background-color: rgba(50, 50, 50, 0.6); /* Darker semi-transparent for contrast */
  backdrop-filter: blur(10px) saturate(150%);
  -webkit-backdrop-filter: blur(10px) saturate(150%);
  color: #f0f0f0;
  padding: 12px 20px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
  font-size: 14px;
  font-weight: 500;
  text-align: center;
  max-width: 80vw; /* Prevent very wide toasts on large screens */

  opacity: 0;
  transform: translateY(30px) scale(0.95); /* Initial state for animation: off-screen and slightly smaller */
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
  pointer-events: auto; /* Toasts themselves are clickable/interactive if needed in future */
}

.toast-message.show {
  opacity: 1;
  transform: translateY(0) scale(1);
}

/* Credits Footer */
.credits-footer {
  position: fixed;
  bottom: 20px;
  left: 20px;
  padding: 8px 12px;
  border-radius: 8px;
  background: rgba(255, 255, 255, 0.1); /* Subtle light glass */
  backdrop-filter: blur(8px) saturate(120%);
  -webkit-backdrop-filter: blur(8px) saturate(120%);
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.65);
  font-size: 12px;
  font-weight: 400;
  z-index: 95; /* Below main controls (100) but above general background */
  transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  display: flex; /* For vertical alignment if needed, though simple text should align */
  align-items: center;
}

.credits-footer:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  background: rgba(255, 255, 255, 0.15); /* Slightly brighter on hover */
}

.credits-footer .credit-heart {
  color: #e74c3c; /* Red heart */
  display: inline-block; /* Allows transform */
  margin: 0 3px; /* Spacing around heart */
  transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); /* Bouncy transition */
}

.credits-footer:hover .credit-heart {
  transform: scale(1.3);
}

.credits-footer .credit-link {
  color: rgba(255, 255, 255, 0.85);
  text-decoration: none;
  font-weight: 500;
  transition: color 0.2s ease;
  margin-left: 3px; /* Spacing before link */
}

.credits-footer .credit-link:hover {
  color: #ffffff;
  text-decoration: underline;
} 

/* Responsive adjustments */
@media (max-width: 960px) { /* Adjust breakpoint as needed */
  .app-container {
    flex-direction: column;
    height: auto; /* Allow app container to grow if content is very tall */
    min-height: 100vh;
  }
.main-content {
  max-width: 100%; /* Allow main content to use full width */
  order: 1; /* Player first */
}
.playlist-sidebar {
  width: 100%;
  max-width: 570px; /* Or match player width */
  margin: 20px auto 0 auto; /* Center sidebar below player */
  order: 2; /* Playlist below player */
  height: auto; /* Auto height */
  max-height: 40vh; /* Limit height to prevent excessive scrolling */
}
.player {
  width: 100%; /* Make player responsive */
  max-width: 570px; /* Max width for player */
}
.search-container {
    max-width: 570px; /* Match player width */
}
.search-results {
    max-width: 570px; /* Match player width */
}




}

@media (max-width: 600px) {
  .player {
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 20px;
  }
  .album-art {
      flex-basis: auto; /* Allow it to shrink if needed */
      width: 180px;
      height: 180px;
  }
  .info {
      align-items: center; /* Center info content */
      text-align: center;
  }
  .track-title {
      font-size: 28px;
  }
  .artist {
      font-size: 18px;
      margin-bottom: 30px;
  }
  .lyrics-info {
      align-items: center;
      text-align: center;
  }
  .lyrics-title {
      font-size: 26px;
  }
  .lyrics-artist {
      font-size: 16px;
  }

  .credits-footer {
    font-size: 11px; /* Slightly smaller on very small screens */
    padding: 6px 10px;
    bottom: 15px;
    left: 15px;
  }
}
```

js/bg.js
```js
function applyColors(color) {
    if (!color || !Array.isArray(color) || color.length < 3) {
      return;
    }
  
    targetColor = { r: color[0], g: color[1], b: color[2] };
  
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
  
    applyAnimation();
  }
  
  function applyAnimation() {
    const dr = (targetColor.r - currentColor.r) * 0.1;
    const dg = (targetColor.g - currentColor.g) * 0.1;
    const db = (targetColor.b - currentColor.b) * 0.1;
  
    currentColor.r += dr;
    currentColor.g += dg;
    currentColor.b += db;
  
    const r = Math.round(currentColor.r);
    const g = Math.round(currentColor.g);
    const b = Math.round(currentColor.b);
  
    const darkenAmount = 30;
    const endR = Math.max(0, r - darkenAmount);
    const endG = Math.max(0, g - darkenAmount);
    const endB = Math.max(0, b - darkenAmount);
  
    document.documentElement.style.setProperty(
      "--bg-start",
      `rgb(${r}, ${g}, ${b})`
    );
    document.documentElement.style.setProperty(
      "--bg-end",
      `rgb(${endR}, ${endG}, ${endB})`
    );
  
    const tolerance = 0.5;
    if (
      Math.abs(targetColor.r - currentColor.r) > tolerance ||
      Math.abs(targetColor.g - currentColor.g) > tolerance ||
      Math.abs(targetColor.b - currentColor.b) > tolerance
    ) {
      animationId = requestAnimationFrame(applyAnimation);
    } else {
      currentColor = { ...targetColor };
    }
  }
  
```

js/endpoints.js
```js
// NB: Each YT Key gives 100 req/day (dev mode)

//const YT_KEY = "AIzaSyDyS3-fRybg6VCIAoRzAt47PNnEVMOsODs";
//const YT_KEY = "AIzaSyAgfWDE5zoRPZWx_BDuCQYFwIIdPOg1M0E";
const YT_KEYS = [
    'AIzaSyDyS3-fRybg6VCIAoRzAt47PNnEVMOsODs', // OGs
    'AIzaSyAgfWDE5zoRPZWx_BDuCQYFwIIdPOg1M0E' // @gmail
];

const RAPIDAPI_HOST = 'youtube-v3-alternative.p.rapidapi.com';
// https://rapidapi.com/ytdlfree/api/youtube-v3-alternative

// NB: Each Rapid Key gives 500 req/month

//const RAPIDAPI_KEY = '97ffa9c073mshdf976f56ef861b2p1294d8jsnb5302f45e8d8';
//const RAPIDAPI_KEY = '77c80e02acmshceeac2836195444p1415aejsn1ab385b54e75';
const RAPIDAPI_KEYS = [
    '14702a52c6msh8318e1e2125f434p11da50jsnab4512ddcf3f', // MK
    '97ffa9c073mshdf976f56ef861b2p1294d8jsnb5302f45e8d8', // @gmail
    '77c80e02acmshceeac2836195444p1415aejsn1ab385b54e75', // me@hydrovolter
    '742640eb4emsh8a1fff59e07f4b1p190938jsnd56db90aab6a', // contact@hydrovolter
    '5ff8bd8475mshe5e6e79c491683ap16d313jsn6d3c2370ff4b' // dmca@hydrovolter
];




const LYRIC_EP = "https://api.lyrics.ovh/v1/";
const YT_EP = "https://www.googleapis.com/youtube/v3/search?part=snippet&q=";
//const YT_EP = "https://api.hydrovolter.workers.dev/music/?part=snippet&q=";
const SEARCH_EP = "https://itunes.apple.com/search?term=";

```

js/getYT.js
```js
// --- Global Counters and API Keys (ensure these are defined globally) ---
// ... (Your existing global definitions for YT_EP, RAPIDAPI_HOST, YT_KEYS, RAPIDAPI_KEYS) ...

let apiCallCounter = 0; // Cycles between Google API and RapidAPI
let rapidApiKeyCounter = 0; // Tracks the current RapidAPI key index
let googleApiKeyCounter = 0; // Tracks the current Google API key index

// GOOGLE API
async function getYTGoogleAPI(query) {
    // Keep track of the starting key index for this attempt to prevent infinite loops
    const initialKeyIndex = googleApiKeyCounter % YT_KEYS.length;
    let attempts = 0;
    let foundVideo = false;
    let lastError = null;

    // Loop through all available Google API keys
    while (attempts < YT_KEYS.length && !foundVideo) {
        const currentKeyIndex = googleApiKeyCounter % YT_KEYS.length;
        const currentGoogleAPIKey = YT_KEYS[currentKeyIndex];

        console.log(`Google API: Attempting with key index ${currentKeyIndex} (Attempt ${attempts + 1}/${YT_KEYS.length})`);

        const url = `${YT_EP}${encodeURIComponent(
            query
        )}&type=video&videoEmbeddable=true&key=${currentGoogleAPIKey}&maxResults=1`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Google API HTTP error! status: ${response.status} for key index ${currentKeyIndex}`);
            }
            const data = await response.json();

            console.log("Youtube results (Google API):", data);
            if (data.items && data.items.length > 0) {
                const videoId = data.items[0].id.videoId;
                loadVid(videoId);
                foundVideo = true; // Mark as successful
                // No need to increment googleApiKeyCounter here; it will naturally advance on next getYTGoogleAPI call
                // because of the final increment after the loop.
            } else {
                lastError = new Error(`No YouTube results found (Google API) for key index ${currentKeyIndex}`);
                console.error(lastError.message);
            }
        } catch (error) {
            lastError = error;
            console.error(`Error searching YouTube (Google API) with key index ${currentKeyIndex}:`, error);
        }

        if (!foundVideo) {
            // Only increment to try the next key if the current one didn't find a video
            googleApiKeyCounter++;
            attempts++;
        }
    }

    if (foundVideo) {
        return Promise.resolve(true); // Resolve if a video was found
    } else {
        // If no video was found after all key attempts
        return Promise.reject(lastError || new Error("Google API exhausted all keys without success."));
    }
}

// youtube-v3-alternative RAPIDAPI
async function getYTRapidAPI(query) {
    const initialKeyIndex = rapidApiKeyCounter % RAPIDAPI_KEYS.length;
    let attempts = 0;
    let foundVideo = false;
    let lastError = null;

    // Loop through all available RapidAPI keys
    while (attempts < RAPIDAPI_KEYS.length && !foundVideo) {
        const currentKeyIndex = rapidApiKeyCounter % RAPIDAPI_KEYS.length;
        const currentRapidAPIKey = RAPIDAPI_KEYS[currentKeyIndex];

        console.log(`RapidAPI: Attempting with key index ${currentKeyIndex} (Attempt ${attempts + 1}/${RAPIDAPI_KEYS.length})`);

        const url = `https://${RAPIDAPI_HOST}/search?query=${encodeURIComponent(
            query
        )}&geo=US&lang=en`;

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'x-rapidapi-host': RAPIDAPI_HOST,
                    'x-rapidapi-key': currentRapidAPIKey,
                },
            });
            if (!response.ok) {
                throw new Error(`RapidAPI HTTP error! status: ${response.status} for key index ${currentKeyIndex}`);
            }
            const data = await response.json();

            console.log("RapidAPI Youtube results:", data);
            if (data && data.data && data.data.length > 0) {
                const videoId = data.data[0].videoId;
                if (videoId) {
                    loadVid(videoId);
                    foundVideo = true; // Mark as successful
                    // No need to increment rapidApiKeyCounter here; it will naturally advance on next getYTRapidAPI call
                } else {
                    lastError = new Error(`Could not extract video ID from RapidAPI results for key index ${currentKeyIndex}`);
                    console.error(lastError.message, data.data[0]);
                }
            } else {
                lastError = new Error(`No RapidAPI YouTube results found or unexpected data structure for key index ${currentKeyIndex}`);
                console.error(lastError.message);
            }
        } catch (error) {
            lastError = error;
            console.error(`Error searching RapidAPI YouTube with key index ${currentKeyIndex}:`, error);
        }

        if (!foundVideo) {
            // Only increment to try the next key if the current one didn't find a video
            rapidApiKeyCounter++;
            attempts++;
        }
    }

    if (foundVideo) {
        return Promise.resolve(true); // Resolve if a video was found
    } else {
        // If no video was found after all key attempts
        return Promise.reject(lastError || new Error("RapidAPI exhausted all keys without success."));
    }
}


// --- Main getYT function with fallback logic (remains largely the same) ---
async function getYT(query) {
    let searchSuccessful = false;

    // Determine the primary API for this call
    const primaryApiIsGoogle = (apiCallCounter % 2 === 0);

    if (primaryApiIsGoogle) {
        console.log("Attempting with Google API (Primary)...");
        try {
            await getYTGoogleAPI(query); // This will now try all Google keys internally
            searchSuccessful = true; // Primary attempt succeeded
        } catch (error) {
            console.warn("Google API failed after trying all its keys. Attempting with RapidAPI (Fallback)...", error);
            try {
                await getYTRapidAPI(query); // This will now try all RapidAPI keys internally
                searchSuccessful = true; // Fallback attempt succeeded
            } catch (fallbackError) {
                console.error("Both Google API (all keys) and RapidAPI (all keys) failed:", fallbackError);
            }
        }
    } else { // Primary API is RapidAPI
        console.log("Attempting with RapidAPI (Primary)...");
        try {
            await getYTRapidAPI(query); // This will now try all RapidAPI keys internally
            searchSuccessful = true; // Primary attempt succeeded
        } catch (error) {
            console.warn("RapidAPI failed after trying all its keys. Attempting with Google API (Fallback)...", error);
            try {
                await getYTGoogleAPI(query); // This will now try all Google keys internally
                searchSuccessful = true; // Fallback attempt succeeded
            } catch (fallbackError) {
                console.error("Both RapidAPI (all keys) and Google API (all keys) failed:", fallbackError);
            }
        }
    }

    // Only increment the main API counter if at least one API call was successful
    if (searchSuccessful) {
        apiCallCounter++;
    } else {
        console.warn("No video loaded after all attempts across both APIs and all their keys. Next getYT call will re-attempt the same primary API.");
    }
}
```

js/history.js
```js
// js/history.js

const RECENT_SEARCHES_KEY = 'musicPlayer_recentSearches';
const MAX_RECENT_SEARCHES = 3;

/**
 * Retrieves the list of recent search queries from localStorage.
 * @returns {string[]} An array of recent search queries.
 */
function getRecentSearches() {
    const storedSearches = localStorage.getItem(RECENT_SEARCHES_KEY);
    return storedSearches ? JSON.parse(storedSearches) : [];
}

/**
 * Adds a search query to the recent searches list.
 * Moves existing query to the top if already present.
 * Limits the list to MAX_RECENT_SEARCHES.
 * @param {string} query The search query to add.
 */
function addRecentSearch(query) {
    if (!query || typeof query !== 'string' || query.trim() === "") return;
    query = query.trim(); // Normalize

    let searches = getRecentSearches();
    // Remove the query if it already exists, to move it to the top (most recent)
    searches = searches.filter(s => s.toLowerCase() !== query.toLowerCase());
    // Add the new query to the beginning
    searches.unshift(query);
    // Limit the number of recent searches
    if (searches.length > MAX_RECENT_SEARCHES) {
        searches = searches.slice(0, MAX_RECENT_SEARCHES);
    }
    localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));
}

/**
 * Removes a specific search query from the recent searches list.
 * @param {string} queryToRemove The search query to remove.
 */
function removeRecentSearch(queryToRemove) {
    if (!queryToRemove || typeof queryToRemove !== 'string' || queryToRemove.trim() === "") return;
    queryToRemove = queryToRemove.trim();

    let searches = getRecentSearches();
    searches = searches.filter(s => s.toLowerCase() !== queryToRemove.toLowerCase());
    localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));

    // This function will be called from search.js, which can then decide to re-render
    // For example, after removing, if search input is focused and empty, search.js will call displayRecentSearches()
}
```

js/init.js
```js
// js/init.js

const searchInput = document.getElementById("searchInput");
const searchResults = document.getElementById("searchResults");
const trackTitle = document.getElementById("trackTitle");
const artistName = document.getElementById("artistName");
const albumCover = document.getElementById("albumCover");
const playPauseBtn = document.getElementById("playPause");
const volumeBtn = document.getElementById("volumeBtn");
const seekBar = document.getElementById("seekbar");
const progressBar = document.getElementById("progress");
const currentTimeSpan = document.getElementById("currentTime");
const remainingTimeSpan = document.getElementById("remainingTime");
const lyricsToggle = document.getElementById("lyricsToggle");
const lyricsIcon = lyricsToggle.querySelector("i");
const playerInfo = document.getElementById("playerInfo");
const lyricsInfo = document.getElementById("lyricsInfo");
const lyricsSongTitle = document.getElementById("lyricsSongTitle");
const lyricsArtistName = document.getElementById("lyricsArtistName");
const lyricsContent = document.getElementById("lyricsContent");
const loopBtn = document.getElementById("loopBtn");
const shuffleBtn = document.getElementById("shuffleBtn");


let showingLyrics = false;
let isMuted = false;
let loopState = 'none';
let isShuffleActive = false;

let player; // YouTube player instance
let isPlaying = false; // Player's playing state
let isDragging = false; // Seekbar dragging state
let searchTimeout;

// currentTrack will store details of the song currently loaded OR playing
let currentTrack = {
  id: null,       // Unique ID (e.g., iTunes trackId, crucial for liking)
  title: "Not Playing",
  artist: "Not Playing",
  artwork: "img/empty_art.png",    // URL to 100x100 artwork (for playlists, like button context)
  artworkLarge: "img/empty_art.png" // URL to 600x600 artwork (for main player display)
};

const colorThief = new ColorThief();

let currentColor = { r: 115, g: 98, b: 86 }; // Default bg color start
let targetColor = { r: 115, g: 98, b: 86 };  // Default bg color target
let animationId = null;

// --- Playlist System Variables ---
const LIKED_SONGS_PLAYLIST_ID = 'liked_songs';
const USER_PLAYLISTS_STORAGE_KEY = 'musicPlayer_userPlaylists';
const LIKED_PLAYLIST_STORAGE_KEY = 'musicPlayer_likedSongsPlaylist'; // Keep this for liked songs

// Storage Keys (already defined but good to list them here for context of what to export/import)
const APP_STORAGE_KEYS = [
  'musicPlayer_likedSongsPlaylist',
  'musicPlayer_userPlaylists',
  'musicPlayer_recentSearches'
  // Add any other localStorage keys specific to your app here
];

let likedPlaylist = []; // Holds {id, title, artist, artwork} for liked songs
let userPlaylists = []; // Holds {id, name, songs: [...]} for user-created playlists

let currentPlayingPlaylistId = null; // ID of the playing playlist (e.g., 'liked_songs', or a user playlist ID)
let currentPlaylistTrackIndex = -1;   // Index in the currentPlayingPlaylistId's song array

let currentSidebarView = 'all_playlists'; // 'all_playlists' or 'single_playlist_view'
let selectedPlaylistToViewId = null;  // ID of the playlist being viewed in the sidebar (not necessarily playing)

// DOM Elements for playlist system (to be fetched in playlist.js's initializePlaylistSystem)
let playlistDisplayAreaElement;
let sidebarTitleElement;
let backToPlaylistsBtnElement;
let createNewPlaylistBtnElement;
let addToPlaylistBtnElement;
let addToPlaylistModalElement;
let modalPlaylistListElement;
let closeModalAddToPlaylistBtnElement;
let likeBtnElement; // Will be grabbed in playlist.js
let prevBtnElement; // Will be grabbed in playlist.js
let nextBtnElement; // Will be grabbed in playlist.js

// DOM Elements for General Modal
let generalModalElement;
let generalModalTitleElement;
let generalModalMessageElement;
let generalModalActionsElement;
let closeGeneralModalBtnElement;

// DOM Elements for Create Playlist Modal
let createPlaylistModalElement;
let createPlaylistModalTitleElement; // Though title is static here, good practice
let newPlaylistNameInputElement;
let confirmCreatePlaylistBtnElement;
let cancelCreatePlaylistBtnElement;
let closeCreatePlaylistModalBtnElement;

let createPlaylistArtworkEditorElement;
let createPlaylistArtworkPreviewElement;
let createPlaylistArtworkInputElement;
let clearCreatePlaylistArtworkBtnElement;

// DOM Elements for Edit Playlist Modal (formerly Rename Playlist Modal)
let editPlaylistModalElement;         // Was renamePlaylistModalElement
let editPlaylistModalTitleElement;    // Was renamePlaylistModalTitleElement
let editPlaylistNameInputElement;     // Was renamePlaylistNameInputElement
let confirmEditPlaylistBtnElement;    // Was confirmRenamePlaylistBtnElement
let cancelEditPlaylistBtnElement;     // Was cancelRenamePlaylistBtnElement
let closeEditPlaylistModalBtnElement; // Was closeRenamePlaylistModalBtnElement
let playlistIdToEdit = null;          // Was playlistIdToRename
// New for edit playlist artwork
let editPlaylistArtworkEditorElement;
let editPlaylistArtworkPreviewElement;
let editPlaylistArtworkInputElement;
let clearEditPlaylistArtworkBtnElement;


// This variable will be used by modals.js to store the Data URL of
// the image selected in the currently active modal's artwork editor.
let currentModalArtworkDataUrl = null;

// NEW: DOM Elements for Settings
let settingsToggleElement;
let settingsModalElement;
let closeSettingsModalBtnElement;
let exportDataBtnElement;
let importFileDropZoneElement;
let importDataInputElement;
let importDataBtnElement;
let selectedFileNameElement;

let importedFileContent = null; // To store content of file selected for import

// --- START: New variables for GitHub commit info ---
let commitUpdateIntervalId = null;
let latestCommitTimestamp = null; // Stores the fetched commit date string
let githubCommitLinkElement = null; // To store the <a> tag reference
let latestCommitShaElement = null;
let latestCommitTimeAgoElement = null;
```

js/lyrics.js
```js
lyricsToggle.addEventListener("click", function () {
    showingLyrics = !showingLyrics;
  
    if (showingLyrics) {
      playerInfo.style.display = "none";
      lyricsInfo.style.display = "flex";
      fetchLyrics(currentTrack.artist, currentTrack.title);
      lyricsIcon.classList.remove("icon-lyrics");
      lyricsIcon.classList.add("icon-lyrics-on");
    } else {
      playerInfo.style.display = "flex";
      lyricsInfo.style.display = "none";
      lyricsIcon.classList.remove("icon-lyrics-on");
      lyricsIcon.classList.add("icon-lyrics");
    }
    
  });
  
  function fetchLyrics(artist, title) {
    lyricsSongTitle.textContent = title;
    lyricsArtistName.textContent = artist;
    lyricsContent.textContent = "Loading lyrics...";
  
    const cleanArtist = encodeURIComponent(artist.trim());
    const cleanTitle = encodeURIComponent(title.trim());
  
    fetch(`${LYRIC_EP}${cleanArtist}/${cleanTitle}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error("Lyrics not found");
        }
        return response.json();
      })
      .then((data) => {
        if (data.lyrics) {
          const normalizedLyrics = data.lyrics.replace(/\n{3,}/g, "\n\n");
          const formattedLyrics = normalizedLyrics.replace(/\n/g, "<br>");
          lyricsContent.innerHTML = formattedLyrics;
        } else {
          lyricsContent.textContent = "No lyrics available.";
        }
      })
      .catch((error) => {
        console.error("Error fetching lyrics:", error);
        lyricsContent.textContent = "No lyrics available.";
      });
  }
  
```

js/modals.js
```js
// Callbacks for confirm/cancel actions
let generalModalConfirmCallback = null; // Not strictly needed if callbacks are passed directly to buttons
let generalModalCancelCallback = null;  // Same as above

const MAX_ARTWORK_SIZE_BYTES = 2 * 1024 * 1024; // 2MB limit for Data URL before resize
const RESIZE_MAX_WIDTH = 300;
const RESIZE_MAX_HEIGHT = 300;


function initializeModals() {
    // Initialize General Modal Elements
    generalModalElement = document.getElementById('generalModal');
    generalModalTitleElement = document.getElementById('generalModalTitle');
    generalModalMessageElement = document.getElementById('generalModalMessage');
    generalModalActionsElement = document.getElementById('generalModalActions');
    closeGeneralModalBtnElement = document.getElementById('closeGeneralModal');

    if (!generalModalElement || !generalModalTitleElement || !generalModalMessageElement ||
        !generalModalActionsElement || !closeGeneralModalBtnElement) {
        console.error("General modal DOM elements not found. Modal functionality will be limited.");
    } else {
        closeGeneralModalBtnElement.addEventListener('click', closeGeneralModal);
        generalModalElement.addEventListener('click', (event) => {
            if (event.target === generalModalElement) closeGeneralModal();
        });
        console.log("General Modal system initialized.");
    }


    // Initialize Create Playlist Modal Elements
    createPlaylistModalElement = document.getElementById('createPlaylistModal');
    newPlaylistNameInputElement = document.getElementById('newPlaylistNameInput');
    confirmCreatePlaylistBtnElement = document.getElementById('confirmCreatePlaylistBtn');
    cancelCreatePlaylistBtnElement = document.getElementById('cancelCreatePlaylistBtn');
    closeCreatePlaylistModalBtnElement = document.getElementById('closeCreatePlaylistModal');
    // Artwork elements for Create modal
    createPlaylistArtworkEditorElement = document.getElementById('createPlaylistArtworkEditor');
    createPlaylistArtworkPreviewElement = document.getElementById('createPlaylistArtworkPreview');
    createPlaylistArtworkInputElement = document.getElementById('createPlaylistArtworkInput');
    clearCreatePlaylistArtworkBtnElement = document.getElementById('clearCreatePlaylistArtworkBtn');


    if (!createPlaylistModalElement || !newPlaylistNameInputElement || !confirmCreatePlaylistBtnElement ||
        !cancelCreatePlaylistBtnElement || !closeCreatePlaylistModalBtnElement ||
        !createPlaylistArtworkEditorElement || !createPlaylistArtworkPreviewElement ||
        !createPlaylistArtworkInputElement || !clearCreatePlaylistArtworkBtnElement) {
        console.error("Create Playlist modal DOM elements not found. This functionality will be limited.");
    } else {
        closeCreatePlaylistModalBtnElement.addEventListener('click', closeCreatePlaylistModal);
        cancelCreatePlaylistBtnElement.addEventListener('click', closeCreatePlaylistModal);
        confirmCreatePlaylistBtnElement.addEventListener('click', handleConfirmCreatePlaylist);
        createPlaylistModalElement.addEventListener('click', (event) => {
            if (event.target === createPlaylistModalElement) closeCreatePlaylistModal();
        });
        newPlaylistNameInputElement.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleConfirmCreatePlaylist();
            }
        });
        console.log("Create Playlist Modal system initialized.");
    }

    // Initialize Edit Playlist Modal Elements (formerly Rename)
    editPlaylistModalElement = document.getElementById('editPlaylistModal');
    editPlaylistModalTitleElement = document.getElementById('editPlaylistModalTitle');
    editPlaylistNameInputElement = document.getElementById('editPlaylistNameInput');
    confirmEditPlaylistBtnElement = document.getElementById('confirmEditPlaylistBtn');
    cancelEditPlaylistBtnElement = document.getElementById('cancelEditPlaylistBtn');
    closeEditPlaylistModalBtnElement = document.getElementById('closeEditPlaylistModal');
    // Artwork elements for Edit modal
    editPlaylistArtworkEditorElement = document.getElementById('editPlaylistArtworkEditor');
    editPlaylistArtworkPreviewElement = document.getElementById('editPlaylistArtworkPreview');
    editPlaylistArtworkInputElement = document.getElementById('editPlaylistArtworkInput');
    clearEditPlaylistArtworkBtnElement = document.getElementById('clearEditPlaylistArtworkBtn');


    if (!editPlaylistModalElement || !editPlaylistNameInputElement || !confirmEditPlaylistBtnElement ||
        !cancelEditPlaylistBtnElement || !closeEditPlaylistModalBtnElement || !editPlaylistModalTitleElement ||
        !editPlaylistArtworkEditorElement || !editPlaylistArtworkPreviewElement ||
        !editPlaylistArtworkInputElement || !clearEditPlaylistArtworkBtnElement) {
        console.error("Edit Playlist modal DOM elements not found. This functionality will be limited.");
    } else {
        closeEditPlaylistModalBtnElement.addEventListener('click', closeEditPlaylistModal);
        cancelEditPlaylistBtnElement.addEventListener('click', closeEditPlaylistModal);
        confirmEditPlaylistBtnElement.addEventListener('click', handleConfirmEditPlaylist);
        editPlaylistModalElement.addEventListener('click', (event) => {
            if (event.target === editPlaylistModalElement) closeEditPlaylistModal();
        });
        editPlaylistNameInputElement.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleConfirmEditPlaylist();
            }
        });
        console.log("Edit Playlist Modal system initialized.");
    }


    // Initialize Settings Modal
    initializeSettingsModal();
}

// --- Image Resizing Utility ---
function resizeImage(file, maxWidth, maxHeight, callback) {
    const reader = new FileReader();
    reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
            let width = img.width;
            let height = img.height;

            if (width > height) {
                if (width > maxWidth) {
                    height = Math.round(height * (maxWidth / width));
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width = Math.round(width * (maxHeight / height));
                    height = maxHeight;
                }
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            // Prefer JPEG for photos to control quality and size
            // Prefer PNG if transparency is important, but for album art, JPEG is often better.
            let dataUrl = canvas.toDataURL('image/jpeg', 0.85); // Adjust quality (0.0 to 1.0)
            if (dataUrl.length > MAX_ARTWORK_SIZE_BYTES && file.type === 'image/png') {
                // Fallback to PNG if JPEG is still too large (though unlikely if resize works)
                // Or try lower JPEG quality
                dataUrl = canvas.toDataURL('image/png');
            }
            callback(dataUrl);
        };
        img.onerror = () => {
            console.error("Error loading image for resize.");
            showToast("Error processing image.", 3000);
            callback(null); //  Indicate failure
        };
        img.src = e.target.result;
    };
    reader.onerror = () => {
        console.error("Error reading file for resize.");
        showToast("Error reading image file.", 3000);
        callback(null);
    };
    reader.readAsDataURL(file);
}

// --- Artwork Editor Setup ---
// currentModalArtworkDataUrl is now global in init.js
function setupArtworkEditor(
    editorContainerElement,
    previewImgElement,
    fileInputElement,
    clearButtonElement,
    existingPlaylistData // Pass the playlist object (or null if creating) to get default art
) {
    const updatePreviewAndState = (dataUrl) => {
        currentModalArtworkDataUrl = dataUrl; // Update global state for the current modal operation
        if (dataUrl) {
            previewImgElement.src = dataUrl;
            clearButtonElement.style.display = 'block';
        } else {
            // Determine default based on existingPlaylistData
            let defaultSrc = 'img/empty_art.png';
            if (existingPlaylistData && existingPlaylistData.songs && existingPlaylistData.songs.length > 0 && existingPlaylistData.songs[0].artwork) {
                defaultSrc = existingPlaylistData.songs[0].artwork;
            }
            previewImgElement.src = defaultSrc;
            clearButtonElement.style.display = 'none'; // Hide if showing default
        }
    };

    const handleFileSelect = (file) => {
        if (file && file.type.startsWith('image/')) {
            if (file.size > MAX_ARTWORK_SIZE_BYTES * 2) { // A bit more lenient before mandatory resize
                showToast("Image too large. Resizing...", 2000);
            }
            resizeImage(file, RESIZE_MAX_WIDTH, RESIZE_MAX_HEIGHT, (resizedDataUrl) => {
                if (resizedDataUrl) {
                    updatePreviewAndState(resizedDataUrl);
                } else {
                    // Resize failed, revert or keep old one if any
                    // For simplicity, let's stick to the previous state if resize fails
                    // updatePreviewAndState(currentModalArtworkDataUrl); // or show default
                }
            });
        } else if (file) {
            showToast("Invalid file type. Please select an image.", 3000);
        }
    };

    // Initial state for the editor
    let initialArtworkSrc = 'img/empty_art.png';
    let initialDataUrl = null;

    if (existingPlaylistData) { // For editing existing playlist
        if (existingPlaylistData.customArtwork) {
            initialArtworkSrc = existingPlaylistData.customArtwork;
            initialDataUrl = existingPlaylistData.customArtwork;
        } else if (existingPlaylistData.songs && existingPlaylistData.songs.length > 0 && existingPlaylistData.songs[0].artwork) {
            initialArtworkSrc = existingPlaylistData.songs[0].artwork;
            // initialDataUrl remains null because this isn't 'custom' user artwork yet
        }
    }
    previewImgElement.src = initialArtworkSrc;
    currentModalArtworkDataUrl = initialDataUrl; // Set global state for this modal
    clearButtonElement.style.display = initialDataUrl ? 'block' : 'none';


    // Event Listeners
    editorContainerElement.onclick = () => fileInputElement.click();
    fileInputElement.onchange = (event) => {
        handleFileSelect(event.target.files[0]);
        fileInputElement.value = ''; // Reset for next selection
    };

    editorContainerElement.ondragover = (event) => {
        event.preventDefault();
        editorContainerElement.classList.add('drag-over');
    };
    editorContainerElement.ondragleave = () => {
        editorContainerElement.classList.remove('drag-over');
    };
    editorContainerElement.ondrop = (event) => {
        event.preventDefault();
        editorContainerElement.classList.remove('drag-over');
        handleFileSelect(event.dataTransfer.files[0]);
    };

    clearButtonElement.onclick = (e) => {
        e.stopPropagation();
        updatePreviewAndState(null); // Clear custom artwork, show default
    };
}

function showGeneralModal(title, message, buttonsConfig = [], options = {}) { // Added options
    if (!generalModalElement || !generalModalTitleElement || !generalModalMessageElement || !generalModalActionsElement) {
        console.error("Cannot show general modal: elements not initialized.");
        alert(`${title}\n${message.replace(/<br\s*\/?>/gi, "\n").replace(/<strong>|<\/strong>/gi, "")}`);
        return;
    }

    // --- Z-INDEX FIX ---
    // If this modal is being shown 'on-top' of another, give it a higher z-index
    if (options.isOverlay) {
        generalModalElement.style.zIndex = '1001'; // Or higher if settingsModal is 1000
    } else {
        generalModalElement.style.zIndex = '1000'; // Default z-index
    }
    // --- END Z-INDEX FIX ---


    generalModalTitleElement.textContent = title;
    generalModalMessageElement.innerHTML = message;
    generalModalActionsElement.innerHTML = '';

    if (buttonsConfig.length === 0) {
        // ... (okButton logic)
        const okButton = document.createElement('button');
        okButton.textContent = 'OK';
        okButton.className = 'modal-button secondary';
        okButton.onclick = () => closeGeneralModal(options.isOverlay); // Pass overlay status
        generalModalActionsElement.appendChild(okButton);
    } else {
        buttonsConfig.forEach(btnConfig => {
            const button = document.createElement('button');
            button.textContent = btnConfig.text;
            button.className = `modal-button ${btnConfig.class || 'secondary'}`;
            button.onclick = () => {
                closeGeneralModal(options.isOverlay); // Pass overlay status & always close on button click
                if (btnConfig.callback && typeof btnConfig.callback === 'function') {
                    btnConfig.callback();
                }
            };
            generalModalActionsElement.appendChild(button);
        });
    }
    generalModalElement.style.display = 'flex';
}

function closeGeneralModal(wasOverlay = false) { // Added wasOverlay
    if (!generalModalElement) return;
    generalModalElement.style.display = 'none';
    // --- Z-INDEX FIX ---
    // Reset z-index if it was an overlay, so it doesn't interfere next time
    if (wasOverlay) {
        generalModalElement.style.zIndex = '1000'; // Reset to default
    }
    // --- END Z-INDEX FIX ---
}

function openCreatePlaylistModal() {
    if (!createPlaylistModalElement || !newPlaylistNameInputElement ||
        !createPlaylistArtworkEditorElement || !createPlaylistArtworkPreviewElement ||
        !createPlaylistArtworkInputElement || !clearCreatePlaylistArtworkBtnElement) return;

    newPlaylistNameInputElement.value = "My Playlist " + (typeof userPlaylists !== 'undefined' ? userPlaylists.length + 1 : 1);
    currentModalArtworkDataUrl = null; // Reset global temp state

    setupArtworkEditor(
        createPlaylistArtworkEditorElement,
        createPlaylistArtworkPreviewElement,
        createPlaylistArtworkInputElement,
        clearCreatePlaylistArtworkBtnElement,
        null // No existing playlist data for a new one
    );

    createPlaylistModalElement.style.display = 'flex';
    newPlaylistNameInputElement.focus();
    newPlaylistNameInputElement.select();
}

function closeCreatePlaylistModal() {
    if (!createPlaylistModalElement) return;
    createPlaylistModalElement.style.display = 'none';
    if(newPlaylistNameInputElement) newPlaylistNameInputElement.value = '';
    currentModalArtworkDataUrl = null; // Clear temp state
    // Reset artwork preview to absolute default
    if(createPlaylistArtworkPreviewElement) createPlaylistArtworkPreviewElement.src = 'img/empty_art.png';
    if(clearCreatePlaylistArtworkBtnElement) clearCreatePlaylistArtworkBtnElement.style.display = 'none';

}

function handleConfirmCreatePlaylist() {
    if (!newPlaylistNameInputElement) return;
    const playlistName = newPlaylistNameInputElement.value.trim();

    if (playlistName) {
        if (typeof createPlaylist === 'function') {
            // currentModalArtworkDataUrl holds the Data URL from the editor (or null)
            createPlaylist(playlistName, currentModalArtworkDataUrl);
            if (typeof renderAllPlaylistsView === 'function') {
                 renderAllPlaylistsView();
            }
            closeCreatePlaylistModal();
            showToast(`Playlist "${escapeModalHtml(playlistName)}" created!`, 3000);
        } else {
            console.error("createPlaylist function not found.");
            showGeneralModal("Error", "Could not create playlist. Functionality missing.");
        }
    } else {
        showGeneralModal("Invalid Name", "Playlist name cannot be empty.");
    }
}

// Renamed from openRenamePlaylistModal
function openEditPlaylistModal(currentPlaylistId, currentName) {
    if (!editPlaylistModalElement || !editPlaylistNameInputElement || !editPlaylistModalTitleElement ||
        !editPlaylistArtworkEditorElement || !editPlaylistArtworkPreviewElement ||
        !editPlaylistArtworkInputElement || !clearEditPlaylistArtworkBtnElement) return;

    const playlistToEdit = typeof getPlaylistById === 'function' ? getPlaylistById(currentPlaylistId) : null;
    if (!playlistToEdit) {
        console.error("Playlist to edit not found:", currentPlaylistId);
        showGeneralModal("Error", "Could not find playlist to edit.");
        return;
    }

    playlistIdToEdit = currentPlaylistId; // Store the ID (global from init.js)
    editPlaylistModalTitleElement.textContent = `Edit "${escapeModalHtml(currentName)}"`;
    editPlaylistNameInputElement.value = currentName;
    currentModalArtworkDataUrl = playlistToEdit.customArtwork; // Initialize with existing custom art

    setupArtworkEditor(
        editPlaylistArtworkEditorElement,
        editPlaylistArtworkPreviewElement,
        editPlaylistArtworkInputElement,
        clearEditPlaylistArtworkBtnElement,
        playlistToEdit // Pass existing playlist data
    );

    editPlaylistModalElement.style.display = 'flex';
    editPlaylistNameInputElement.focus();
    editPlaylistNameInputElement.select();
}

// Renamed from closeRenamePlaylistModal
function closeEditPlaylistModal() {
    if (!editPlaylistModalElement) return;
    editPlaylistModalElement.style.display = 'none';
    if(editPlaylistNameInputElement) editPlaylistNameInputElement.value = '';
    playlistIdToEdit = null;
    currentModalArtworkDataUrl = null; // Clear temp state
    // Reset artwork preview to absolute default
    if(editPlaylistArtworkPreviewElement) editPlaylistArtworkPreviewElement.src = 'img/empty_art.png';
    if(clearEditPlaylistArtworkBtnElement) clearEditPlaylistArtworkBtnElement.style.display = 'none';
}

// Renamed from handleConfirmRenamePlaylist
function handleConfirmEditPlaylist() {
    if (!editPlaylistNameInputElement || !playlistIdToEdit) return;

    const newPlaylistName = editPlaylistNameInputElement.value.trim();
    const oldPlaylistData = typeof getPlaylistById === 'function' ? getPlaylistById(playlistIdToEdit) : null;
    const oldName = oldPlaylistData ? oldPlaylistData.name : "";

    // currentModalArtworkDataUrl holds the new Data URL (or null if cleared, or existing if unchanged by user)

    if (!newPlaylistName) {
        showGeneralModal("Invalid Name", "Playlist name cannot be empty.");
        return;
    }

    if (newPlaylistName !== oldName || (oldPlaylistData && oldPlaylistData.customArtwork !== currentModalArtworkDataUrl) || currentModalArtworkDataUrl === null && oldPlaylistData.customArtwork !== null) {
        if (typeof updatePlaylistDetails === 'function') { // updatePlaylistDetails is from playlist.js
            updatePlaylistDetails(playlistIdToEdit, newPlaylistName, currentModalArtworkDataUrl);
            closeEditPlaylistModal();
            showToast(`Playlist "${escapeModalHtml(newPlaylistName)}" updated!`, 3000);
        } else {
            console.error("updatePlaylistDetails function not found.");
            showGeneralModal("Error", "Could not update playlist. Functionality missing.");
        }
    } else { // No changes made
        closeEditPlaylistModal();
    }
}

// --- Settings Modal ---
// --- Settings Modal ---
function initializeSettingsModal() {
    settingsToggleElement = document.getElementById('settingsToggle');
    settingsModalElement = document.getElementById('settingsModal');
    closeSettingsModalBtnElement = document.getElementById('closeSettingsModal');
    exportDataBtnElement = document.getElementById('exportDataBtn');
    importFileDropZoneElement = document.getElementById('importFileDropZone');
    importDataInputElement = document.getElementById('importDataInput');
    importDataBtnElement = document.getElementById('importDataBtn');
    selectedFileNameElement = document.getElementById('selectedFileName');

    // --- START: Initialize GitHub info elements ---
    githubCommitLinkElement = document.getElementById('githubCommitLink');
    latestCommitShaElement = document.getElementById('latestCommitSha');
    latestCommitTimeAgoElement = document.getElementById('latestCommitTimeAgo');
    // --- END: Initialize GitHub info elements ---

    if (!settingsToggleElement || !settingsModalElement || !closeSettingsModalBtnElement ||
        !exportDataBtnElement || !importFileDropZoneElement || !importDataInputElement ||
        !importDataBtnElement || !selectedFileNameElement ||
        !githubCommitLinkElement || !latestCommitShaElement || !latestCommitTimeAgoElement) { // Add new elements to check
        console.error("One or more settings modal DOM elements not found. Settings functionality disabled/limited.");
        return;
    }

    settingsToggleElement.addEventListener('click', openSettingsModal);
    closeSettingsModalBtnElement.addEventListener('click', closeSettingsModal);
    settingsModalElement.addEventListener('click', (event) => {
        if (event.target === settingsModalElement) closeSettingsModal();
    });

    exportDataBtnElement.addEventListener('click', exportUserData);

    // Import File Handling
    // ... (existing import event listeners) ...
    importFileDropZoneElement.addEventListener('click', () => importDataInputElement.click());
    importDataInputElement.addEventListener('change', handleFileSelectedForImport);

    importFileDropZoneElement.addEventListener('dragover', (event) => {
        event.preventDefault();
        importFileDropZoneElement.classList.add('drag-over');
    });
    importFileDropZoneElement.addEventListener('dragleave', () => {
        importFileDropZoneElement.classList.remove('drag-over');
    });
    importFileDropZoneElement.addEventListener('drop', (event) => {
        event.preventDefault();
        importFileDropZoneElement.classList.remove('drag-over');
        if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
            handleFileSelectedForImport({ target: { files: event.dataTransfer.files } });
            event.dataTransfer.clearData();
        }
    });

    importDataBtnElement.addEventListener('click', confirmAndProcessImport);


    console.log("Settings Modal system initialized.");
}

async function fetchLatestCommitInfo() {
    if (!latestCommitShaElement || !latestCommitTimeAgoElement || !githubCommitLinkElement) return;

    latestCommitShaElement.textContent = 'loading...';
    latestCommitTimeAgoElement.textContent = '';
    githubCommitLinkElement.href = "https://github.com/Hydrovolter/Music"; // Default link

    try {
        const response = await fetch('https://api.github.com/repos/Hydrovolter/Music/commits?per_page=1');
        if (!response.ok) {
            throw new Error(`GitHub API error! Status: ${response.status}`);
        }
        const data = await response.json();
        if (data && data.length > 0) {
            const commit = data[0];
            const shortSha = commit.sha.substring(0, 7);
            latestCommitTimestamp = commit.commit.committer.date; // Store for ticking

            latestCommitShaElement.textContent = shortSha;
            githubCommitLinkElement.href = commit.html_url; // Link to the commit page
            latestCommitTimeAgoElement.title = new Date(latestCommitTimestamp).toLocaleString(); // Full date in title

            updateCommitTimeAgo(); // Initial display
            if (commitUpdateIntervalId) clearInterval(commitUpdateIntervalId); // Clear previous interval if any
            commitUpdateIntervalId = setInterval(updateCommitTimeAgo, 1000); // Update every second
        } else {
            throw new Error("No commit data received.");
        }
    } catch (error) {
        console.error("Failed to fetch latest commit info:", error);
        latestCommitShaElement.textContent = 'unavailable';
        latestCommitTimeAgoElement.textContent = '';
        if(githubCommitLinkElement) githubCommitLinkElement.href = "https://github.com/Hydrovolter/Music/commits";
    }
}

function formatTimeAgoSimple(dateString) {
    if (!dateString) return "";
    const date = new Date(dateString);
    const now = new Date();
    const seconds = Math.round((now - date) / 1000);
    const minutes = Math.round(seconds / 60);
    const hours = Math.round(minutes / 60);
    const days = Math.round(hours / 24);
    const months = Math.round(days / 30.44); // Average days in month
    const years = Math.round(days / 365.25);

    if (seconds < 60) return `${seconds}s`;
    if (minutes < 60) return `${minutes}m`;
    if (hours < 24) return `${hours}h`;
    if (days < 30) return `${days}d`;
    if (months < 12) return `${months}mo`;
    return `${years}y`;
}

function updateCommitTimeAgo() {
    if (latestCommitTimestamp && latestCommitTimeAgoElement) {
        latestCommitTimeAgoElement.textContent = formatTimeAgoSimple(latestCommitTimestamp);
    }
}

function openSettingsModal() {
    if (!settingsModalElement) return;
    // Reset import UI
    importedFileContent = null;
    if(importDataInputElement) importDataInputElement.value = '';
    if(selectedFileNameElement) selectedFileNameElement.textContent = '';
    if(importDataBtnElement) importDataBtnElement.disabled = true;
    
    settingsModalElement.style.display = 'flex';
    fetchLatestCommitInfo(); // Fetch commit info when modal opens
}

function closeSettingsModal() {
    if (!settingsModalElement) return;
    settingsModalElement.style.display = 'none';
    importedFileContent = null;

    // --- START: Clear GitHub interval and reset info ---
    if (commitUpdateIntervalId) {
        clearInterval(commitUpdateIntervalId);
        commitUpdateIntervalId = null;
    }
    latestCommitTimestamp = null;
    if (latestCommitShaElement) latestCommitShaElement.textContent = '';
    if (latestCommitTimeAgoElement) latestCommitTimeAgoElement.textContent = '';
    if (githubCommitLinkElement) githubCommitLinkElement.href = "https://github.com/Hydrovolter/Music"; // Reset link
}

// --- Export Functionality ---
function exportUserData() {
    const dataToExport = {};
    APP_STORAGE_KEYS.forEach(key => { // APP_STORAGE_KEYS from init.js
        const item = localStorage.getItem(key);
        if (item !== null) { // Only include keys that actually exist
            try {
                // Attempt to parse to ensure it's valid JSON if we want to store it as object,
                // but for export, storing raw string is fine. For re-importing as JSON later, it's good.
                dataToExport[key] = JSON.parse(item);
            } catch (e) {
                dataToExport[key] = item; // Store as string if not parseable (shouldn't happen for our app data)
            }
        }
    });

    if (Object.keys(dataToExport).length === 0) {
        showToast("No data to export.", 3000);
        return;
    }

    const jsonString = JSON.stringify(dataToExport, null, 2); // Pretty print JSON
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const timestamp = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
    a.download = `music_player_data_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast("Data exported successfully!", 3000);
}

// --- Import Functionality ---
function handleFileSelectedForImport(event) {
    const file = event.target.files[0];
    if (file) {
        if (file.type === "application/json" || file.name.endsWith(".json")) {
            const reader = new FileReader();
            reader.onload = (e) => {
                importedFileContent = e.target.result; // Store the raw string content
                if(selectedFileNameElement) selectedFileNameElement.textContent = `Selected: ${file.name}`;
                if(importDataBtnElement) importDataBtnElement.disabled = false;
            };
            reader.onerror = (e) => {
                showToast("Error reading file.", 3000);
                importedFileContent = null;
                if(selectedFileNameElement) selectedFileNameElement.textContent = '';
                if(importDataBtnElement) importDataBtnElement.disabled = true;
            };
            reader.readAsText(file);
        } else {
            showToast("Invalid file type. Please select a .json file.", 3000);
            importedFileContent = null;
            if(selectedFileNameElement) selectedFileNameElement.textContent = '';
            if(importDataBtnElement) importDataBtnElement.disabled = true;
            if(importDataInputElement) importDataInputElement.value = ''; // Clear file input
        }
    }
}

function confirmAndProcessImport() {
    const fileContentToProcess = importedFileContent; // Capture current value
    console.log("confirmAndProcessImport called. fileContentToProcess CAPTURED:", fileContentToProcess ? fileContentToProcess.substring(0,50) + "..." : "null");

    if (!fileContentToProcess) {
        showToast("No file selected for import.", 3000);
        return;
    }

    showGeneralModal(
        "Confirm Import",
        "Warning: Importing data will override your current playlists and app data. This action cannot be undone.<br><br>Are you sure you want to proceed?",
        [
            {
                text: 'Proceed with Import',
                class: 'primary',
                callback: () => { // Use an arrow function to ensure 'this' context if needed, and to pass the captured content
                    processImportedData(fileContentToProcess); // Pass the captured content
                }
            },
            {
                text: 'Cancel',
                class: 'secondary'
            }
        ],
        { isOverlay: true }
    );
}

function processImportedData(fileContentForProcessing) {
    console.log("processImportedData CALLED. fileContentForProcessing:", fileContentForProcessing ? fileContentForProcessing.substring(0, 50) + "..." : "null");
    if (!fileContentForProcessing) {
        showToast("Import failed: No file content was provided to process.", 3000);
        return;
    }

    let parsedDataFromFile; // Declare here to be accessible in finally if needed for reset

    try {
        parsedDataFromFile = JSON.parse(fileContentForProcessing);

        // --- BEGIN ENHANCED VALIDATION ---
        if (typeof parsedDataFromFile !== 'object' || parsedDataFromFile === null) {
            throw new Error("Invalid file structure: Data is not a valid JSON object.");
        }

        // Check if at least one of the expected app storage keys exists at the top level of the imported object.
        const hasAtLeastOneAppKey = APP_STORAGE_KEYS.some(key => parsedDataFromFile.hasOwnProperty(key));
        if (!hasAtLeastOneAppKey) {
            throw new Error("Invalid file structure: Does not contain recognizable application data.");
        }

        // Optional: More specific validation for each key's expected type (e.g., arrays)
        APP_STORAGE_KEYS.forEach(key => {
            if (parsedDataFromFile.hasOwnProperty(key)) {
                const LIKED_PLAYLIST_STORAGE_KEY_CONST = "musicPlayer_likedSongsPlaylist";
                const USER_PLAYLISTS_STORAGE_KEY_CONST = "musicPlayer_userPlaylists";
                const RECENT_SEARCHES_KEY_CONST = "musicPlayer_recentSearches";

                if ((key === LIKED_PLAYLIST_STORAGE_KEY_CONST ||
                     key === USER_PLAYLISTS_STORAGE_KEY_CONST ||
                     key === RECENT_SEARCHES_KEY_CONST) &&
                    !Array.isArray(parsedDataFromFile[key])) {
                    throw new Error(`Invalid file structure: Data for "${key}" is not an array.`);
                }
                // Add more type checks if other keys have specific expected types (e.g., object, string, number)
            }
        });
        // --- END ENHANCED VALIDATION ---

        // Clear existing app-specific localStorage data
        APP_STORAGE_KEYS.forEach(key => {
            localStorage.removeItem(key);
        });

        // Apply imported data to localStorage
        APP_STORAGE_KEYS.forEach(key => {
            if (parsedDataFromFile.hasOwnProperty(key)) {
                localStorage.setItem(key, JSON.stringify(parsedDataFromFile[key]));
                console.log(`Imported and set localStorage for: ${key}`);
            }
        });

        // --- Crucial: Reset and Reload application state ---
        // (Your extensive reset logic remains here...)
        // 1. Stop current playback & clear player state
        if (typeof player !== 'undefined' && player && typeof player.stopVideo === 'function') {
            player.stopVideo();
        }
        if (typeof clearPlayerStateOnEnd === 'function') { clearPlayerStateOnEnd(); }
        isPlaying = false;
        if (playPauseBtn) {
            playPauseBtn.classList.remove("icon-pause"); playPauseBtn.classList.add("icon-play");
        }

        // 2. Reset current track displayed in player UI
        currentTrack = {
            id: null, title: "Not Playing", artist: "Not Playing",
            artwork: "img/empty_art.png", artworkLarge: "img/empty_art.png", durationSeconds: 0
        };
        if(trackTitle) trackTitle.textContent = currentTrack.title;
        if(artistName) artistName.textContent = currentTrack.artist;
        if(albumCover) {
            albumCover.src = currentTrack.artworkLarge;
            albumCover.onload = () => { if(typeof applyColors === 'function') applyColors([115, 98, 86]); };
        }
        if(typeof applyColors === 'function') applyColors([115, 98, 86]);
        if (showingLyrics && typeof lyricsContent !== 'undefined') {
            if(lyricsSongTitle) lyricsSongTitle.textContent = "Not Playing";
            if(lyricsArtistName) lyricsArtistName.textContent = "Not Playing";
            lyricsContent.textContent = "No lyrics available.";
        }
        if(typeof updateLikeButtonState === 'function') updateLikeButtonState();

        // 3. Clear any active playlist context
        if (typeof clearPlaylistContext === 'function') {
            clearPlaylistContext();
        } else {
            currentPlayingPlaylistId = null; currentPlaylistTrackIndex = -1;
            isShuffleActive = false; loopState = 'none';
            if(typeof updatePlaylistControlsVisibility === 'function') updatePlaylistControlsVisibility();
            if(typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon();
            if(typeof updateLoopButtonIcon === 'function') updateLoopButtonIcon();
        }

        // 4. Re-initialize the playlist system
        if (typeof initializePlaylistSystem === 'function') {
            initializePlaylistSystem();
        } else {
            console.error("initializePlaylistSystem function not found.");
        }

        // 5. Refresh recent searches
        if (typeof searchInput !== 'undefined' && searchInput === document.activeElement && searchInput.value.trim() === "" && typeof displayRecentSearches === 'function') {
            displayRecentSearches();
        }
        
        // This toast is only reached if all try block operations succeed
        showToast("Data imported successfully! UI refreshed.", 3500);
        closeSettingsModal(); 

    } catch (error) { // Catch JSON.parse errors or errors thrown by custom validation
        console.error("Error processing imported file:", error);
        // Provide a more user-friendly message, potentially including parts of the error message
        let userErrorMessage = "Import failed: Invalid file format or content.";
        if (error.message.startsWith("Invalid file structure:")) {
            userErrorMessage = `Import failed: ${error.message}`;
        } else if (error instanceof SyntaxError) { // Specifically for JSON.parse errors
             userErrorMessage = "Import failed: File is not valid JSON.";
        }
        showToast(userErrorMessage, 4000);
    } finally {
        // This block always runs, regardless of try/catch outcome
        importedFileContent = null;
        if(importDataInputElement) importDataInputElement.value = '';
        if(selectedFileNameElement) selectedFileNameElement.textContent = '';
        if(importDataBtnElement) importDataBtnElement.disabled = true;
    }
}




// Helper function for escaping HTML (can live here or in a general utils.js)
// Make sure this is accessible if other files need it, or they have their own.
function escapeModalHtml(unsafe) {
    if (typeof unsafe !== 'string') {
        return unsafe === null || typeof unsafe === 'undefined' ? '' : String(unsafe);
    }
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
}
```

js/play.js
```js
// js/play.js

// artworkUrl is expected to be the 100x100 version
// trackId should be a string if provided
function playSong(title, artist, artworkUrl, trackId = null, durationSeconds = 0) {
    const newTrackId = trackId ? trackId.toString() : `${title}-${artist}`.toLowerCase().replace(/\s+/g, '-');
  
    currentTrack = {
        id: newTrackId,
        title: title,
        artist: artist,
        artwork: artworkUrl,
        artworkLarge: artworkUrl ? artworkUrl.replace("100x100", "600x600") : 'img/empty_art.png',
        // --- BEGIN MODIFICATION: Store durationSeconds ---
        durationSeconds: durationSeconds || 0 // Store it, default to 0 if not provided
        // --- END MODIFICATION ---
    };
  
    trackTitle.textContent = currentTrack.title;
    artistName.textContent = currentTrack.artist;
  
    lyricsSongTitle.textContent = currentTrack.title;
    lyricsArtistName.textContent = currentTrack.artist;
  
    if (showingLyrics) {
        fetchLyrics(currentTrack.artist, currentTrack.title);
    }
  
    albumCover.crossOrigin = "anonymous";
    albumCover.src = currentTrack.artworkLarge;
  
    albumCover.onload = function () {
        if (albumCover.src && !albumCover.src.endsWith('img/empty_art.png')) {
            try {
                const dominantColor = colorThief.getColor(albumCover);
                applyColors(dominantColor);
            } catch (e) {
                console.error("Color extraction failed (onload):", e);
                applyColors([100, 100, 100]);
            }
        } else {
             applyColors([115, 98, 86]);
        }
    };
    albumCover.onerror = function() {
        console.error("Failed to load album art:", currentTrack.artworkLarge);
        applyColors([100, 100, 100]);
        albumCover.src = 'img/empty_art.png';
    };
  
    if (typeof updateLikeButtonState === 'function') {
        updateLikeButtonState();
    }
  
    const searchQuery = `${currentTrack.title} - ${currentTrack.artist}`;
    getYT(searchQuery);
  }

function loadVid(videoId) {
  // player is global from init.js (and player.js)
  // isMuted is global from init.js
  if (player && typeof player.loadVideoById === 'function') {
      player.loadVideoById(videoId);
      // Autoplay is handled by YouTube API or onPlayerStateChange (YT.PlayerState.CUED)

      if (isMuted && typeof player.mute === 'function') {
          player.mute();
      } else if (typeof player.unMute === 'function' && !isMuted) { // only unmute if not muted
          player.unMute();
      }
  } else {
      console.error("YouTube player not ready or loadVideoById not available.");
  }
}
```

js/playback.js
```js
function togglePlayback() {
    console.log("Toggle playback called");
    if (!player) return;
  
    if (isPlaying) {
      player.pauseVideo();
    } else {
      player.playVideo();
    }
  }
  
  function startSeek(e) {
    isDragging = true;
    seekBar.classList.add("active");
    updateSeekPosition(e);
  }
  
  function dragSeek(e) {
    if (isDragging) {
      updateSeekPosition(e);
    }
  }
  
  function endSeek() {
    if (isDragging) {
      isDragging = false;
      seekBar.classList.remove("active");
    }
  }
  
  function updateSeekPosition(e) {
    if (!player || !player.getDuration) return;
  
    const rect = seekBar.getBoundingClientRect();
    const position = (e.clientX - rect.left) / rect.width;
    const percent = Math.min(Math.max(position, 0), 1);
  
    progressBar.style.width = percent * 100 + "%";
  
    const duration = player.getDuration();
    player.seekTo(percent * duration, true);
  }
  
  function updateProgress() {
    if (!player || !player.getDuration || isDragging) return;
  
    try {
      const duration = player.getDuration() || 0;
      const currentTime = player.getCurrentTime() || 0;
      const percent = (currentTime / duration) * 100;
  
      progressBar.style.width = percent + "%";
  
      currentTimeSpan.textContent = formatTime(currentTime);
      remainingTimeSpan.textContent = "-" + formatTime(duration - currentTime);
    } catch (error) {
      console.error("Error updating progress:", error);
    }
  }
  
  function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60)
      .toString()
      .padStart(2, "0");
    return `${minutes}:${secs}`;
  }
  
```

js/player.js
```js
// js/player.js

// YouTube Iframe API setup (tag, firstScriptTag) - unchanged
const tag = document.createElement("script");
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName("script")[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

function onYouTubeIframeAPIReady() {
  player = new YT.Player("ytPlayer", { // player is global
    height: "1",
    width: "1",
    videoId: "-",
    playerVars: {
      playsinline: 1,
      controls: 0,
      enablejsapi: 1,
      modestbranding: 1,
      rel: 0,
      showinfo: 0,
      autoplay: 0,
    },
    events: {
      onReady: onPlayerReady,
      onStateChange: onPlayerStateChange,
      onError: onPlayerError
    },
  });
}

function onPlayerReady(event) {
  console.log("Player is ready");

  // playPauseBtn, volumeBtn, loopBtn are global from init.js
  // seekBar is global from init.js
  playPauseBtn.addEventListener("click", togglePlayback); // togglePlayback is global from playback.js
  volumeBtn.addEventListener("click", toggleMute);
  loopBtn.addEventListener("click", toggleLoop);
  if (shuffleBtn) shuffleBtn.addEventListener("click", toggleShuffle);

  seekBar.addEventListener("mousedown", startSeek); // startSeek from playback.js
  document.addEventListener("mousemove", dragSeek); // dragSeek from playback.js
  document.addEventListener("mouseup", endSeek);   // endSeek from playback.js

  setInterval(updateProgress, 500); // updateProgress from playback.js
  updateLoopButtonIcon(); // Initialize loop button icon based on global loopState
  updateShuffleButtonIcon();

  // Initial color logic - unchanged
  if (albumCover.complete && albumCover.src && !albumCover.src.endsWith('img/empty_art.png')) {
    try {
      const dominantColor = colorThief.getColor(albumCover);
      applyColors(dominantColor);
    } catch (e) {
      console.error("Initial color extraction failed (already complete):", e);
      applyColors([100,100,100]);
    }
  } else if (albumCover.src && albumCover.src.endsWith('img/empty_art.png')) {
    applyColors([115, 98, 86]);
  }
}

// Updates the visual state of the loop button based on global 'loopState'
function updateLoopButtonIcon() {
    if (!loopBtn) return; // loopBtn is global
    loopBtn.classList.remove('loop-active', 'loop-playlist-active');

    if (loopState === 'song') {
        loopBtn.classList.add('loop-active'); // For repeat-1.svg, green
    } else if (loopState === 'playlist') {
        loopBtn.classList.add('loop-playlist-active'); // For repeat.svg, green
    }
    // If 'none', no extra class, uses default .icon-loop style
}

// Manages cycling through loop states
function toggleLoop() {
    if (!player) return; // player is global

    // currentPlayingPlaylistId is global from init.js
    // likedPlaylist and userPlaylists are global from init.js
    const activePlaylist = getPlaylistById(currentPlayingPlaylistId); // from playlist.js
    const playlistIsEffectivelyActive = activePlaylist && activePlaylist.songs && activePlaylist.songs.length > 0;

    if (playlistIsEffectivelyActive) {
        if (loopState === 'none') loopState = 'playlist';
        else if (loopState === 'playlist') loopState = 'song';
        else loopState = 'none'; // 'song' -> 'none'
    } else { // No playlist active, or active playlist is empty
        if (loopState === 'none') loopState = 'song';
        else loopState = 'none'; // 'song' -> 'none'
    }
    console.log("Loop state changed to:", loopState, "| Playlist active for looping:", playlistIsEffectivelyActive);
    updateLoopButtonIcon();
}

function onPlayerStateChange(event) {
  console.log("Player state:", event.data, "| Loop:", loopState, "| Shuffle:", isShuffleActive, "| PlaylistID:", currentPlayingPlaylistId, "| TrackIdx:", currentPlaylistTrackIndex);

  if (event.data === YT.PlayerState.PLAYING) {
    isPlaying = true;
    playPauseBtn.classList.remove("icon-play");
    playPauseBtn.classList.add("icon-pause");
  } else if (event.data === YT.PlayerState.PAUSED) {
    isPlaying = false;
    playPauseBtn.classList.remove("icon-pause");
    playPauseBtn.classList.add("icon-play");
  } else if (event.data === YT.PlayerState.ENDED) {
    isPlaying = false;
    playPauseBtn.classList.remove("icon-pause");
    playPauseBtn.classList.add("icon-play");

    if (loopState === 'song' && player) {
      player.seekTo(0, true);
      player.playVideo();
    } else if (isShuffleActive && currentPlayingPlaylistId) { // SHUFFLE takes precedence over simple playlist next
        playNextTrackInCurrentPlaylist(); // This will use shuffle logic
    } else if (currentPlayingPlaylistId && typeof getPlaylistById === 'function' && typeof playNextTrackInCurrentPlaylist === 'function') {
        // Non-shuffled playlist logic
        const currentPlaylist = getPlaylistById(currentPlayingPlaylistId);
        if (currentPlaylist && currentPlaylist.songs && currentPlaylist.songs.length > 0) {
            const isLastTrack = currentPlaylistTrackIndex >= currentPlaylist.songs.length - 1;
            if (loopState === 'playlist') {
                playNextTrackInCurrentPlaylist();
            } else if (loopState === 'none' && !isLastTrack) {
                playNextTrackInCurrentPlaylist();
            } else {
                clearPlayerStateOnEnd();
            }
        } else {
             clearPlayerStateOnEnd();
        }
    } else {
      clearPlayerStateOnEnd();
    }
  } else if (event.data === YT.PlayerState.CUED && currentTrack && currentTrack.id !== null && !isPlaying) {
    if (player && typeof player.playVideo === 'function') player.playVideo();
  }
}

function clearPlayerStateOnEnd() {
    // progressBar, currentTimeSpan, remainingTimeSpan are global
    // formatTime is from playback.js
    if(progressBar) progressBar.style.width = "0%";
    if(currentTimeSpan) currentTimeSpan.textContent = formatTime(0);
    if (player && typeof player.getDuration === 'function') {
        const duration = player.getDuration();
        if(remainingTimeSpan) remainingTimeSpan.textContent = "-" + formatTime(duration || 0);
    } else {
        if(remainingTimeSpan) remainingTimeSpan.textContent = "-0:00";
    }
    // Optionally, clear current track display if desired, but typically not needed
    // as the UI still shows the last played song until a new one starts.
}

function onPlayerError(event) {
    console.error("YouTube Player Error:", event.data, "Song:", currentTrack ? currentTrack.title : "N/A");
    isPlaying = false;
    if (playPauseBtn) {
        playPauseBtn.classList.remove("icon-pause");
        playPauseBtn.classList.add("icon-play");
    }

    if (event.data === 101 || event.data === 150) {
      if (typeof showGeneralModal === 'function') {
          // Use escapeModalHtml from modals.js if available, or a local/global escapeHtml
          const songTitle = currentTrack ? (typeof escapeModalHtml === 'function' ? escapeModalHtml(currentTrack.title) : currentTrack.title) : "This song";
          showGeneralModal(
              "Playback Error",
              `"${songTitle}" cannot be played due to video embedding restrictions by the owner.`
          );
      } else {
          alert(`Error: "${currentTrack ? currentTrack.title : "This song"}" cannot be played due to embedding restrictions.`);
      }
  }

    if (loopState === 'playlist' && currentPlayingPlaylistId && typeof playNextTrackInCurrentPlaylist === 'function') {
        console.warn("Player error, attempting next track due to 'loop playlist' state.");
        playNextTrackInCurrentPlaylist();
    } else if (loopState === 'song' && (event.data === 101 || event.data === 150)) {
        // If looping a song that causes an embedding error, stop looping it.
        console.warn("Embedding error on a looping song. Disabling loop for this track.");
        loopState = 'none';
        updateLoopButtonIcon();
        clearPlayerStateOnEnd();
    } else if (loopState !== 'song') { // If not looping the current song (which would retry itself)
        clearPlayerStateOnEnd();
    }
    // If loopState is 'song' and it's a different error, it will try to replay and likely error again.
    // A counter for repeated errors on the same song might be useful for breaking such loops.
}

// Toggle Mute function
function toggleMute() {
  if (!player || typeof player.isMuted !== 'function') return;
  // isMuted is global
  // volumeBtn is global
  if (player.isMuted()) {
    player.unMute();
    volumeBtn.classList.remove("icon-muted");
    volumeBtn.classList.add("icon-volume");
    isMuted = false;
  } else {
    player.mute();
    volumeBtn.classList.remove("icon-volume");
    volumeBtn.classList.add("icon-muted");
    isMuted = true;
  }
}

// --- SHUFFLE FUNCTIONS ---
function updateShuffleButtonIcon() {
  if (!shuffleBtn) return;
  if (isShuffleActive) {
      shuffleBtn.classList.add('shuffle-active');
  } else {
      shuffleBtn.classList.remove('shuffle-active');
  }
}

function toggleShuffle() {
  if (!currentPlayingPlaylistId) { // Shuffle only makes sense with an active playlist
      // Optionally inform user or just do nothing
      console.warn("Shuffle toggled but no active playlist.");
      isShuffleActive = false; // Ensure it's off
      updateShuffleButtonIcon();
      return;
  }

  isShuffleActive = !isShuffleActive;
  console.log("Shuffle state changed to:", isShuffleActive);

  if (isShuffleActive) {
      // If shuffle is activated, and a playlist is playing, initialize shuffle queues
      const playlist = getPlaylistById(currentPlayingPlaylistId);
      if (playlist && playlist.songs.length > 0) {
          // Pass the currently playing track's ID so it can be handled correctly
          const currentTrackIdForShuffle = currentTrack && currentTrack.id ? currentTrack.id : null;
          initializeShuffleQueues(playlist.songs, currentTrackIdForShuffle);
      } else {
          // Playlist became empty or invalid, turn shuffle off
          isShuffleActive = false;
      }
  } else {
      // Shuffle turned off, clear queues
      shuffleUpcomingQueue = [];
      shufflePlayedQueue = [];
  }
  updateShuffleButtonIcon();
  // No need to immediately play next song; current song continues.
  // The next/prev or song end logic will use the new shuffle state.
}
```

js/playlist.js
```js
// js/playlist.js

// --- INITIALIZATION ---
function initializePlaylistSystem() {
    // Fetch DOM Elements
    playlistDisplayAreaElement = document.getElementById('playlistDisplayArea');
    sidebarTitleElement = document.getElementById('sidebarTitle');
    backToPlaylistsBtnElement = document.getElementById('backToPlaylistsBtn');
    createNewPlaylistBtnElement = document.getElementById('createNewPlaylistBtn');
    addToPlaylistBtnElement = document.getElementById('addToPlaylistBtn');
    addToPlaylistModalElement = document.getElementById('addToPlaylistModal');
    modalPlaylistListElement = document.getElementById('modalPlaylistList');
    closeModalAddToPlaylistBtnElement = document.getElementById('closeAddToPlaylistModal');
    likeBtnElement = document.getElementById('likeBtn');
    prevBtnElement = document.getElementById('prevBtn');
    nextBtnElement = document.getElementById('nextBtn');

    if (!playlistDisplayAreaElement || !sidebarTitleElement || !backToPlaylistsBtnElement ||
        !createNewPlaylistBtnElement || !addToPlaylistBtnElement || !addToPlaylistModalElement ||
        !modalPlaylistListElement || !closeModalAddToPlaylistBtnElement || !likeBtnElement ||
        !prevBtnElement || !nextBtnElement) {
        console.error("One or more playlist system DOM elements not found. Aborting.");
        return;
    }

    loadLikedPlaylist();
    loadUserPlaylists();

    renderSidebar(); // Initial render

    // Event Listeners
    likeBtnElement.addEventListener('click', toggleLikeCurrentSong);
    nextBtnElement.addEventListener('click', playNextTrackInCurrentPlaylist);
    prevBtnElement.addEventListener('click', playPreviousTrackInCurrentPlaylist);
    backToPlaylistsBtnElement.addEventListener('click', () => switchSidebarView('all_playlists'));
    createNewPlaylistBtnElement.addEventListener('click', handleCreateNewPlaylist);
    addToPlaylistBtnElement.addEventListener('click', () => { openAddToPlaylistModal(); });
    closeModalAddToPlaylistBtnElement.addEventListener('click', closeAddToPlaylistModal);

    window.addEventListener('click', (event) => {
        if (event.target === addToPlaylistModalElement) {
            closeAddToPlaylistModal();
        }
    });

    updatePlaylistControlsVisibility(); // Initial check for prev/next buttons
}

// --- DATA MANAGEMENT (LIKED SONGS) ---
function loadLikedPlaylist() {
    const stored = localStorage.getItem(LIKED_PLAYLIST_STORAGE_KEY); // From init.js
    likedPlaylist = stored ? JSON.parse(stored) : [];
}

function saveLikedPlaylist() {
    localStorage.setItem(LIKED_PLAYLIST_STORAGE_KEY, JSON.stringify(likedPlaylist));
}

function addSongToLikedPlaylist(songData) {
    if (!songData || !songData.id) {
        console.error("Cannot add to liked: missing song data or ID.", songData);
        return;
    }
    // Ensure durationSeconds is part of songData being pushed
    if (songData.durationSeconds === undefined) {
        console.warn(`Song "${songData.title}" added to Liked without duration. Defaulting to 0.`);
        songData.durationSeconds = 0; // Or fetch it if critical, but for now default
    }

    if (!likedPlaylist.find(s => s.id === songData.id)) {
        likedPlaylist.push(songData); // songData now includes durationSeconds
        saveLikedPlaylist();
        // ... (toast and re-render logic from previous step)
        if (typeof showToast === 'function') {
            const message = `"${escapeHtml(songData.title)}" added to Liked Songs!`;
            showToast(message, 3000);
        }
        if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === LIKED_SONGS_PLAYLIST_ID) {
            renderSinglePlaylistView(LIKED_SONGS_PLAYLIST_ID);
        } else if (currentSidebarView === 'all_playlists') {
            renderAllPlaylistsView();
        }
        updateLikeButtonState(true);

    } else {
        // ... (toast for already liked)
        if (typeof showToast === 'function') {
            const message = `"${escapeHtml(songData.title)}" is already in Liked Songs.`;
            showToast(message, 3000);
        }
    }
}

function removeSongFromLikedPlaylist(songId) {
    const initialLength = likedPlaylist.length;
    const songBeingRemoved = likedPlaylist.find(s => s.id === songId);

    likedPlaylist = likedPlaylist.filter(s => s.id !== songId);

    if (likedPlaylist.length < initialLength) {
        saveLikedPlaylist();

        // --- BEGIN MODIFICATION ---
        if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === LIKED_SONGS_PLAYLIST_ID) {
            renderSinglePlaylistView(LIKED_SONGS_PLAYLIST_ID);
        } else if (currentSidebarView === 'all_playlists') { // If viewing the overview
            renderAllPlaylistsView(); // Refresh the overview
        }
        // --- END MODIFICATION ---

        if (songBeingRemoved && typeof showToast === 'function') {
            showToast(`"${escapeHtml(songBeingRemoved.title)}" removed from Liked Songs.`, 3000);
        }


        if (currentPlayingPlaylistId === LIKED_SONGS_PLAYLIST_ID && currentTrack && currentTrack.id === songId) {
            const oldPlayingSongId = currentTrack.id;
            const newIndex = likedPlaylist.findIndex(s => s.id === oldPlayingSongId);
            if (newIndex === -1 && likedPlaylist.length > 0 && currentPlaylistTrackIndex >= likedPlaylist.length) {
                currentPlaylistTrackIndex = Math.max(0, likedPlaylist.length - 1);
            } else if (newIndex !== -1) {
                 currentPlaylistTrackIndex = newIndex;
            } else if (likedPlaylist.length === 0) {
                clearPlaylistContext(); // This also handles player controls visibility
            }
        }
        if (currentTrack && currentTrack.id === songId) {
            updateLikeButtonState(false); // Update player's heart icon
        }
    }
}

function isSongLiked(songId) {
    if (!songId) return false;
    return likedPlaylist.some(s => s.id === songId);
}

function toggleLikeCurrentSong() {
    if (!currentTrack || currentTrack.id == null) {
        console.warn("No current track to like/unlike, or track has no ID.");
        // Optionally show a toast or modal if currentTrack.id is null
        if (currentTrack && currentTrack.id == null && typeof showToast === 'function') {
            showToast("Cannot like: Track information incomplete.", 3000);
        }
        return;
    }

    if (isSongLiked(currentTrack.id)) {
        removeSongFromLikedPlaylist(currentTrack.id);
        // Toast for unliking is handled inside removeSongFromLikedPlaylist if songBeingRemoved exists
    } else {
        // --- BEGIN MODIFICATION: Ensure durationSeconds is included ---
        if (currentTrack.durationSeconds === undefined) {
            // This case should be rare if playSong always populates it.
            // Could happen if currentTrack was somehow set without a preceding playSong call that included duration.
            console.warn(`Liking current track "${currentTrack.title}" but its duration is undefined. Defaulting to 0.`);
        }
        addSongToLikedPlaylist({
            id: currentTrack.id, // Already a string from playSong
            title: currentTrack.title,
            artist: currentTrack.artist,
            artwork: currentTrack.artwork, // Ensure this is the 100x100 artwork
            durationSeconds: currentTrack.durationSeconds || 0 // Add durationSeconds here
        });
        // --- END MODIFICATION ---
        // Toast for liking is handled inside addSongToLikedPlaylist
    }
    // updateLikeButtonState is called by addSongToLikedPlaylist/removeSongFromLikedPlaylist
    // when currentTrack matches the modified song.
}


function updateLikeButtonState(isLikedOverride) {
    if (!likeBtnElement) return;
    const liked = typeof isLikedOverride === 'boolean' ? isLikedOverride : (currentTrack && currentTrack.id != null ? isSongLiked(currentTrack.id) : false);

    if (liked) {
        likeBtnElement.classList.remove('icon-heart-empty');
        likeBtnElement.classList.add('icon-heart-filled');
    } else {
        likeBtnElement.classList.remove('icon-heart-filled');
        likeBtnElement.classList.add('icon-heart-empty');
    }
}

// --- DATA MANAGEMENT (USER PLAYLISTS) ---
function loadUserPlaylists() {
    const stored = localStorage.getItem(USER_PLAYLISTS_STORAGE_KEY);
    userPlaylists = stored ? JSON.parse(stored) : [];
    // Ensure existing playlists have the customArtwork property
    userPlaylists.forEach(p => {
        if (p.customArtwork === undefined) {
            p.customArtwork = null;
        }
    });
}


function saveUserPlaylists() {
    localStorage.setItem(USER_PLAYLISTS_STORAGE_KEY, JSON.stringify(userPlaylists));
}

// Modified createPlaylist
function createPlaylist(name, customArtworkDataUrl = null) { // Added customArtworkDataUrl
    const newPlaylist = {
        id: `playlist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: name || "New Playlist",
        songs: [],
        customArtwork: customArtworkDataUrl // Store it
    };
    userPlaylists.push(newPlaylist);
    saveUserPlaylists();
    return newPlaylist;
}

function getPlaylistById(playlistId) {
    if (playlistId === LIKED_SONGS_PLAYLIST_ID) {
        // Liked Songs playlist doesn't have custom artwork editable by user
        return { id: LIKED_SONGS_PLAYLIST_ID, name: "Liked Songs", songs: [...likedPlaylist], customArtwork: null };
    }
    return userPlaylists.find(p => p.id === playlistId);
}

// Renamed from renamePlaylist and updated
function updatePlaylistDetails(playlistId, newName, newCustomArtworkDataUrl) {
    const playlist = userPlaylists.find(p => p.id === playlistId);
    if (playlist) {
        let changed = false;
        if (newName && newName.trim() !== "" && playlist.name !== newName.trim()) {
            playlist.name = newName.trim();
            changed = true;
        }
        // Check if newCustomArtworkDataUrl is explicitly passed (it could be null to clear it)
        if (newCustomArtworkDataUrl !== undefined && playlist.customArtwork !== newCustomArtworkDataUrl) {
            playlist.customArtwork = newCustomArtworkDataUrl;
            changed = true;
        }

        if (changed) {
            saveUserPlaylists();
            // Re-render views
            if (currentSidebarView === 'all_playlists') {
                renderAllPlaylistsView();
            } else if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
                if (sidebarTitleElement) sidebarTitleElement.textContent = escapeHtml(playlist.name); // Update title if viewing
                renderSinglePlaylistView(playlistId);
            }
            // If the currently playing playlist was edited, its display in the sidebar might need an update too
            // This is generally covered by the above re-renders.
        }
    }
}

function deletePlaylist(playlistId) {
    const playlist = getPlaylistById(playlistId);
    if (!playlist) return;
    const playlistName = playlist.name || "this playlist";

    showGeneralModal(
        "Confirm Deletion",
        `Are you sure you want to delete the playlist "<strong>${escapeModalHtml(playlistName)}</strong>"?<br>This action cannot be undone.`,
        [
            {
                text: 'Delete',
                class: 'primary',
                callback: () => {
                    userPlaylists = userPlaylists.filter(p => p.id !== playlistId);
                    saveUserPlaylists();
                    if (selectedPlaylistToViewId === playlistId) switchSidebarView('all_playlists');
                    else if (currentSidebarView === 'all_playlists') renderAllPlaylistsView();
                    if (currentPlayingPlaylistId === playlistId) clearPlaylistContext();
                    console.log(`Playlist "${escapeModalHtml(playlistName)}" deleted.`);
                    showToast(`Playlist "${escapeModalHtml(playlistName)}" deleted.`, 3000);
                }
            },
            { text: 'Cancel', class: 'secondary', callback: () => console.log('Deletion cancelled.') }
        ]
    );
}

function addSongToUserPlaylist(playlistId, songData) {
    const playlist = userPlaylists.find(p => p.id === playlistId);
    if (playlist && songData && songData.id) {
        // Ensure durationSeconds is part of songData being pushed
        if (songData.durationSeconds === undefined) {
            console.warn(`Song "${songData.title}" added to playlist "${playlist.name}" without duration. Defaulting to 0.`);
            songData.durationSeconds = 0;
        }

        if (!playlist.songs.find(s => s.id === songData.id)) {
            playlist.songs.push(songData); // songData now includes durationSeconds
            saveUserPlaylists();
            // ... (toast and re-render logic from previous step)
             if (typeof showToast === 'function') {
                const message = `"${escapeHtml(songData.title)}" added to ${escapeHtml(playlist.name)}!`;
                showToast(message, 3000);
            }
            if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
                renderSinglePlaylistView(playlistId);
            } else if (currentSidebarView === 'all_playlists') {
                renderAllPlaylistsView();
            }
            console.log(`Song "${songData.title}" added to playlist "${playlist.name}"`);
        } else {
            // ... (toast for song already in playlist)
            if (typeof showToast === 'function') {
                const message = `"${escapeHtml(songData.title)}" is already in ${escapeHtml(playlist.name)}.`;
                showToast(message, 3000);
            }
        }
    } else {
        // ... (error handling)
        if (!playlist) console.error("Playlist not found for ID:", playlistId);
        if (!songData || !songData.id) console.error("Invalid song data for addSongToUserPlaylist:", songData);
        if (typeof showToast === 'function') {
             showToast("Error: Could not add song to playlist.", 3000);
        }
    }
}

function removeSongFromUserPlaylist(playlistId, songId) {
    const playlist = userPlaylists.find(p => p.id === playlistId);
    if (playlist) {
        const initialLength = playlist.songs.length;
        const songBeingRemoved = playlist.songs.find(s => s.id === songId);
        playlist.songs = playlist.songs.filter(s => s.id !== songId);

        if (playlist.songs.length < initialLength) {
            saveUserPlaylists();

            // --- BEGIN MODIFICATION ---
            if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
                renderSinglePlaylistView(playlistId);
            } else if (currentSidebarView === 'all_playlists') { // If viewing the overview
                renderAllPlaylistsView(); // Refresh the overview
            }
            // --- END MODIFICATION ---
            
            if (songBeingRemoved && typeof showToast === 'function') {
                showToast(`"${escapeHtml(songBeingRemoved.title)}" removed from ${escapeHtml(playlist.name)}.`, 3000);
            }

            if (currentPlayingPlaylistId === playlistId && currentTrack && currentTrack.id === songId) {
                // If the removed song was playing from this user playlist
                // Player.js ENDED state or next/prev logic will handle advancing if possible.
                // We might need to adjust currentPlaylistTrackIndex if the removed song was *before* current.
                // For simplicity, if current playing is removed, player handles next or stops.
                // If the playlist becomes empty, clear context.
                if (playlist.songs.length === 0) {
                    clearPlaylistContext();
                } else {
                    // Check if currentTrackIndex is now out of bounds
                    if (currentPlaylistTrackIndex >= playlist.songs.length) {
                        currentPlaylistTrackIndex = playlist.songs.length - 1; // Point to new last song
                    }
                    // If the song removed was *before* the current one, the index of the current playing song
                    // in the modified array would have shifted.
                    const stillPlayingSong = playlist.songs.find(s => s.id === currentTrack.id);
                    if (stillPlayingSong) {
                        currentPlaylistTrackIndex = playlist.songs.findIndex(s => s.id === currentTrack.id);
                    } else {
                        // Current track was the one removed, and playlist not empty,
                        // player will likely stop or try to play next based on its ENDED logic.
                        // No direct action needed here other than the render.
                    }
                }
            }
        }
    }
}

function reorderSongInPlaylist(playlistId, oldIndex, newIndex) {
    const playlistRef = (playlistId === LIKED_SONGS_PLAYLIST_ID) ? likedPlaylist : userPlaylists.find(p => p.id === playlistId)?.songs;
    if (!playlistRef) return;

    const itemToMove = playlistRef.splice(oldIndex, 1)[0];
    playlistRef.splice(newIndex, 0, itemToMove);

    if (playlistId === LIKED_SONGS_PLAYLIST_ID) {
        saveLikedPlaylist();
    } else {
        saveUserPlaylists(); // Assumes playlistRef was a direct reference to a user playlist's songs array
    }

    if (currentPlayingPlaylistId === playlistId && currentTrack) {
        const newPlayingIndex = playlistRef.findIndex(song => song.id === currentTrack.id);
        if (newPlayingIndex !== -1) {
            currentPlaylistTrackIndex = newPlayingIndex;
        }
    }

    if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
        renderSinglePlaylistView(playlistId);
    }
}

// --- UI RENDERING ---
function renderSidebar() {
    if (!playlistDisplayAreaElement) return; // Guard if elements not ready
    if (currentSidebarView === 'all_playlists') {
        renderAllPlaylistsView();
    } else if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId) {
        renderSinglePlaylistView(selectedPlaylistToViewId);
    }
}

function switchSidebarView(view, playlistId = null) {
    currentSidebarView = view;
    selectedPlaylistToViewId = playlistId; // This is ID of playlist to *view*, not necessarily play
    renderSidebar();
}

function renderAllPlaylistsView() {
    if (!playlistDisplayAreaElement || !sidebarTitleElement || !backToPlaylistsBtnElement || !createNewPlaylistBtnElement) return;

    // --- BEGIN MODIFICATION: Store scroll and clear title class ---
    let currentScrollTop = 0;
    if (playlistDisplayAreaElement) {
        currentScrollTop = playlistDisplayAreaElement.scrollTop;
    }

    if (sidebarTitleElement) { // Ensure element exists
        sidebarTitleElement.textContent = "Your Playlists";
        sidebarTitleElement.classList.remove('playing-playlist-title'); // Remove the class here
    }
    // --- END MODIFICATION ---

    playlistDisplayAreaElement.innerHTML = '';
    // sidebarTitleElement.textContent = "Your Playlists"; // Moved up
    backToPlaylistsBtnElement.style.display = 'none';
    createNewPlaylistBtnElement.style.display = 'inline-block';

    const ul = document.createElement('ul');
    // ul.className = 'playlist-list-overview';

    const likedSongsData = { id: LIKED_SONGS_PLAYLIST_ID, name: "Liked Songs", songs: likedPlaylist };
    ul.appendChild(createPlaylistOverviewItem(likedSongsData));

    userPlaylists.forEach(playlist => {
        ul.appendChild(createPlaylistOverviewItem(playlist));
    });

    playlistDisplayAreaElement.appendChild(ul);

    // --- BEGIN MODIFICATION: Restore scroll position ---
    if (playlistDisplayAreaElement) {
        playlistDisplayAreaElement.scrollTop = currentScrollTop;
    }
    // --- END MODIFICATION ---
}

// Modify createPlaylistOverviewItem to use actual durations
function createPlaylistOverviewItem(playlistData) {
    const li = document.createElement('li');
    li.className = 'playlist-overview-item';
    li.setAttribute('data-playlist-id', playlistData.id);

    const songCount = playlistData.songs.length;
    const songsText = songCount === 1 ? "1 song" : `${songCount} songs`;

    // --- BEGIN MODIFICATION: Calculate total duration from actual song data ---
    let totalDurationSeconds = 0;
    if (songCount > 0) {
        totalDurationSeconds = playlistData.songs.reduce((sum, song) => {
            return sum + (song.durationSeconds || 0); // Use stored durationSeconds, fallback to 0
        }, 0);
    }
    const formattedDuration = formatPlaylistDuration(totalDurationSeconds);
    const countAndDurationText = songCount > 0 ? `${songsText} • ${formattedDuration}` : songsText;
    // --- END MODIFICATION ---

    let artworkSrc;
    // ... (artwork logic remains the same)
     if (playlistData.id === LIKED_SONGS_PLAYLIST_ID) {
        artworkSrc = 'img/liked_songs.png';
    } else {
        li.setAttribute('draggable', true);
        if (playlistData.customArtwork) {
            artworkSrc = playlistData.customArtwork;
        } else if (playlistData.songs.length > 0 && playlistData.songs[0].artwork) {
            artworkSrc = playlistData.songs[0].artwork;
        } else {
            artworkSrc = 'img/empty_art.png';
        }
        li.addEventListener('dragstart', (event) => handlePlaylistDragStart(event, playlistData.id));
        li.addEventListener('dragover', handlePlaylistDragOver);
        li.addEventListener('drop', (event) => handlePlaylistDrop(event, playlistData.id));
        li.addEventListener('dragend', handlePlaylistDragEnd);
    }


    let nameDisplayClasses = "playlist-overview-item-name";
    if (currentPlayingPlaylistId === playlistData.id) {
        nameDisplayClasses += " playing-playlist-title";
    }
    let nameDisplay = `<div class="${nameDisplayClasses}">${escapeHtml(playlistData.name)}</div>`;

    let actionsHtml = '';
    // ... (actionsHtml logic remains the same)
    if (playlistData.id !== LIKED_SONGS_PLAYLIST_ID) {
        actionsHtml = `
            <div class="playlist-item-actions">
                <button class="edit-playlist-btn" title="Edit Playlist"><i class="icon icon-edit"></i></button>
                <button class="delete-playlist-btn" title="Delete"><i class="icon icon-trash"></i></button>
            </div>`;
    }


    li.innerHTML = `
        <img src="${artworkSrc}" alt="${escapeHtml(playlistData.name)}" class="playlist-overview-item-artwork">
        <div class="playlist-overview-item-info">
            ${nameDisplay}
            <div class="playlist-overview-item-count">${countAndDurationText}</div>
        </div>
        ${actionsHtml}
    `;

    // ... (event listeners in this function remain the same)
    const infoSection = li.querySelector('.playlist-overview-item-info');
    const artworkSection = li.querySelector('.playlist-overview-item-artwork');
    const viewPlaylistHandler = () => switchSidebarView('single_playlist_view', playlistData.id);

    const combinedClickHandler = (e) => {
        if (e.target.closest('.playlist-item-actions') ||
            (draggedPlaylistElement && draggedPlaylistElement.classList.contains('dragging'))) {
            return;
        }
        viewPlaylistHandler();
    };
    
    if (infoSection) infoSection.addEventListener('click', combinedClickHandler);
    if (artworkSection) artworkSection.addEventListener('click', combinedClickHandler);


    if (playlistData.id !== LIKED_SONGS_PLAYLIST_ID) {
        const editBtn = li.querySelector('.edit-playlist-btn');
        const deleteBtn = li.querySelector('.delete-playlist-btn');
        if(editBtn) editBtn.addEventListener('click', (e) => { e.stopPropagation(); handleEditPlaylist(playlistData.id); });
        if(deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deletePlaylist(playlistData.id); });
    }
    return li;
}

function reorderUserPlaylists(draggedInitialIndex, targetVisualIndex) {
    // draggedInitialIndex: original index in userPlaylists
    // targetVisualIndex: the index where it should appear *after* the move, relative to the original array.
    // E.g., to move to the very start, targetVisualIndex = 0.
    // To move to be the item at index K (pushing K and subsequent down), targetVisualIndex = K.

    if (draggedInitialIndex < 0 || draggedInitialIndex >= userPlaylists.length ||
        targetVisualIndex < 0 || targetVisualIndex > userPlaylists.length) { // targetVisualIndex can be userPlaylists.length for appending
        console.warn("Invalid indices for playlist reorder", draggedInitialIndex, targetVisualIndex);
        return;
    }
    
    // If trying to drop in the same spot (no actual move needed)
    // Note: if targetVisualIndex is intended to be "insert before this index"
    // then if draggedInitialIndex === targetVisualIndex, no move.
    // if targetVisualIndex is "insert after this index (targetVisualIndex-1)", then no move if draggedInitialIndex === targetVisualIndex-1
    // Let's assume targetVisualIndex is "insert AT this index".
    if (draggedInitialIndex === targetVisualIndex || draggedInitialIndex === targetVisualIndex -1 && targetVisualIndex > draggedInitialIndex) { // No actual move
        // renderAllPlaylistsView(); // Still re-render to clear any drag artifacts
        return;
    }


    const itemToMove = userPlaylists.splice(draggedInitialIndex, 1)[0];

    // Adjust targetVisualIndex if the removal of itemToMove affected it
    let effectiveTargetIndex = targetVisualIndex;
    if (draggedInitialIndex < targetVisualIndex) {
        effectiveTargetIndex--; // The target position shifted left because an item before it was removed
    }
    
    // Clamp effectiveTargetIndex to be within the bounds of the (now shorter) array for insertion
    effectiveTargetIndex = Math.max(0, Math.min(effectiveTargetIndex, userPlaylists.length));

    userPlaylists.splice(effectiveTargetIndex, 0, itemToMove);

    saveUserPlaylists();
    renderAllPlaylistsView(); // Re-render the overview to reflect the new order and clear drag artifacts
}

function renderSinglePlaylistView(playlistId) {
    if (!playlistDisplayAreaElement || !sidebarTitleElement || !backToPlaylistsBtnElement || !createNewPlaylistBtnElement) return;

    const playlist = getPlaylistById(playlistId);
    if (!playlist) {
        switchSidebarView('all_playlists');
        return;
    }

    let currentScrollTop = 0;
    if (playlistDisplayAreaElement) {
        currentScrollTop = playlistDisplayAreaElement.scrollTop;
    }

    playlistDisplayAreaElement.innerHTML = '';
    sidebarTitleElement.textContent = escapeHtml(playlist.name);

    // --- BEGIN MODIFICATION: Add class to sidebar title if it's the playing playlist ---
    sidebarTitleElement.classList.remove('playing-playlist-title'); // Remove first to handle deselection
    if (currentPlayingPlaylistId === playlistId) {
        sidebarTitleElement.classList.add('playing-playlist-title');
    }
    // --- END MODIFICATION ---

    backToPlaylistsBtnElement.style.display = 'inline-block';
    createNewPlaylistBtnElement.style.display = 'none';

    // ... (rest of renderSinglePlaylistView, including song list rendering, remains the same)
    if (playlist.songs.length === 0) {
        playlistDisplayAreaElement.innerHTML = `<p class="empty-playlist-message">This playlist is empty.</p>`;
        if (playlistDisplayAreaElement) {
            playlistDisplayAreaElement.scrollTop = currentScrollTop;
        }
        return;
    }

    const ul = document.createElement('ul');

    playlist.songs.forEach((song, index) => {
        const li = document.createElement('li');
        li.className = 'playlist-item';
        li.setAttribute('data-song-id', song.id.toString());
        li.setAttribute('draggable', true); 

        if (currentPlayingPlaylistId === playlistId && currentPlaylistTrackIndex === index && currentTrack && currentTrack.id === song.id) {
            li.classList.add('playing');
        }
        
        let actionButtonHtml = '';
        if (playlistId === LIKED_SONGS_PLAYLIST_ID) {
            actionButtonHtml = `
                <button class="unlike-song-from-liked-playlist-btn icon-action-btn" title="Remove from Liked Songs">
                    <i class="icon icon-heart-filled"></i> 
                </button>`;
        } else {
            actionButtonHtml = `
                <button class="remove-song-from-playlist-btn icon-action-btn" title="Remove from playlist">
                    <i class="icon icon-trash"></i>
                </button>`;
        }

        li.innerHTML = `
            <img src="${song.artwork || 'img/empty_art.png'}" alt="${escapeHtml(song.title)}" class="playlist-item-artwork">
            <div class="playlist-item-info">
                <div class="playlist-item-title">${escapeHtml(song.title)}</div>
                <div class="playlist-item-artist">${escapeHtml(song.artist)}</div>
            </div>
            ${actionButtonHtml} 
        `;

        li.addEventListener('click', (e) => {
            const unlikeButton = e.target.closest('.unlike-song-from-liked-playlist-btn');
            const removeButton = e.target.closest('.remove-song-from-playlist-btn');

            if (unlikeButton) { 
                e.stopPropagation();
                removeSongFromLikedPlaylist(song.id); 
            } else if (removeButton) { 
                e.stopPropagation();
                removeSongFromUserPlaylist(playlistId, song.id);
            } else { 
                playSongFromCurrentPlaylist(playlistId, index);
            }
        });

        li.addEventListener('dragstart', (event) => handleSongDragStart(event, index, playlistId));
        li.addEventListener('dragover', handleSongDragOver);
        li.addEventListener('drop', (event) => handleSongDrop(event, index, playlistId));
        li.addEventListener('dragend', handleSongDragEnd);

        ul.appendChild(li);
    });
    playlistDisplayAreaElement.appendChild(ul);

    if (playlistDisplayAreaElement) {
        playlistDisplayAreaElement.scrollTop = currentScrollTop;
    }
}

// --- PLAYBACK LOGIC ADAPTATIONS ---
// When playing a song from a playlist, ensure duration is passed to playSong
function playSongFromCurrentPlaylist(playlistId, songIndexInOriginalPlaylist) {
    const playlist = getPlaylistById(playlistId);
    if (!playlist || !playlist.songs || songIndexInOriginalPlaylist < 0 || songIndexInOriginalPlaylist >= playlist.songs.length) {
        console.warn(`Cannot play song: invalid playlist or index. Playlist ID: ${playlistId}, Index: ${songIndexInOriginalPlaylist}`);
        clearPlaylistContext();
        return;
    }

    const songToPlay = playlist.songs[songIndexInOriginalPlaylist];

    // ... (shuffle logic) ...
    if (isShuffleActive && currentPlayingPlaylistId === playlistId) {
        const upcomingIndex = shuffleUpcomingQueue.findIndex(s => s.id === songToPlay.id);
        if (upcomingIndex > -1) shuffleUpcomingQueue.splice(upcomingIndex, 1);
        const playedIndex = shufflePlayedQueue.findIndex(s => s.id === songToPlay.id);
        if (playedIndex > -1) shufflePlayedQueue.splice(playedIndex, 1);
        shufflePlayedQueue.push(songToPlay);
    } else if (isShuffleActive && currentPlayingPlaylistId !== playlistId) {
        initializeShuffleQueues(playlist.songs, songToPlay.id);
    }


    currentPlayingPlaylistId = playlistId;
    currentPlaylistTrackIndex = songIndexInOriginalPlaylist;

    if (typeof playSong === 'function') {
        // --- MODIFICATION: Pass durationSeconds from the playlist song object ---
        playSong(
            songToPlay.title,
            songToPlay.artist,
            songToPlay.artwork,
            songToPlay.id.toString(),
            songToPlay.durationSeconds || 0 // Pass stored duration
        );
        // --- END MODIFICATION ---
    } else {
        console.error("Global playSong function not found!");
    }

    renderSidebar();
    updatePlaylistControlsVisibility();
}


function playNextTrackInCurrentPlaylist() {
    if (!currentPlayingPlaylistId) return;

    const playlist = getPlaylistById(currentPlayingPlaylistId);
    if (!playlist || !playlist.songs || playlist.songs.length === 0) {
        clearPlaylistContext();
        return;
    }

    if (isShuffleActive) {
        if (shuffleUpcomingQueue.length === 0) {
            if (loopState === 'playlist') {
                console.log("Shuffle: Upcoming empty, looping playlist.");
                initializeShuffleQueues(playlist.songs);
                 // After re-initializing, check if there are still songs to play
                if (shuffleUpcomingQueue.length > 0) {
                    const nextSongToPlay = shuffleUpcomingQueue.shift();
                    shufflePlayedQueue.push(nextSongToPlay);
                    const originalIndexOfNextSong = playlist.songs.findIndex(s => s.id === nextSongToPlay.id);
                    currentPlaylistTrackIndex = originalIndexOfNextSong;
                    currentPlayingPlaylistId = playlist.id;
                    console.log(`Shuffle: Playing next "${nextSongToPlay.title}" after loop. Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
                    if (typeof playSong === 'function') {
                        playSong(nextSongToPlay.title, nextSongToPlay.artist, nextSongToPlay.artwork, nextSongToPlay.id.toString());
                    }
                    renderSidebar();
                    updatePlaylistControlsVisibility();
                    return; // Important: exit after handling the looped shuffle
                } else {
                    // Playlist became empty even after trying to loop shuffle (e.g. 0 songs playlist)
                    clearPlaylistContext();
                    return;
                }
            } else {
                console.log("Shuffle: Upcoming empty, no loop. Showing toast.");
                if (typeof showToast === 'function') { // <<<< ADDED TOAST
                    showToast("Last track in shuffle. Enable loop to replay.", 3500);
                }
                return; // Stop here, don't proceed to play
            }
        }

        // This block is for when shuffleUpcomingQueue.length > 0 (normal shuffle next)
        const nextSongToPlay = shuffleUpcomingQueue.shift();
        shufflePlayedQueue.push(nextSongToPlay);
        const originalIndexOfNextSong = playlist.songs.findIndex(s => s.id === nextSongToPlay.id);
        currentPlaylistTrackIndex = originalIndexOfNextSong;
        currentPlayingPlaylistId = playlist.id;
        console.log(`Shuffle: Playing next "${nextSongToPlay.title}". Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
        if (typeof playSong === 'function') {
            playSong(nextSongToPlay.title, nextSongToPlay.artist, nextSongToPlay.artwork, nextSongToPlay.id.toString());
        }
        renderSidebar();
        updatePlaylistControlsVisibility();

    } else { // Original non-shuffle logic
        let nextIndex = currentPlaylistTrackIndex + 1;
        if (nextIndex >= playlist.songs.length) {
            if (loopState === 'playlist') {
                nextIndex = 0;
            } else {
                console.log("Playlist: Last track, no loop. Showing toast.");
                if (typeof showToast === 'function') { // <<<< ADDED TOAST
                    showToast("End of playlist! Enable loop to continue.", 3500);
                }
                return; // Stop here, don't proceed to play
            }
        }
        playSongFromCurrentPlaylist(currentPlayingPlaylistId, nextIndex);
    }
}

function playPreviousTrackInCurrentPlaylist() {
    if (!currentPlayingPlaylistId) return;

    const playlist = getPlaylistById(currentPlayingPlaylistId);
     if (!playlist || !playlist.songs || playlist.songs.length === 0) {
        clearPlaylistContext();
        return;
    }

    if (isShuffleActive) {
        if (shufflePlayedQueue.length < 2) { // Need at least 2 songs in played: one current, one previous
            console.log("Shuffle: Not enough played history to go previous.");
            return; // Or play the first song of the shuffle cycle if desired
        }

        const currentSongFromPlayed = shufflePlayedQueue.pop(); // Remove current from played
        shuffleUpcomingQueue.unshift(currentSongFromPlayed); // Add it back to start of upcoming

        const previousSongToPlay = shufflePlayedQueue[shufflePlayedQueue.length - 1]; // Peek at new last (actual prev)
        
        const originalIndexOfPrevSong = playlist.songs.findIndex(s => s.id === previousSongToPlay.id);

        currentPlaylistTrackIndex = originalIndexOfPrevSong;
        currentPlayingPlaylistId = playlist.id;

        console.log(`Shuffle: Playing previous "${previousSongToPlay.title}". Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
        if (typeof playSong === 'function') {
            playSong(previousSongToPlay.title, previousSongToPlay.artist, previousSongToPlay.artwork, previousSongToPlay.id.toString());
        }
        renderSidebar();
        updatePlaylistControlsVisibility();

    } else { // Original non-shuffle logic
        let prevIndex = currentPlaylistTrackIndex - 1;
        if (prevIndex < 0) {
            // If loop playlist is active, wrap to last song, otherwise stop at first.
            if (loopState === 'playlist') {
                 prevIndex = playlist.songs.length - 1;
            } else {
                return; // Don't wrap if not looping playlist
            }
        }
        playSongFromCurrentPlaylist(currentPlayingPlaylistId, prevIndex);
    }
}
function updatePlaylistControlsVisibility() {
    if (!prevBtnElement || !nextBtnElement || !shuffleBtn) return; // Add shuffleBtn check
    const playlist = getPlaylistById(currentPlayingPlaylistId);
    const showControls = playlist && playlist.songs && playlist.songs.length > 0;

    prevBtnElement.style.display = showControls ? 'inline-block' : 'none';
    nextBtnElement.style.display = showControls ? 'inline-block' : 'none';
    shuffleBtn.style.display = showControls ? 'inline-block' : 'none'; // <<< ADD THIS

    if (typeof updateLoopButtonIcon === 'function') updateLoopButtonIcon();
    if (typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon(); // <<< ADD THIS
}

function clearPlaylistContext() {
    const wasPlayingPlaylist = currentPlayingPlaylistId !== null;
    currentPlayingPlaylistId = null;
    currentPlaylistTrackIndex = -1;

    isShuffleActive = false;
    shuffleUpcomingQueue = [];
    shufflePlayedQueue = [];
    if(typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon();

    // --- MODIFICATION: Explicitly call renderSidebar if the view might need an update ---
    // This ensures that if the overview or a single playlist view was showing the "playing" state,
    // it gets cleared.
    if (wasPlayingPlaylist) { // Only re-render if something *was* playing from a playlist
        renderSidebar(); // This will call either renderAllPlaylistsView or renderSinglePlaylistView
    } else {
        // If nothing was playing from a playlist, but controls still need update (e.g. shuffle toggled off)
        updatePlaylistControlsVisibility();
    }
    // --- END MODIFICATION ---


    // updatePlaylistControlsVisibility(); // Original call - renderSidebar above covers its visual aspect for titles

    if (wasPlayingPlaylist && typeof loopState !== 'undefined' && loopState === 'playlist') {
        loopState = 'none';
        if (typeof updateLoopButtonIcon === 'function') updateLoopButtonIcon();
    }
}

// --- "ADD TO PLAYLIST" MODAL ---
// In openAddToPlaylistModal: ensure currentTrack has durationSeconds
function openAddToPlaylistModal(songDataOverride = null) {
    const songToAdd = songDataOverride || currentTrack;

    if (!songToAdd || songToAdd.id == null) {
        showGeneralModal("Cannot Add Song", "No song selected or currently playing to add to a playlist.");
        return;
    }
    if (!songToAdd.title || !songToAdd.artist || !songToAdd.artwork || songToAdd.durationSeconds === undefined) { // Check duration
        console.error("Song data for modal is incomplete (missing duration?):", songToAdd);
        // Attempt to find duration if it's the currentTrack and it might have been populated by playSong
        let duration = songToAdd.durationSeconds;
        if (songToAdd.id === currentTrack.id && currentTrack.durationSeconds !== undefined) {
            duration = currentTrack.durationSeconds;
        } else if (songToAdd.durationSeconds === undefined) {
            // Fallback or error - for now, let's alert and maybe default
            // This scenario should be rare if data flow is correct from search/playSong
             console.warn("Duration missing for song in 'Add to Playlist' modal. Defaulting to 0. Song:", songToAdd.title);
             duration = 0; // Or some average
        }
        
        // Rebuild songToAdd with potentially found/defaulted duration
        const completeSongToAdd = {
            ...songToAdd,
            durationSeconds: duration
        };
        
        // If critical data still missing after attempt:
        if (!completeSongToAdd.title || !completeSongToAdd.artist || !completeSongToAdd.artwork) {
            showGeneralModal("Error", "Cannot add song due to incomplete data.");
            return;
        }
        // Proceed with completeSongToAdd
        _populateAndShowAddToPlaylistModal(completeSongToAdd);

    } else {
        // songToAdd already has duration and other necessary fields
        _populateAndShowAddToPlaylistModal(songToAdd);
    }
}

function closeAddToPlaylistModal() {
    addToPlaylistModalElement.style.display = 'none';
}

// --- PLAYLIST MANAGEMENT UI HANDLERS ---
function handleCreateNewPlaylist() {
    if (typeof openCreatePlaylistModal === 'function') { // openCreatePlaylistModal is from modals.js
        openCreatePlaylistModal();
    } else {
        console.error("openCreatePlaylistModal function not found!");
        // Fallback to prompt if modal function isn't available
        const playlistNameFallback = prompt("Enter name for new playlist (modal error):", "My Playlist");
        if (playlistNameFallback && playlistNameFallback.trim() !== "") {
            createPlaylist(playlistNameFallback.trim());
            renderAllPlaylistsView();
        } else if (playlistNameFallback !== null) {
            alert("Playlist name cannot be empty.");
        }
    }
}

// Renamed from handleRenamePlaylist
function handleEditPlaylist(playlistIdToEdit) {
    const playlist = getPlaylistById(playlistIdToEdit);
    if (!playlist || playlist.id === LIKED_SONGS_PLAYLIST_ID) {
        console.warn("Attempted to edit Liked Songs or non-existent playlist.");
        return;
    }

    if (typeof openEditPlaylistModal === 'function') { // openEditPlaylistModal is from modals.js
        openEditPlaylistModal(playlist.id, playlist.name); // Pass ID and current name
    } else {
        console.error("openEditPlaylistModal function not found!");
        // Fallback could be more complex here, maybe just rename via prompt
        const newNameFallback = prompt(`Enter new name for "${escapeHtml(playlist.name)}":`, playlist.name);
        if (newNameFallback && newNameFallback.trim() !== "" && newNameFallback.trim() !== playlist.name) {
            updatePlaylistDetails(playlist.id, newNameFallback.trim(), playlist.customArtwork); // Pass existing artwork
        } else if (newNameFallback && newNameFallback.trim() === "") {
            if(typeof showGeneralModal === 'function') showGeneralModal("Invalid Name", "Playlist name cannot be empty.");
            else alert("Playlist name cannot be empty.");
        }
    }
}

// --- DRAG AND DROP FOR SONGS (within a single playlist view) ---
let draggedSongIndex = null;
let draggedSongElement = null;
let dragOverPlaylistIdContext = null; // Stores playlist ID during drag operation

// New state variables for playlist dragging
let draggedPlaylistIndex = null;     // Index in the userPlaylists array
let draggedPlaylistElement = null;

function handleSongDragStart(event, index, playlistId) {
    draggedSongIndex = index;
    draggedSongElement = event.target;
    dragOverPlaylistIdContext = playlistId; // Set context for this drag operation
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', index.toString()); // Standard practice
    setTimeout(() => {
        if (draggedSongElement) draggedSongElement.classList.add('dragging');
    }, 0);
}

function handleSongDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    const currentTargetLi = event.target.closest('.playlist-item');

    if (!currentTargetLi || !draggedSongElement || currentTargetLi === draggedSongElement ||
        !playlistDisplayAreaElement.contains(currentTargetLi)) { // Ensure target is within the display area
        return;
    }
    clearGapIndicators(); // Clear previous gaps
    const rect = currentTargetLi.getBoundingClientRect();
    const offsetY = event.clientY - rect.top;
    currentTargetLi.classList.add(offsetY < rect.height / 2 ? 'show-gap-above' : 'show-gap-below');
}

function handleSongDrop(event, indexOfTheItemDroppedOn, playlistIdForDropTarget) {
    event.preventDefault();
    clearGapIndicators();

    if (draggedSongIndex === null || dragOverPlaylistIdContext !== playlistIdForDropTarget ||
        dragOverPlaylistIdContext !== selectedPlaylistToViewId) {
        // Dragged from different playlist context or something went wrong
        if (draggedSongElement) draggedSongElement.classList.remove('dragging');
        draggedSongIndex = null;
        draggedSongElement = null;
        dragOverPlaylistIdContext = null;
        return;
    }

    // At this point, playlistIdForDropTarget is the same as dragOverPlaylistIdContext
    const currentReorderingPlaylistId = dragOverPlaylistIdContext;

    reorderSongInPlaylist(currentReorderingPlaylistId, draggedSongIndex, indexOfTheItemDroppedOn);
    // reorderSongInPlaylist now handles saving and re-rendering the single playlist view.
    // The re-render will also clean up dragging classes.

    // Reset state variables in handleSongDragEnd
}

function handleSongDragEnd(event) {
    clearGapIndicators();
    if (draggedSongElement) {
        draggedSongElement.classList.remove('dragging');
    }
    // Failsafe: remove dragging from all items if something went wrong
    const allItems = playlistDisplayAreaElement.querySelectorAll('.playlist-item.dragging');
    allItems.forEach(item => item.classList.remove('dragging'));

    draggedSongIndex = null;
    draggedSongElement = null;
    dragOverPlaylistIdContext = null;
}

function clearGapIndicators() {
    const items = playlistDisplayAreaElement.querySelectorAll('.playlist-item');
    items.forEach(item => {
        item.classList.remove('show-gap-above', 'show-gap-below');
    });
}

// --- DRAG AND DROP FOR PLAYLIST OVERVIEW ITEMS ---

function handlePlaylistDragStart(event, playlistId) {
    draggedPlaylistIndex = userPlaylists.findIndex(p => p.id === playlistId);
    // Explicitly prevent dragging "Liked Songs" even if draggable was somehow set
    if (draggedPlaylistIndex === -1 || playlistId === LIKED_SONGS_PLAYLIST_ID) {
        event.preventDefault();
        return;
    }

    draggedPlaylistElement = event.target.closest('.playlist-overview-item');
    if (!draggedPlaylistElement) { // Should not happen if event is on the li
        event.preventDefault();
        return;
    }
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', playlistId); // Store playlistId

    setTimeout(() => { // Timeout to allow browser to render drag image before class change
        if (draggedPlaylistElement) draggedPlaylistElement.classList.add('dragging');
    }, 0);
}

function handlePlaylistDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    const targetLiElement = event.target.closest('.playlist-overview-item');

    // Do not allow dropping on "Liked Songs" or on the item being dragged
    if (!targetLiElement || targetLiElement === draggedPlaylistElement || 
        targetLiElement.getAttribute('data-playlist-id') === LIKED_SONGS_PLAYLIST_ID) {
        clearPlaylistGapIndicators(); // Clear any gaps if hovering over an invalid target
        return;
    }

    clearPlaylistGapIndicators(); // Clear previous gaps

    const rect = targetLiElement.getBoundingClientRect();
    const offsetY = event.clientY - rect.top;
    const middleY = rect.height / 2;

    if (offsetY < middleY) {
        targetLiElement.classList.add('show-gap-above');
    } else {
        targetLiElement.classList.add('show-gap-below');
    }
}

function handlePlaylistDrop(event, targetPlaylistIdOnDrop) {
    event.preventDefault();
    clearPlaylistGapIndicators();

    if (!draggedPlaylistElement || draggedPlaylistIndex === -1 || targetPlaylistIdOnDrop === LIKED_SONGS_PLAYLIST_ID) {
        // Invalid drag operation or dropping on "Liked Songs"
        if (draggedPlaylistElement) draggedPlaylistElement.classList.remove('dragging');
        draggedPlaylistIndex = -1;
        draggedPlaylistElement = null;
        return;
    }

    const targetLiElement = event.target.closest('.playlist-overview-item');
    if (!targetLiElement) { // Should not happen if drop event is on a valid target
        if (draggedPlaylistElement) draggedPlaylistElement.classList.remove('dragging');
        draggedPlaylistIndex = -1;
        draggedPlaylistElement = null;
        return;
    }

    const targetPlaylistIndexInUserPlaylists = userPlaylists.findIndex(p => p.id === targetPlaylistIdOnDrop);
    if (targetPlaylistIndexInUserPlaylists === -1) { // Target playlist not found (error)
        if (draggedPlaylistElement) draggedPlaylistElement.classList.remove('dragging');
        draggedPlaylistIndex = -1;
        draggedPlaylistElement = null;
        return;
    }

    // Determine target insert position based on drop location relative to the target item's middle
    let visualTargetIndex = targetPlaylistIndexInUserPlaylists; // This is the index of the item we are dropping ONTO

    const rect = targetLiElement.getBoundingClientRect();
    const offsetY = event.clientY - rect.top;
    const middleY = rect.height / 2;

    if (offsetY > middleY) { // Dropped on the lower half, so insert AFTER this item
        visualTargetIndex++;
    }
    // If dropped on upper half, visualTargetIndex remains the index of the target item (insert BEFORE it)

    reorderUserPlaylists(draggedPlaylistIndex, visualTargetIndex);
    // Drag end will clean up remaining state and classes.
    // reorderUserPlaylists will call renderAllPlaylistsView which also helps clean up.
}

function handlePlaylistDragEnd(event) {
    clearPlaylistGapIndicators();
    if (draggedPlaylistElement) {
        draggedPlaylistElement.classList.remove('dragging');
    }
    // Failsafe removal
    const allDraggingItems = playlistDisplayAreaElement.querySelectorAll('.playlist-overview-item.dragging');
    allDraggingItems.forEach(item => item.classList.remove('dragging'));

    draggedPlaylistIndex = -1;
    draggedPlaylistElement = null;
}

function clearPlaylistGapIndicators() {
    const items = playlistDisplayAreaElement.querySelectorAll('.playlist-overview-item');
    items.forEach(item => {
        item.classList.remove('show-gap-above', 'show-gap-below');
    });
}

// --- SHUFFLE HELPER ---
function shuffleArray(array) {
    let newArray = [...array]; // Create a copy
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

// --- SHUFFLE QUEUE MANAGEMENT ---
function initializeShuffleQueues(playlistSongs, currentlyPlayingSongId = null) {
    if (!isShuffleActive || !playlistSongs || playlistSongs.length === 0) {
        shuffleUpcomingQueue = [];
        shufflePlayedQueue = [];
        isShuffleActive = false; // Turn off if no songs
        if (typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon();
        return;
    }

    // Create a queue of song *objects* or just *IDs*. IDs are simpler for queue management.
    // Let's use song objects for now to easily access details later.
    shuffleUpcomingQueue = shuffleArray(playlistSongs);
    shufflePlayedQueue = [];

    if (currentlyPlayingSongId) {
        const currentSongIndexInUpcoming = shuffleUpcomingQueue.findIndex(s => s.id === currentlyPlayingSongId);
        if (currentSongIndexInUpcoming > -1) {
            const currentSongObject = shuffleUpcomingQueue.splice(currentSongIndexInUpcoming, 1)[0];
            shufflePlayedQueue.push(currentSongObject); // Current song is first in played queue
        } else {
            // If current song wasn't in the list for some reason, just proceed.
        }
    }
    console.log("Shuffle queues initialized. Upcoming:", shuffleUpcomingQueue.map(s=>s.title), "Played:", shufflePlayedQueue.map(s=>s.title));
}


// --- Helper Function to Format Duration (same as your previous request) ---
function formatPlaylistDuration(totalSeconds) {
    if (isNaN(totalSeconds) || totalSeconds <= 0) { // Changed to <= 0
        return "0s";
    }

    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = Math.floor(totalSeconds % 60);

    let durationStr = "";
    if (hours > 0) {
        durationStr += `${hours}hr`;
        if (minutes > 0) {
            durationStr += ` ${minutes}m`;
        }
    } else if (minutes > 0) {
        durationStr += `${minutes}m`;
        if (seconds > 0) { // Only show seconds if there are minutes but no hours
            durationStr += ` ${seconds}s`;
        }
    } else if (seconds > 0) {
        durationStr += `${seconds}s`;
    } else {
        return "0s"; // Should ideally not be reached if totalSeconds > 0
    }
    return durationStr.trim();
}

// Helper for openAddToPlaylistModal to avoid code duplication
function _populateAndShowAddToPlaylistModal(songToAddWithDuration) {
    if (!modalPlaylistListElement || !addToPlaylistModalElement) {
        console.error("Add to playlist modal elements not found.");
        return;
    }
    modalPlaylistListElement.innerHTML = '';

    const createClickHandler = (addFunction, playlistContextId = null) => {
        return () => {
            addFunction(playlistContextId ? playlistContextId : songToAddWithDuration, playlistContextId ? songToAddWithDuration : undefined);
            closeAddToPlaylistModal();
        };
    };
    
    // Option to add to Liked Songs
    const likedItem = document.createElement('div');
    likedItem.className = 'modal-playlist-item';
    likedItem.textContent = "Liked Songs";
    likedItem.onclick = () => {
        addSongToLikedPlaylist({ // Pass the full song object
            id: songToAddWithDuration.id.toString(),
            title: songToAddWithDuration.title,
            artist: songToAddWithDuration.artist,
            artwork: songToAddWithDuration.artwork,
            durationSeconds: songToAddWithDuration.durationSeconds
        });
        closeAddToPlaylistModal();
    };
    modalPlaylistListElement.appendChild(likedItem);

    userPlaylists.forEach(playlist => {
        const playlistItem = document.createElement('div');
        playlistItem.className = 'modal-playlist-item';
        playlistItem.textContent = escapeHtml(playlist.name);
        playlistItem.onclick = () => {
            addSongToUserPlaylist(playlist.id, { // Pass the full song object
                id: songToAddWithDuration.id.toString(),
                title: songToAddWithDuration.title,
                artist: songToAddWithDuration.artist,
                artwork: songToAddWithDuration.artwork,
                durationSeconds: songToAddWithDuration.durationSeconds
            });
            closeAddToPlaylistModal();
        };
        modalPlaylistListElement.appendChild(playlistItem);
    });

    if (modalPlaylistListElement.children.length === 1 && userPlaylists.length === 0) {
         const noUserPlaylistsMsg = document.createElement('p');
         noUserPlaylistsMsg.textContent = 'No other playlists. Create one first!';
         noUserPlaylistsMsg.style.textAlign = 'center';
         noUserPlaylistsMsg.style.marginTop = '10px';
         modalPlaylistListElement.appendChild(noUserPlaylistsMsg);
    }

    addToPlaylistModalElement.style.display = 'flex';
}

// Helper to prevent XSS
function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') {
        // console.warn("escapeHtml called with non-string:", unsafe);
        return unsafe === null || typeof unsafe === 'undefined' ? '' : String(unsafe);
    }
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'")
}
```

js/search.js
```js
// --- Event Listeners for searchInput ---

searchInput.addEventListener("focus", function () {
  if (searchInput.value.trim() === "") {
      displayRecentSearches();
  }
  // If there's text, the 'input' event will handle regular search suggestions or actual search
});

searchInput.addEventListener("input", function () {
  clearTimeout(searchTimeout); // searchTimeout should be defined (e.g., in init.js or top of this file)
  const query = searchInput.value.trim();

  if (query.length > 1) {
      searchTimeout = setTimeout(() => {
          searchSongs(query);
      }, 300);
  } else if (query.length === 0) {
      displayRecentSearches(); // Show recent searches if input is cleared
  } else {
      // Query is 1 char, or just spaces - hide main song search results
      hideSearchResults(); 
      // Optionally, you could still show recent searches here if desired,
      // but typical behavior is to hide until input is empty or long enough for song search.
  }
});

searchInput.addEventListener("keypress", function (e) {
  if (e.key === "Enter") {
      clearTimeout(searchTimeout);
      const query = searchInput.value.trim();
      if (query.length > 1) {
          searchSongs(query); // searchSongs will handle adding to recent history on success
      } else if (query.length === 0) {
          hideSearchResults(); // Don't search an empty string on enter
      }
  }
});

// --- Main Search Function ---
function searchSongs(query) {
  if (!searchResults) { // Guard
      console.error("Search results element not found");
      return;
  }
  searchResults.innerHTML = '<div class="loading">Searching...</div>';
  showSearchResults();

  // SEARCH_EP should be globally available from endpoints.js
  const url = `${SEARCH_EP}${encodeURIComponent(query)}&media=music&entity=song&limit=10`;

  fetch(url)
      .then((response) => response.json())
      .then((data) => {
          console.log("iTunes search results:", data);
          // displaySearchResults is for song results. displayRecentSearches is for history.
          if (data.results && data.results.length > 0) {
              // Uses addRecentSearch() from history.js
              addRecentSearch(query); 
              displaySongSearchResults(data.results); // Renamed for clarity
          } else {
              // Don't add to history if no song results found for this query
              displaySongSearchResults(data.results); // Will show "No results found"
          }
      })
      .catch((error) => {
          console.error("Error searching iTunes:", error);
          searchResults.innerHTML =
              '<div class="loading">Search failed. Please try again.</div>';
      });
}

// Renamed your original displaySearchResults to avoid conflict with the new one for history
// This function displays actual song search results from iTunes.
function displaySongSearchResults(results) {
    if (!searchResults) return;
  
    if (!results || results.length === 0) {
        searchResults.innerHTML = '<div class="loading">No results found</div>';
        return;
    }
  
    searchResults.innerHTML = "";
  
    results.forEach((item) => {
        if (!item.trackName || !item.artistName || !item.trackId || !item.artworkUrl100) {
            console.warn("Skipping search result due to missing data:", item);
            return;
        }
  
        const resultElement = document.createElement("div");
        resultElement.className = "result-item";
  
        // --- BEGIN MODIFICATION: Store duration ---
        const durationSeconds = item.trackTimeMillis ? Math.round(item.trackTimeMillis / 1000) : 0; // Default to 0 if not present
        // --- END MODIFICATION ---
  
        resultElement.dataset.trackId = item.trackId.toString();
        resultElement.dataset.trackName = item.trackName;
        resultElement.dataset.artistName = item.artistName;
        resultElement.dataset.artworkUrl100 = item.artworkUrl100;
        resultElement.dataset.durationSeconds = durationSeconds.toString(); // Store as string in dataset
  
        resultElement.innerHTML = `
            <div class="result-img">
                <img src="${item.artworkUrl100}" alt="${escapeHtml(item.trackName)}" crossorigin="anonymous">
            </div>
            <div class="result-info">
                <div class="result-title">${escapeHtml(item.trackName)}</div>
                <div class="result-artist">${escapeHtml(item.artistName)}</div>
            </div>
            <button class="add-to-playlist-search-btn icon-action-btn" title="Add to playlist">
                <i class="icon icon-plus-circle"></i>
            </button>
        `;
        
        resultElement.addEventListener("click", (event) => {
            if (event.target.closest('.add-to-playlist-search-btn')) {
                return;
            }
            if (typeof clearPlaylistContext === 'function') clearPlaylistContext();
            // --- MODIFICATION: Pass durationSeconds to playSong ---
            playSong(item.trackName, item.artistName, item.artworkUrl100, item.trackId.toString(), durationSeconds);
            // --- END MODIFICATION ---
            hideSearchResults();
            if (searchInput) searchInput.value = "";
            event.stopPropagation();
        });
  
        const addToPlaylistBtnForResult = resultElement.querySelector('.add-to-playlist-search-btn');
        if (addToPlaylistBtnForResult) {
            addToPlaylistBtnForResult.addEventListener('click', (event) => {
                event.stopPropagation();
                const songDataForModal = {
                    id: item.trackId.toString(),
                    title: item.trackName,
                    artist: item.artistName,
                    artwork: item.artworkUrl100,
                    // --- MODIFICATION: Add durationSeconds to songDataForModal ---
                    durationSeconds: parseInt(resultElement.dataset.durationSeconds, 10) || 0
                    // --- END MODIFICATION ---
                };
                if (typeof openAddToPlaylistModal === 'function') {
                    openAddToPlaylistModal(songDataForModal);
                } else {
                    console.error("openAddToPlaylistModal function not found");
                }
            });
        }
        searchResults.appendChild(resultElement);
    });
  }

// --- Utility functions (showSearchResults, hideSearchResults) ---
// These should be your existing functions:
function showSearchResults() {
  if (searchResults) searchResults.classList.add("active");
}

function hideSearchResults() {
  if (searchResults) searchResults.classList.remove("active");
}

// --- Display Logic for Recent Searches ---
function displayRecentSearches() {
  // Uses getRecentSearches() from history.js or this file
  const recentSearches = getRecentSearches(); 

  if (!searchResults) return; 

  if (recentSearches.length === 0) {
      searchResults.innerHTML = '<div class="loading" style="padding: 10px 0;">No recent searches.</div>';
      showSearchResults(); 
      return;
  }

  searchResults.innerHTML = ''; 
  const title = document.createElement('div');
  title.className = 'recent-searches-title';
  title.textContent = 'Recent Searches';
  searchResults.appendChild(title);

  recentSearches.forEach(query => {
      const recentItem = document.createElement('div');
      recentItem.className = 'recent-search-item result-item'; 

      recentItem.innerHTML = `
          <span class="recent-search-query">${escapeHtml(query)}</span>
          <button class="remove-recent-search-btn icon-action-btn" title="Remove from history">
              <i class="icon icon-close"></i>
          </button>
      `;

      // Event listener for the entire recentItem (covers clicking the query text area)
      recentItem.addEventListener('click', (event) => {
          // If the click was specifically on the remove button,
          // let its own handler (which also stops propagation) do the work.
          if (event.target.closest('.remove-recent-search-btn')) {
              return;
          }
          
          // This click is on the recent search item (likely the query text area) to initiate a search
          searchInput.value = query; 
          searchSongs(query); // This will refresh the searchResults content
          
          // IMPORTANT: Stop this click from bubbling up to the document listener
          event.stopPropagation(); 
      });

      const removeBtn = recentItem.querySelector('.remove-recent-search-btn');
      if (removeBtn) {
          removeBtn.addEventListener('click', (event) => {
              event.stopPropagation(); // Crucial: Prevent parent (recentItem) click and document click
              removeRecentSearch(query); 
              displayRecentSearches();   // Re-render the recent searches list immediately
          });
      }
      searchResults.appendChild(recentItem);
  });
  showSearchResults(); 
}
```

js/toast.js
```js
// js/toast.js

const toastContainer = document.getElementById('toastContainer');
const MAX_TOASTS = 1; // Define the maximum number of toasts allowed

// Store references to active toasts and their removal timeouts
let activeToasts = []; // Array of { element: toastElement, timeoutId: id }

/**
 * Displays a toast message, managing the maximum number of toasts.
 * @param {string} message The message to display.
 * @param {number} duration How long the toast should be visible in milliseconds (default: 3000).
 */
function showToast(message, duration = 3000) {
    if (!toastContainer) {
        console.error("Toast container not found!");
        alert(message); // Fallback
        return;
    }

    // If max toasts (or more) are considered active, remove the oldest one.
    // "Oldest" here refers to the one added first to our activeToasts array.
    if (activeToasts.length >= MAX_TOASTS) {
        const oldestToastEntry = activeToasts.shift(); // Remove from beginning of our tracking array
        if (oldestToastEntry) {
            clearTimeout(oldestToastEntry.timeoutId); // Stop its scheduled removal
            // Force remove its 'show' class and then remove from DOM without waiting for transition
            // This is to make space immediately.
            if (oldestToastEntry.element.parentNode) {
                oldestToastEntry.element.classList.remove('show'); // Start fade if desired, but removal is next
                oldestToastEntry.element.remove(); // Immediate DOM removal
            }
        }
    }

    const toastElement = document.createElement('div');
    toastElement.className = 'toast-message';
    toastElement.textContent = message;

    toastContainer.appendChild(toastElement);

    // Trigger the animation for showing
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toastElement.classList.add('show');
        });
    });

    const removalTimeoutId = setTimeout(() => {
        // Start fade out animation
        toastElement.classList.remove('show');

        // Remove from DOM after transition
        const transitionEndHandler = () => {
            if (toastElement.parentNode) {
                toastElement.parentNode.removeChild(toastElement);
            }
            // Clean up from our activeToasts array
            activeToasts = activeToasts.filter(t => t.element !== toastElement);
            toastElement.removeEventListener('transitionend', transitionEndHandler); // Clean up listener
        };
        toastElement.addEventListener('transitionend', transitionEndHandler);

        // Fallback: if transitionend doesn't fire (e.g. element removed by other means, or no transition)
        // remove it from activeToasts after a bit longer than the transition duration
        setTimeout(() => {
            activeToasts = activeToasts.filter(t => t.element !== toastElement);
            if (toastElement.parentNode) { // If still in DOM and transitionend didn't fire
                 toastElement.remove();
            }
        }, duration + 500); // duration of show + css transition time (e.g., 300ms) + buffer

    }, duration);

    // Add to our tracking array
    activeToasts.push({ element: toastElement, timeoutId: removalTimeoutId });
}
```

js/archive/getYT.v0..js
```js
// GOOGLE API
function getYTGoogleAPI(query) {
    // Determine which Google API key to use based on the counter
    const keyIndex = googleApiKeyCounter % YT_KEYS.length;
    const currentGoogleAPIKey = YT_KEYS[keyIndex];

    // One-liner console.log to show which key is being used
    console.log(`Google API: Using key index ${keyIndex}`);

    const url = `${YT_EP}${encodeURIComponent(
        query
    )}&type=video&videoEmbeddable=true&key=${currentGoogleAPIKey}&maxResults=1`; // Use currentGoogleAPIKey here

    fetch(url)
        .then((response) => response.json())
        .then((data) => {
            console.log("Youtube results (Google API):", data);
            if (data.items && data.items.length > 0) {
                const videoId = data.items[0].id.videoId;
                loadVid(videoId);
            } else {
                console.error("No YouTube results found (Google API)");
            }
        })
        .catch((error) => {
            console.error("Error searching YouTube (Google API):", error);
        });

    // Increment the Google API key counter for the next call
    googleApiKeyCounter++;
}
  
  // youtube-v3-alternative RAPIDAPI
  function getYTRapidAPI(query) {
    const keyIndex = rapidApiKeyCounter % RAPIDAPI_KEYS.length; // Get the current index
    const currentRapidAPIKey = RAPIDAPI_KEYS[keyIndex];

    console.log(`RapidAPI: Using key index ${keyIndex}`);
    // Your RapidAPI Key
    const url = `https://${RAPIDAPI_HOST}/search?query=${encodeURIComponent(
      query
    )}&geo=US&lang=en`;
  
    fetch(url, {
      method: 'GET',
      headers: {
        'x-rapidapi-host': RAPIDAPI_HOST,
        'x-rapidapi-key': currentRapidAPIKey, // RAPIDAPI_KEY
      },
    })
      .then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then((data) => {
        console.log("RapidAPI Youtube results:", data);
  
        if (data && data.data && data.data.length > 0) {
          const videoId = data.data[0].videoId;
  
          if (videoId) {
            loadVid(videoId);
          } else {
            console.error("Could not extract video ID from RapidAPI results.", data.data[0]);
          }
        } else {
          console.error("No RapidAPI YouTube results found or unexpected data structure.");
        }
      })
      .catch((error) => {
        console.error("Error searching RapidAPI YouTube:", error);
      });
      rapidApiKeyCounter++;
  }




let apiCallCounter = 0;
let rapidApiKeyCounter = 0;
let googleApiKeyCounter = 0;

function getYT(query) {
  // Use the modulo operator to alternate between 0 and 1
  if (apiCallCounter % 2 === 0) {
    console.log("Using Google API for search...");
    getYTGoogleAPI(query);
  } else {
    console.log("Using RapidAPI for search...");
    getYTRapidAPI(query);
  }
  // Increment the counter for the next call
  apiCallCounter++;
}

```

js/archive/getYT.v1..js
```js
// --- Global Counters and API Keys (ensure these are defined globally) ---




let apiCallCounter = 0; // Cycles between Google API and RapidAPI
let rapidApiKeyCounter = 0; // Cycles RapidAPI keys
let googleApiKeyCounter = 0; // Cycles Google API keys

// GOOGLE API
function getYTGoogleAPI(query) {
    return new Promise((resolve, reject) => { // Return a Promise
        const keyIndex = googleApiKeyCounter % YT_KEYS.length;
        const currentGoogleAPIKey = YT_KEYS[keyIndex];

        console.log(`Google API: Using key index ${keyIndex}`);

        const url = `${YT_EP}${encodeURIComponent(
            query
        )}&type=video&videoEmbeddable=true&key=${currentGoogleAPIKey}&maxResults=1`;

        fetch(url)
            .then((response) => {
                if (!response.ok) {
                    // Throw an error for HTTP issues (4xx, 5xx)
                    throw new Error(`Google API HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then((data) => {
                console.log("Youtube results (Google API):", data);
                if (data.items && data.items.length > 0) {
                    const videoId = data.items[0].id.videoId;
                    loadVid(videoId);
                    googleApiKeyCounter++; // Increment counter on success
                    resolve(true); // Resolve the Promise indicating success
                } else {
                    console.error("No YouTube results found (Google API)");
                    googleApiKeyCounter++; // Increment counter even if no results, to cycle key
                    reject(new Error("No YouTube results found (Google API)")); // Reject if no results
                }
            })
            .catch((error) => {
                console.error("Error searching YouTube (Google API):", error);
                googleApiKeyCounter++; // Increment counter on error, to cycle key
                reject(error); // Reject the Promise on fetch error
            });
    });
}

// youtube-v3-alternative RAPIDAPI
function getYTRapidAPI(query) {
    return new Promise((resolve, reject) => { // Return a Promise
        const keyIndex = rapidApiKeyCounter % RAPIDAPI_KEYS.length;
        const currentRapidAPIKey = RAPIDAPI_KEYS[keyIndex];

        console.log(`RapidAPI: Using key index ${keyIndex}`);

        const url = `https://${RAPIDAPI_HOST}/search?query=${encodeURIComponent(
            query
        )}&geo=US&lang=en`;

        fetch(url, {
            method: 'GET',
            headers: {
                'x-rapidapi-host': RAPIDAPI_HOST,
                'x-rapidapi-key': currentRapidAPIKey,
            },
        })
            .then((response) => {
                if (!response.ok) {
                    // Throw an error for HTTP issues
                    throw new Error(`RapidAPI HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then((data) => {
                console.log("RapidAPI Youtube results:", data);
                if (data && data.data && data.data.length > 0) {
                    const videoId = data.data[0].videoId;
                    if (videoId) {
                        loadVid(videoId);
                        rapidApiKeyCounter++; // Increment counter on success
                        resolve(true); // Resolve the Promise indicating success
                    } else {
                        console.error("Could not extract video ID from RapidAPI results.", data.data[0]);
                        rapidApiKeyCounter++; // Increment counter even if no videoId, to cycle key
                        reject(new Error("Could not extract video ID from RapidAPI results.")); // Reject
                    }
                } else {
                    console.error("No RapidAPI YouTube results found or unexpected data structure.");
                    rapidApiKeyCounter++; // Increment counter even if no results, to cycle key
                    reject(new Error("No RapidAPI YouTube results found or unexpected data structure.")); // Reject
                }
            })
            .catch((error) => {
                console.error("Error searching RapidAPI YouTube:", error);
                rapidApiKeyCounter++; // Increment counter on error, to cycle key
                reject(error); // Reject the Promise on fetch error
            });
    });
}


// --- Main getYT function with fallback logic ---
async function getYT(query) {
    let searchSuccessful = false;

    // Determine the primary API for this call
    const primaryApiIsGoogle = (apiCallCounter % 2 === 0);

    if (primaryApiIsGoogle) {
        console.log("Attempting with Google API (Primary)...");
        try {
            await getYTGoogleAPI(query);
            searchSuccessful = true; // Primary attempt succeeded
        } catch (error) {
            console.warn("Google API failed. Attempting with RapidAPI (Fallback)...", error);
            try {
                await getYTRapidAPI(query);
                searchSuccessful = true; // Fallback attempt succeeded
            } catch (fallbackError) {
                console.error("Both Google API and RapidAPI failed:", fallbackError);
            }
        }
    } else { // Primary API is RapidAPI
        console.log("Attempting with RapidAPI (Primary)...");
        try {
            await getYTRapidAPI(query);
            searchSuccessful = true; // Primary attempt succeeded
        } catch (error) {
            console.warn("RapidAPI failed. Attempting with Google API (Fallback)...", error);
            try {
                await getYTGoogleAPI(query);
                searchSuccessful = true; // Fallback attempt succeeded
            } catch (fallbackError) {
                console.error("Both RapidAPI and Google API failed:", fallbackError);
            }
        }
    }

    // Only increment the main API counter if at least one API call was successful
    if (searchSuccessful) {
        apiCallCounter++;
    } else {
        // If both failed, we don't increment apiCallCounter.
        // This means the next getYT call will try the *same primary API* again,
        // allowing for a re-attempt with a potentially fresh state or a fix.
        console.warn("No video loaded after all attempts. Next getYT call will re-attempt the same primary API.");
    }
}
```

