I have a static music player. I am going to provide you the filenames and the code for each file so you can understand my codebase. Then, in the following prompts I will ask you prompts to help me develop it and add new features. For now, just fully understand the codebase and the program so you can be ready to help me add more features and tweak things. 

index.html
```html
<!DOCTYPE html>
<!--------------------------------------*
* - iTunes api - searching
* - lyrics.ovh - lyrics
* - youtube data v3 - player
* - RapidAPI (rapidapi.com/ytdlfree/api/youtube-v3-alternative) - cycling player
*--------------------------------------->
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Music Player</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.min.js"></script>
    <link rel="stylesheet" href="css/all.css" />

    <link rel="icon" href="img/favicon.png" type="image/x-icon">
  </head>
  <body>
    <div class="app-container"> 
        <div class="main-content">
            <div class="search-container">
            <input
                type="text"
                class="search-input"
                placeholder="Search for any song..."
                id="searchInput"
                autocomplete="off"
            />
            <div class="search-results" id="searchResults">
            </div>
            </div>

            

            <div class="player-area">
                <div class="player">
                    <div class="album-art">
                        <img
                        src="img/empty_art.png"
                        alt="Album"
                        id="albumCover"
                        crossorigin="anonymous"
                        />
                    </div>
                    <div class="info" id="playerInfo">
                        <div class="track-title" id="trackTitle">Not Playing</div>
                        <div class="artist" id="artistName">Not Playing</div>
                        <div class="controls">
                            <i id="prevBtn" class="icon icon-prev"></i>
                            <i id="playPause" class="icon icon-play"></i>
                            <i id="nextBtn" class="icon icon-next"></i>
                            <i id="volumeBtn" class="icon icon-volume"></i>
                            <i id="loopBtn" class="icon icon-loop"></i>
                            <i id="shuffleBtn" class="icon icon-shuffle"></i> 
                            <i id="likeBtn" class="icon icon-heart-empty"></i>
                            <i id="addToPlaylistBtn" class="icon icon-plus-circle"></i>
                        </div>
                        <div id="seekbar" class="seekbar"><div id="progress"></div></div>
                        <div class="timecodes">
                        <span id="currentTime">0:00</span>
                        <span id="remainingTime">-0:00</span>
                        </div>
                    </div>

                    <div class="lyrics-info" id="lyricsInfo">
                        <div class="lyrics-header">
                        <div>
                            <div class="lyrics-title" id="lyricsSongTitle">Not Playing</div>
                            <div class="lyrics-artist" id="lyricsArtistName">Not Playing</div>
                        </div>
                        </div>
                        <div class="lyrics-content" id="lyricsContent">
                        No lyrics available.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="playlist-sidebar" id="playlistSidebar">
          <div class="playlist-sidebar-header">
              <button id="backToPlaylistsBtn" class="sidebar-back-button icon-button" title="Back to playlists" style="display: none;">
                <i class="icon icon-arrow-left"></i>
              </button>
              <h3 id="sidebarTitle">Your Playlists</h3>
              <button id="createNewPlaylistBtn" class="create-playlist-btn">+</button>
          </div>
          <div class="playlist-content" id="playlistDisplayArea">
          </div>
      </div>


    </div>


    <div class="lyrics-toggle" id="lyricsToggle">
      <i class="icon icon-lyrics"></i>
    </div>


    <div id="player-container">
      <div id="ytPlayer"></div>
    </div>

    <div id="addToPlaylistModal" class="modal" style="display:none;">
      <div class="modal-content">
          <span class="close-modal-btn" id="closeAddToPlaylistModal">×</span>
          <h4>Add to Playlist</h4>
          <div id="modalPlaylistList">
              <!-- Playlists will be dynamically inserted here -->
          </div>
      </div>
    </div>

    <div id="generalModal" class="modal" style="display:none;">
      <div class="modal-content">
          <span class="close-modal-btn" id="closeGeneralModal">×</span>
          <h4 id="generalModalTitle">Notification</h4>
          <p id="generalModalMessage" style="text-align: center; margin-bottom: 20px;"></p>
          <div id="generalModalActions" style="text-align: center;">
              <!-- Buttons will be dynamically inserted here -->
          </div>
      </div>
  </div>

  <div id="createPlaylistModal" class="modal" style="display:none;">
    <div class="modal-content">
        <span class="close-modal-btn" id="closeCreatePlaylistModal">×</span>
        <h4 id="createPlaylistModalTitle">Create New Playlist</h4>
        <div class="form-group" style="margin-bottom: 20px;">
            <label for="newPlaylistNameInput" style="display: block; margin-bottom: 8px; font-weight: 500;">Playlist Name:</label>
            <input type="text" id="newPlaylistNameInput" class="modal-input" placeholder="My Awesome Playlist">
        </div>
        <div id="createPlaylistModalActions" style="text-align: right;">
            <button id="cancelCreatePlaylistBtn" class="modal-button secondary" style="margin-right: 10px;">Cancel</button>
            <button id="confirmCreatePlaylistBtn" class="modal-button success">Create</button>
        </div>
    </div>
  </div>

  <div id="renamePlaylistModal" class="modal" style="display:none;">
    <div class="modal-content">
        <span class="close-modal-btn" id="closeRenamePlaylistModal">×</span>
        <h4 id="renamePlaylistModalTitle">Rename Playlist</h4>
        <div class="form-group" style="margin-bottom: 20px;">
            <label for="renamePlaylistNameInput" style="display: block; margin-bottom: 8px; font-weight: 500;">New Playlist Name:</label>
            <input type="text" id="renamePlaylistNameInput" class="modal-input" placeholder="Enter new name">
        </div>
        <div id="renamePlaylistModalActions" style="text-align: right;">
            <button id="cancelRenamePlaylistBtn" class="modal-button secondary" style="margin-right: 10px;">Cancel</button>
            <button id="confirmRenamePlaylistBtn" class="modal-button success">Save</button>
        </div>
    </div>
  </div>

  <div id="toastContainer" class="toast-container">
    <!-- Toasts will be dynamically added here -->
  </div>

    <script src="js/endpoints.js"></script>
    <script src="js/init.js"></script>
    <script src="js/modals.js"></script>
    <script src="js/toast.js"></script>
    <script src="js/bg.js"></script>
    <script src="js/playlist.js"></script>
    <script src="js/player.js"></script>
    <script src="js/history.js"></script> 
    <script src="js/search.js"></script>
    <script src="js/play.js"></script>
    <script src="js/getYT.js"></script>
    <script src="js/lyrics.js"></script>
    <script src="js/playback.js"></script>

    <script>
      document.addEventListener("click", function (e) {
        // Ensure searchInput and searchResults are defined before accessing contains
        if (typeof searchInput !== 'undefined' && typeof searchResults !== 'undefined' &&
            !searchResults.contains(e.target) && e.target !== searchInput) {
          if (typeof hideSearchResults === 'function') hideSearchResults();
        }
      });

      document.addEventListener('DOMContentLoaded', () => {
        if (typeof initializeModals === 'function') { // Initialize the new modal system
            initializeModals();
        } else {
            console.error("initializeModals function not found.");
        }
        if (typeof initializePlaylistSystem === 'function') { // Initialize the playlist system
            initializePlaylistSystem();
        } else {
            console.error("initializePlaylistSystem function not found.");
        }

      });
    </script>
  </body>
</html>
```

css/all.css
```css
:root {
  --bg-start: #747474;
  --bg-end: #4b4b4b;
  --card-width: 540px; /* Not directly used by player anymore, but keep for reference */
  --card-height: 220px; /* Not directly used by player anymore */
  --sidebar-width: 300px; /* New variable for playlist sidebar */
}
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
body {
  min-height: 100vh;
  background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
  font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    sans-serif;
  color: #fff;
  transition: background 0.8s ease;
  overflow-x: hidden; /* Prevent horizontal scroll if content is too wide */
}

.app-container {
  display: flex;
  padding: 20px;
  width: 100%;
  /* min-height: calc(100vh - 40px); /* This sets a minimum, but flex items can still grow it */
  height: calc(100vh - 40px); /* Try setting a fixed height for the container */
  max-height: calc(100vh - 40px); /* And a max-height to prevent overflow */
  gap: 20px;
  box-sizing: border-box; /* Ensure padding is included in height calculation */
}

.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  /* Crucial: Allow main content to scroll if its content is too tall,
     but try to keep it from expanding app-container beyond viewport height. */
  overflow-y: auto;
  min-height: 0; /* Fix for flex item overflow issues in some browsers */
}

.search-container {
  width: 100%;
  max-width: 560px;
  margin-bottom: 20px;
  z-index: 100;
  position: relative; /* Changed from absolute */
}
.search-input {
  width: 100%;
  padding: 12px 20px;
  border-radius: 12px;
  border: none;
  font-family: "Inter", sans-serif;
  font-size: 16px;
  background: rgba(255, 255, 255, 0.15);
  color: #fff;
  outline: none;
  transition: all 0.2s ease;
  backdrop-filter: blur(5px);
}
.search-input::placeholder {
  color: rgba(255, 255, 255, 0.6);
}
.search-input:focus {
  background: rgba(255, 255, 255, 0.25);
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
}
.search-results {
  width: 100%; /* Match search input width */
  max-width: 560px; /* Match search input width */
  max-height: 400px;
  background: rgba(30, 30, 30, 0.65);
  backdrop-filter: blur(10px);
  border-radius: 8px;
  overflow-y: auto;
  opacity: 0;
  visibility: hidden;
  transition: all 0.2s ease;
  z-index: 99;
  position: absolute;
  top: calc(100% + 5px); /* Position below search input */
  left: 0;
  transform: translateY(-7px);
}
.search-results.active {
  opacity: 1;
  transform: translateY(0);
  visibility: visible;
}

/* Title for "Recent Searches" section in the dropdown */
.recent-searches-title {
  padding: 10px 16px 5px 16px;
  font-size: 12px; /* Made it slightly smaller */
  font-weight: 600; /* Made it a bit bolder */
  color: rgba(255, 255, 255, 0.7); /* Slightly more visible */
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08); /* Softer border */
  margin-bottom: 5px;
}

/* Individual recent search item */
.recent-search-item {
  /* .result-item class is also applied for base flex styling */
  display: flex;
  justify-content: space-between; /* Query left, button right */
  align-items: center;
  padding: 10px 16px; /* Consistent padding */
  /* cursor: default; /* Optional: override .result-item's cursor if only text is clickable */
}

.recent-search-item:hover {
  background-color: rgba(255, 255, 255, 0.08); /* Consistent hover */
}

/* The clickable query text */
.recent-search-query {
  flex-grow: 1;
  cursor: pointer;
  font-size: 15px; /* Match song title size or adjust */
  color: #fff; /* Brighter for better readability */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-right: 10px; /* Space before the X button */
}

/* The remove button for a recent search item */
.remove-recent-search-btn {
  /* .icon-action-btn class is applied for base styling (padding, border-radius) */
  /* We removed margin-left: auto from .icon-action-btn for this specific case if it was there,
     or ensure it doesn't apply if it's not needed due to justify-content: space-between */
  margin-left: 0; /* Explicitly override if .icon-action-btn has margin-left: auto */
  flex-shrink: 0;
}

.remove-recent-search-btn .icon.icon-close {
  /* .icon-action-btn .icon might set a default size (e.g., 16px) */
  width: 14px;  /* Adjust size as needed for the 'x' */
  height: 14px;
  background-color: rgba(255, 255, 255, 0.5); /* Dimmer for 'x' */
}

.remove-recent-search-btn:hover .icon.icon-close {
  background-color: #ff8080; /* Softer red on hover for 'x' */
}

.result-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  cursor: pointer;
  transition: background 0.2s;
  overflow: hidden;
}
.result-item:hover {
  background: rgba(255, 255, 255, 0.1);
}
.result-img {
  width: 60px;
  height: 60px;
  border-radius: 6px;
  overflow: hidden;
  margin-right: 16px;
  flex-shrink: 0;
}
.result-img img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.result-info {
  flex: 1;
  overflow: hidden; /* Ensure text ellipsis works */
  flex-grow: 1;
  margin-right: 8px;
}
.result-title {
  font-weight: 600;
  margin-bottom: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.result-artist {
  font-size: 14px;
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.player-area {
  display: flex;
  justify-content: center; /* Center the player itself */
  align-items: center; /* Vertically center if player-area has more height */
  width: 100%;
  margin-top: 20px; /* Space from search results or search bar */
  flex-grow: 1; /* Allow it to take space if main-content is taller */
}

.player {
  width: 570px; /* Fixed width for player */
  display: flex;
  align-items: center;
  gap: 28px;
  padding: 24px; /* Padding inside the player card */
  /* background: rgba(0,0,0,0.1); Optional: subtle background for player card */
  /* border-radius: 12px; Optional: rounded corners for player card */
}
.album-art {
  flex: 0 0 220px;
  height: 220px;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 20px rgba(0,0,0,0.3);
}
.album-art img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.info {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  padding-left: 0px;
  text-shadow: 0px 0px 12px rgba(0, 0, 0, 0.3);
  min-width: 0; /* Fix for flex item text overflow */
}

.track-title {
  font-size: 34px;
  font-weight: 700;
  margin-bottom: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; /* Let flexbox handle width */
}
.artist {
  font-size: 20px;
  opacity: 0.75;
  margin-bottom: 45px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; Let flexbox handle width */
}

.seekbar {
  height: 6px;
  background: rgba(255, 255, 255, 0.25);
  border-radius: 6px;
  position: relative;
  cursor: pointer;
  transition: height 0.2s ease;
}
.seekbar.active {
  height: 8px;
}
#progress {
  height: 100%;
  width: 0%;
  background: #fff;
  border-radius: 3px;
}
.timecodes {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  opacity: 0.7;
  margin-top: 4px;
}
#ytPlayer {
  position: absolute;
  top: -9999px; /* Move way off screen */
  left: -9999px;
  width: 1px;
  height: 1px;
  opacity: 0; /* Keep hidden */
}
.loading {
  text-align: center;
  padding: 20px;
  color: rgba(255, 255, 255, 0.7);
}
/* Custom Scrollbar Styles (these should already be present and apply to .playlist-content) */
.search-results::-webkit-scrollbar,
.lyrics-content::-webkit-scrollbar,
.playlist-content::-webkit-scrollbar {
  width: 8px; /* Slightly wider for better grab-ability if desired */
}
.search-results::-webkit-scrollbar-track,
.lyrics-content::-webkit-scrollbar-track,
.playlist-content::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px; /* Match thumb radius */
}
.search-results::-webkit-scrollbar-thumb,
.lyrics-content::-webkit-scrollbar-thumb,
.playlist-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.35); /* Slightly more visible thumb */
  border-radius: 4px;
}

/*
.playlist-content::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}
*/


/* Lyrics view */
.lyrics-info {
  flex: 1;
  display: none;
  flex-direction: column;
  justify-content: flex-start;
  text-shadow: 0px 0px 12px rgba(0, 0, 0, 0.3);
  min-width: 0;
  max-height: 220px; /* This should already be set to match album art */
  overflow: hidden; /* Ensures content that overflows max-height doesn't push parent */
}

.lyrics-content {
  flex-grow: 1;
  overflow-y: auto; /* This should already be there for lyrics scrolling */
  text-align: left;
  white-space: pre-line;
  padding-right: 10px;
  font-size: 16px;
  line-height: 1.6;
}

.lyrics-header {
  /* display: flex; */ /* Already flex from .lyrics-info if shown */
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  /* display: none; */ /* Control via .lyrics-info display */
}

.lyrics-title {
  font-size: 30px;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; */
}

.lyrics-artist {
  font-size: 16px;
  opacity: 0.75;
  margin-bottom: 15px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  /* max-width: 300px; */
}


.controls {
  display: flex;
  align-items: center;
  gap: 16px; /* Adjusted gap if needed */
  margin-bottom: 18px;
}
.controls i { /* Base icon style in controls */
  cursor: pointer;
  transition: 0.12s ease;
}
.controls i:active {
  transform: scale(0.94);
}

#playPause { font-size: 32px; }
#prevBtn, #nextBtn { font-size: 26px; display: none; }
#volumeBtn { font-size: 20px; }
#loopBtn { font-size: 22px; } /* Assuming you want loop button size */
#likeBtn { font-size: 22px; }
#addToPlaylistBtn { font-size: 22px; } /* New Add to Playlist button */

.lyrics-toggle {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 40px;
  background: rgba(255, 255, 255, 0.15);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(5px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: all 0.2s ease;
  z-index: 100;
}

.lyrics-toggle:hover {
  background: rgba(255, 255, 255, 0.25);
}

.lyrics-toggle i {
  background-color: white;
  width: 22px;
  height: 22px;
}



.icon {
display: inline-block;
width: 32px; /* Default width, can be overridden by ID */
height: 32px; /* Default height, can be overridden by ID */
background-color: white;
mask-repeat: no-repeat;
mask-position: center;
mask-size: contain;
-webkit-mask-repeat: no-repeat;
-webkit-mask-position: center;
-webkit-mask-size: contain;
transition: transform 0.1s ease, background-color 0.1s ease;
}

.icon:active {
transform: scale(0.94);
}

/* Optional: common styling for icon-only buttons if you have more */
.icon-button { /* You added this class to the button in HTML */
  background: none;
  border: none;
  cursor: pointer;
  padding: 6px; /* Example padding */
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}
.icon-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}
.icon-button .icon {
  width: 20px; /* Default icon size for icon-buttons */
  height: 20px;
  background-color: white;
}

/* New/Refined Styles for Action Buttons within list items */
.icon-action-btn { /* Common style for small icon buttons like remove/edit */
  background: none;
  border: none;
  padding: 5px; /* Adjust padding to control clickable area and spacing */
  cursor: pointer;
  display: inline-flex; /* Helps align icon inside */
  align-items: center;
  justify-content: center;
  border-radius: 50%; /* Make it circular */
  transition: background-color 0.2s ease;
  /* Position it to the right if desired within the playlist item flex layout */
  margin-left: auto; /* Pushes button to the far right of its flex container if .playlist-item is display:flex */
}

.icon-action-btn:hover {
  background-color: rgba(255, 255, 255, 0.1); /* Subtle hover effect */
}


.icon-action-btn .icon { /* Style for the icon INSIDE these action buttons */
  width: 16px;
  height: 16px;
  background-color: rgba(255, 255, 255, 0.7);
  transition: background-color 0.2s ease;
  pointer-events: none; /* <<<<<<<<<<<<<<<<<<< ADD THIS LINE */
}

.icon-action-btn:hover .icon {
  background-color: #ff6b6b; /* Change icon color on hover - e.g., red for delete */
}

.add-to-playlist-search-btn {
  flex-shrink: 0; /* Prevents the button from shrinking */
  /* .icon-action-btn already provides margin-left: auto and other base styles */
}

/* 4. Style the icon INSIDE the button for specific size */
.add-to-playlist-search-btn .icon.icon-plus-circle {
  width: 18px;  /* Or 16px to match other .icon-action-btn .icon, or 20px. Adjust to taste. */
  height: 18px; /* Match width */
}

.icon-close {
  mask-image: url('../img/icons/close.svg');
  -webkit-mask-image: url('../img/icons/close.svg');
}

.icon-arrow-left {
  mask-image: url('../img/icons/arrow-left.svg');
  -webkit-mask-image: url('../img/icons/arrow-left.svg');
  /* background-color will be inherited or set by .sidebar-back-button .icon */
}
.icon-edit {
  mask-image: url('../img/icons/edit.svg');
  -webkit-mask-image: url('../img/icons/edit.svg');
}
.icon-trash {
  mask-image: url('../img/icons/trash.svg');
  -webkit-mask-image: url('../img/icons/trash.svg');
}

/* Add near other icon definitions */
.icon-shuffle {
  mask-image: url('../img/icons/shuffle.svg');
  -webkit-mask-image: url('../img/icons/shuffle.svg');
}

/* Add near .icon-loop.loop-active for active state styling */
.icon-shuffle.shuffle-active {
  background-color: #00ff88; /* Green color, same as active loop */
  transform: scale(1.1); /* Optional: visual feedback */
}

/* Adjust size for these small action buttons if needed */
.playlist-item-actions .icon {
    width: 1em; /* Or a fixed px value like 14px */
    height: 1em;
    background-color: currentColor; /* Inherit color from button */
}
.icon-play { mask-image: url('../img/icons/play.svg'); -webkit-mask-image: url('../img/icons/play.svg'); }
.icon-pause { mask-image: url('../img/icons/pause.svg'); -webkit-mask-image: url('../img/icons/pause.svg'); }
.icon-volume { mask-image: url('../img/icons/volume-loud.svg'); -webkit-mask-image: url('../img/icons/volume-loud.svg'); }
.icon-muted { mask-image: url('../img/icons/mute.svg'); -webkit-mask-image: url('../img/icons/mute.svg'); }
.icon-lyrics { mask-image: url('../img/icons/lyrics.svg'); -webkit-mask-image: url('../img/icons/lyrics.svg'); }
.icon-lyrics-on { mask-image: url('../img/icons/music.svg'); -webkit-mask-image: url('../img/icons/music.svg'); }
.icon-plus-circle {
  mask-image: url('../img/icons/plus-circle.svg');
  -webkit-mask-image: url('../img/icons/plus-circle.svg');

}
.icon-loop { /* Base style for the loop button - uses repeat.svg */
  mask-image: url('../img/icons/repeat.svg');
  -webkit-mask-image: url('../img/icons/repeat.svg');
  /* Default color is white (from .icon) */
}

/* New: Loop Playlist State (repeat.svg but green) */
.icon-loop.loop-playlist-active {
  /* Uses the default repeat.svg mask from .icon-loop */
  background-color: #00ff88; /* Green color */
  transform: scale(1.1); /* Optional: visual feedback, matches loop-song */
}

.icon-loop.loop-active { /* This class now specifically means "loop current song" */
  mask-image: url('../img/icons/repeat-1.svg'); /* with the "1" on it */
  -webkit-mask-image: url('../img/icons/repeat-1.svg');
  background-color: #00ff88; /* Green color */
  transform: scale(1.1); /* You already had this, good */
}

/* New Playlist Icons */
.icon-heart-empty {
mask-image: url('../img/icons/heart-empty.svg');
-webkit-mask-image: url('../img/icons/heart-empty.svg');

}
.icon-heart-filled {
mask-image: url('../img/icons/heart-filled.svg');
-webkit-mask-image: url('../img/icons/heart-filled.svg');
background-color: #ff6b6b; /* Liked color */

}
.icon-prev {
mask-image: url('../img/icons/prev.svg');
-webkit-mask-image: url('../img/icons/prev.svg');

}
.icon-next {
mask-image: url('../img/icons/next.svg');
-webkit-mask-image: url('../img/icons/next.svg');

}

/* Playlist Sidebar Styles - Focus here */
.playlist-sidebar {
  width: var(--sidebar-width);
  min-width: 280px;
  /* Important: Set a specific height or max-height for the sidebar.
     It should take available space in the flex container but not exceed it. */
  display: flex; /* Keep this to allow flex-grow on playlist-content */
  flex-direction: column; /* Keep this */
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(8px);
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  /* Core change: ensure sidebar doesn't grow beyond available vertical space */
  height: 100%; /* Take full height of its flex container slot if possible */
  max-height: 100%; /* Prevent it from exceeding the allocated height */
  overflow: hidden; /* This will hide any direct children overflow, forcing .playlist-content to scroll */
  min-height: 0; /* Another flexbox fix for potential overflow issues */
}

.playlist-sidebar-header {
  display: flex;
  /* justify-content: space-between; Keep this for overall structure */
  align-items: center;
  margin-bottom: 15px;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  flex-shrink: 0;
  position: relative; /* <<<< ADD THIS: For absolute positioning of title if needed, or for easier centering with flex */
}

.playlist-sidebar-header h3 { /* The #sidebarTitle element */
  font-size: 18px;
  font-weight: 600;
  margin: 0; /* Reset default margins */

  /* --- Centering Logic --- */
  position: absolute;       /* <<<< METHOD 1: Absolute Positioning */
  left: 50%;                /* <<<< METHOD 1 */
  transform: translateX(-50%); /* <<<< METHOD 1 */
  /* OR */
  /* flex-grow: 1;          /* <<<< METHOD 2: Flexbox Centering (Remove if using METHOD 1) */
  /* text-align: center;    /* <<<< METHOD 2 (Remove if using METHOD 1) */

  /* Ensure it doesn't overlap buttons if title is too long */
  max-width: calc(100% - 80px); /* Adjust 80px based on combined width of your back and create buttons + margins */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Styles for the sidebar back button - REFINED (Ensure this part is correct) */
.playlist-sidebar-header .sidebar-back-button {
  background: none;
  border: none;
  cursor: pointer;
  /* margin-right: auto; REMOVE THIS LINE. We want the title to push against the create button. */
  margin-right: 10px; /* <<<< ADD THIS: Add some space between back button and title */
  
  /* --- Key changes for perfect circle and centering --- */
  width: 32px;
  height: 32px;
  padding: 0;
  border-radius: 50%;
  
  display: flex;
  align-items: center;
  justify-content: center;
  
  transition: background-color 0.2s ease;
  flex-shrink: 0; /* <<<< ADD THIS: Prevent back button from shrinking */
}

.playlist-sidebar-header .sidebar-back-button:hover {
  /* opacity: 0.8; Remove this, use background-color change instead for icon buttons */
  background-color: rgba(255, 255, 255, 0.1);
}

.playlist-sidebar-header .sidebar-back-button .icon {
  /* Icon size should be smaller than the button's width/height
     to fit comfortably within the circle. */
  width: 18px;  /* Adjust icon size */
  height: 18px; /* Adjust icon size */
  background-color: white; /* Icon color */
  /* No need for margins on the icon if the button is using flex to center it */
}


.playlist-sidebar-header .create-playlist-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  color: white;
  font-size: 20px;
  font-weight: bold;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  cursor: pointer;
  line-height: 28px; /* Align plus vertically */
  text-align: center;
  margin-left: auto; /* <<<< ADD THIS: Add some space between title and create button */
  flex-shrink: 0;   /* <<<< ADD THIS: Prevent create button from shrinking */
}

/* General list display for playlists and songs in playlist */
.playlist-list-container { /* Wrapper for the ul if needed, or style #playlistDisplayArea directly */
  flex-grow: 1;
  overflow-y: auto;
  min-height: 0;
  padding-right: 8px; /* Gap for scrollbar */
}
.playlist-list-container ul {
  list-style: none;
  padding: 0;
  margin: 0;
}


.create-playlist-btn:hover {
  background: rgba(255,255,255,0.2);
}

/* Individual Playlist Item (in the list of playlists) */
.playlist-overview-item {
  display: flex;
  align-items: center;
  padding: 12px 8px;
  margin-bottom: 8px;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  position: relative; /* For delete/rename buttons */
}
.playlist-overview-item:hover {
  background-color: rgba(255, 255, 255, 0.08);
}
.playlist-overview-item-artwork {
  width: 50px;
  height: 50px;
  border-radius: 4px;
  margin-right: 15px;
  object-fit: cover;
  flex-shrink: 0;
}
.playlist-overview-item-info {
  flex-grow: 1;
  overflow: hidden;
}
.playlist-overview-item-name {
  font-size: 16px;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-bottom: 3px;
}
.playlist-overview-item-count {
  font-size: 13px;
  color: rgba(255, 255, 255, 0.7);
}
.playlist-item-actions button { /* For delete/rename buttons on playlist overview */
    background: none;
    border: none;
    color: rgba(255,255,255,0.6);
    cursor: pointer;
    padding: 3px;
    font-size: 14px;
    margin-left: 5px;
}
.playlist-item-actions button:hover {
    color: white;
}

/* Styling for input field when creating/renaming */
.playlist-name-input {
  width: calc(100% - 60px); /* Adjust based on sibling elements if any */
  padding: 8px;
  margin-bottom: 5px;
  background-color: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: white;
  border-radius: 4px;
  font-size: 16px;
}
.playlist-overview-item-info .playlist-name-input { /* When renaming inline */
  font-size: 16px;
  font-weight: 500;
  width: 100%;
}

/* Playlist content scrollbar (ensure it's styled nicely) */
#playlistDisplayArea::-webkit-scrollbar { width: 8px; }
#playlistDisplayArea::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 4px; }
#playlistDisplayArea::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.35); border-radius: 4px; }
#playlistDisplayArea {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.35) rgba(255, 255, 255, 0.05);
}

.playlist-content {
  flex-grow: 1; /* Allows this to take up remaining space in .playlist-sidebar - GOOD */
  overflow-y: auto; /* This enables the internal scrollbar - GOOD */
  min-height: 0; /* Flex item fix, ensures it can shrink and show scrollbar */
  padding-right: 8px; /* Adjust if scrollbar overlaps content slightly */
  scrollbar-width: thin; /* "auto" or "thin" */
  scrollbar-color: rgba(255, 255, 255, 0.35) rgba(255, 255, 255, 0.05); /* thumb track */
}


.playlist-item {
  display: flex;
  align-items: center;
  padding: 10px 5px; /* Base padding */
  margin-bottom: 8px;
  border-radius: 6px;
  cursor: pointer;
  background-color: transparent;
  user-select: none;
  /* Add transitions for smooth "sliding" and opacity change */
  transition: padding-top 0.15s ease-out, 
              padding-bottom 0.15s ease-out, 
              background-color 0.2s ease,
              opacity 0.15s ease-out; /* Added opacity transition */
}

.playlist-item:hover {
  background-color: rgba(255, 255, 255, 0.08);
}

.playlist-item.playing {
  background-color: rgba(255, 255, 255, 0.15);
}
.playlist-item.playing .playlist-item-title {
    color: #00ff88;
}

.playlist-item-artwork {
  width: 45px;
  height: 45px;
  border-radius: 4px;
  margin-right: 12px;
  object-fit: cover;
  flex-shrink: 0;
  pointer-events: none; /* Make sure drag events go to the li */
}

.playlist-item-info {
  flex-grow: 1;
  overflow: hidden;
  pointer-events: none; /* Make sure drag events go to the li */
}

/* Styles for the item being dragged */
.playlist-item.dragging {
  opacity: 0.5; /* Make it semi-transparent */
  background: rgba(255,255,255,0.1); /* Optional: slight background change */
  /* box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Optional: lift effect */
}

/* Styles to create visual space when dragging over an item */
.playlist-item.show-gap-above {
  padding-top: 55px; /* Adjust this value: item height (approx 45px) + margin (8px) + small buffer */
                      /* This pushes the content of *this* item down, making space above it. */
}

.playlist-item.show-gap-below {
  padding-bottom: 55px; /* Same logic, makes space below this item's content. */
}

/* Styles for the playlist overview item being dragged */
.playlist-overview-item.dragging {
  opacity: 0.5;
  background: rgba(255,255,255,0.2); /* Consistent with song dragging */
  /* box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Optional */
}

/* Styles to create visual space when dragging over a playlist overview item */
.playlist-overview-item.show-gap-above {
  /* Adjust padding based on typical height of .playlist-overview-item */
  /* .playlist-overview-item padding: 12px 8px; margin-bottom: 8px; artwork height: 50px */
  /* Roughly 50px (art) + 2*12px (padding) + 8px (margin) = 82px. Let's use a bit less. */
  padding-top: 75px;
}

.playlist-overview-item.show-gap-below {
  padding-bottom: 75px;
}

.playlist-item-title {
font-size: 15px;
font-weight: 500;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
margin-bottom: 2px;
}

.playlist-item-artist {
font-size: 13px;
color: rgba(255, 255, 255, 0.7);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}

.empty-playlist-message {
text-align: center;
color: rgba(255, 255, 255, 0.6);
margin-top: 30px;
font-style: italic;
}

.playlist-item.dragging {
opacity: 0.5;
background: rgba(255,255,255,0.2);
}

/* Modal Styles - Updated for Glassmorphism */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  /* The overlay itself remains semi-transparent black to dim the background */
  background-color: rgba(0,0,0,0.4); /* Slightly less dark overlay maybe */
  /* backdrop-filter: blur(2px); /* Optional: blur the entire page behind the modal - can be performance heavy */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px; /* Add some padding so modal doesn't hit screen edges on small viewports */
}

.modal-content {
  /* Glassmorphism Background */
  background-color: rgba(255, 255, 255, 0.1); /* Very light, semi-transparent white */
  backdrop-filter: blur(15px) saturate(150%); /* Key for the frosted glass effect, adjust blur amount */
  -webkit-backdrop-filter: blur(15px) saturate(150%); /* For Safari */

  color: #f0f0f0; /* Adjust text color for readability on the new background */
  
  padding: 25px 30px;
  border-radius: 12px; /* Slightly larger radius can look nice */
  
  /* Subtle Border to define edges */
  border: 1px solid rgba(255, 255, 255, 0.18);

  width: 90%;
  max-width: 380px;
  
  /* Softer Shadow */
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.17); /* Softer, more diffused shadow */
  /* Or a simpler one: box-shadow: 0 4px 15px rgba(0,0,0,0.2); */

  position: relative;
  text-align: left;
  /* overflow: hidden; /* Can help if content inside tries to break border-radius with its own bg */
}

.close-modal-btn {
  color: rgba(255, 255, 255, 0.7); /* Adjust for new background */
  position: absolute;
  top: 12px; /* Adjust position slightly if needed */
  right: 15px;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
  transition: color 0.2s ease;
}
.close-modal-btn:hover,
.close-modal-btn:focus {
  color: white;
}

.modal-content h4 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 20px;
  font-weight: 600;
  text-align: center;
  color: #ffffff; /* Ensure title is clearly visible */
}

#modalPlaylistList {
  max-height: 200px;
  overflow-y: auto;
  margin-top: 10px;
  padding-right: 5px; /* Space for scrollbar if items are wide */
}

#modalPlaylistList .modal-playlist-item {
  padding: 10px 12px;
  cursor: pointer;
  border-radius: 6px; /* Match overall aesthetic */
  margin-bottom: 6px;
  font-size: 15px;
  color: #e0e0e0; /* Slightly softer than pure white */
  transition: background-color 0.2s ease, color 0.2s ease;
  /* Optional: add a very subtle divider if needed, or rely on hover */
  /* border-bottom: 1px solid rgba(255,255,255,0.05); */
}
/* #modalPlaylistList .modal-playlist-item:last-child {
  border-bottom: none; 
} */

#modalPlaylistList .modal-playlist-item:hover {
  background-color: rgba(255,255,255,0.15); /* Slightly lighter hover */
  color: #ffffff;
}

/* Scrollbar for modal playlist list - keep it subtle */
#modalPlaylistList::-webkit-scrollbar { width: 6px; }
#modalPlaylistList::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 3px; }
#modalPlaylistList::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.25); border-radius: 3px; } /* Slightly lighter thumb */
#modalPlaylistList::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.4); }
#modalPlaylistList {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.25) rgba(255, 255, 255, 0.05);
}

/* Styles for action buttons within the general modal */
#generalModalActions {
  margin-top: 20px;
  display: flex; /* For button layout */
  justify-content: center; /* Center buttons, or space-around/space-between */
  gap: 15px; /* Space between buttons */
}

.modal-button {
  padding: 10px 20px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  font-size: 15px;
  font-weight: 500;
  transition: background-color 0.2s ease, opacity 0.2s ease;
  min-width: 80px; /* Minimum width for buttons */
}

.modal-button.primary { /* For primary actions like "Delete", "Confirm" */
  background-color: #e53e3e; /* Example: Red for delete */
  color: white;
}
.modal-button.primary:hover {
  background-color: #c53030;
}

.modal-button.success { /* NEW: For positive actions like "Create", "Save" */
  background-color: #38A169; /* Green (Tailwind's green-600) */
  color: white;
}
.modal-button.success:hover {
  background-color: #2F855A; /* Darker Green (Tailwind's green-700) */
}

.modal-button.secondary { /* For secondary actions like "Cancel", "OK" for info */
  background-color: rgba(255, 255, 255, 0.15);
  color: #f0f0f0;
  border: 1px solid rgba(255, 255, 255, 0.2);
}
.modal-button.secondary:hover {
  background-color: rgba(255, 255, 255, 0.25);
}

/* Styles for input fields within modals */
.modal-input {
  width: 100%;
  padding: 10px 12px;
  background-color: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #f0f0f0;
  border-radius: 6px;
  font-size: 15px;
  box-sizing: border-box; /* Ensure padding and border don't add to width */
}
.modal-input:focus {
  outline: none;
  border-color: rgba(255, 255, 255, 0.4);
  background-color: rgba(255, 255, 255, 0.1);
}

/* Specific styling for the create playlist modal actions if needed,
   otherwise the general #generalModalActions styling might be sufficient if adapted.
   The HTML above used text-align: right directly on #createPlaylistModalActions.
*/
#createPlaylistModalActions {
  margin-top: 20px;
  display: flex;
  justify-content: flex-end; /* Align buttons to the right */
  gap: 10px;
}

.form-group label { /* Style for labels above inputs */
    color: #ccc; /* Lighter than main text */
}

/* Toast Notifications (add towards the end of all.css) */
.toast-container {
  position: fixed;
  bottom: 20px; /* Adjust as needed, consider lyrics toggle */
  left: 50%;
  transform: translateX(-50%);
  z-index: 2000; /* Above most other elements */
  display: flex;
  flex-direction: column-reverse; /* New toasts appear above older ones if multiple */
  align-items: center;
  gap: 10px;
  pointer-events: none; /* Allow clicks to pass through the container itself */
}

.toast-message {
  /* Glassmorphism */
  background-color: rgba(50, 50, 50, 0.6); /* Darker semi-transparent for contrast */
  backdrop-filter: blur(10px) saturate(150%);
  -webkit-backdrop-filter: blur(10px) saturate(150%);
  color: #f0f0f0;
  padding: 12px 20px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
  font-size: 14px;
  font-weight: 500;
  text-align: center;
  max-width: 80vw; /* Prevent very wide toasts on large screens */

  opacity: 0;
  transform: translateY(30px) scale(0.95); /* Initial state for animation: off-screen and slightly smaller */
  transition: opacity 0.3s ease-out, transform 0.3s ease-out;
  pointer-events: auto; /* Toasts themselves are clickable/interactive if needed in future */
}

.toast-message.show {
  opacity: 1;
  transform: translateY(0) scale(1);
}


/* Responsive adjustments */
@media (max-width: 960px) { /* Adjust breakpoint as needed */
  .app-container {
    flex-direction: column;
    height: auto; /* Allow app container to grow if content is very tall */
    min-height: 100vh;
  }
.main-content {
  max-width: 100%; /* Allow main content to use full width */
  order: 1; /* Player first */
}
.playlist-sidebar {
  width: 100%;
  max-width: 570px; /* Or match player width */
  margin: 20px auto 0 auto; /* Center sidebar below player */
  order: 2; /* Playlist below player */
  height: auto; /* Auto height */
  max-height: 40vh; /* Limit height to prevent excessive scrolling */
}
.player {
  width: 100%; /* Make player responsive */
  max-width: 570px; /* Max width for player */
}
.search-container {
    max-width: 570px; /* Match player width */
}
.search-results {
    max-width: 570px; /* Match player width */
}



}

@media (max-width: 600px) {
  .player {
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 20px;
  }
  .album-art {
      flex-basis: auto; /* Allow it to shrink if needed */
      width: 180px;
      height: 180px;
  }
  .info {
      align-items: center; /* Center info content */
      text-align: center;
  }
  .track-title {
      font-size: 28px;
  }
  .artist {
      font-size: 18px;
      margin-bottom: 30px;
  }
  .lyrics-info {
      align-items: center;
      text-align: center;
  }
  .lyrics-title {
      font-size: 26px;
  }
  .lyrics-artist {
      font-size: 16px;
  }
}
```

js/bg.js
```js
function applyColors(color) {
    if (!color || !Array.isArray(color) || color.length < 3) {
      return;
    }
  
    targetColor = { r: color[0], g: color[1], b: color[2] };
  
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
  
    applyAnimation();
  }
  
  function applyAnimation() {
    const dr = (targetColor.r - currentColor.r) * 0.1;
    const dg = (targetColor.g - currentColor.g) * 0.1;
    const db = (targetColor.b - currentColor.b) * 0.1;
  
    currentColor.r += dr;
    currentColor.g += dg;
    currentColor.b += db;
  
    const r = Math.round(currentColor.r);
    const g = Math.round(currentColor.g);
    const b = Math.round(currentColor.b);
  
    const darkenAmount = 30;
    const endR = Math.max(0, r - darkenAmount);
    const endG = Math.max(0, g - darkenAmount);
    const endB = Math.max(0, b - darkenAmount);
  
    document.documentElement.style.setProperty(
      "--bg-start",
      `rgb(${r}, ${g}, ${b})`
    );
    document.documentElement.style.setProperty(
      "--bg-end",
      `rgb(${endR}, ${endG}, ${endB})`
    );
  
    const tolerance = 0.5;
    if (
      Math.abs(targetColor.r - currentColor.r) > tolerance ||
      Math.abs(targetColor.g - currentColor.g) > tolerance ||
      Math.abs(targetColor.b - currentColor.b) > tolerance
    ) {
      animationId = requestAnimationFrame(applyAnimation);
    } else {
      currentColor = { ...targetColor };
    }
  }
  
```

js/endpoints.js
```js
// NB: Each YT Key gives 100 req/day (dev mode)

//const YT_KEY = "AIzaSyDyS3-fRybg6VCIAoRzAt47PNnEVMOsODs";
//const YT_KEY = "AIzaSyAgfWDE5zoRPZWx_BDuCQYFwIIdPOg1M0E";
const YT_KEYS = [
    'AIzaSyDyS3-fRybg6VCIAoRzAt47PNnEVMOsODs', // OGs
    'AIzaSyAgfWDE5zoRPZWx_BDuCQYFwIIdPOg1M0E' // @gmail
];

const RAPIDAPI_HOST = 'youtube-v3-alternative.p.rapidapi.com';
// https://rapidapi.com/ytdlfree/api/youtube-v3-alternative

// NB: Each Rapid Key gives 500 req/month

//const RAPIDAPI_KEY = '97ffa9c073mshdf976f56ef861b2p1294d8jsnb5302f45e8d8';
//const RAPIDAPI_KEY = '77c80e02acmshceeac2836195444p1415aejsn1ab385b54e75';
const RAPIDAPI_KEYS = [
    '14702a52c6msh8318e1e2125f434p11da50jsnab4512ddcf3f', // MK
    '97ffa9c073mshdf976f56ef861b2p1294d8jsnb5302f45e8d8', // @gmail
    '77c80e02acmshceeac2836195444p1415aejsn1ab385b54e75', // me@hydrovolter
    '742640eb4emsh8a1fff59e07f4b1p190938jsnd56db90aab6a', // contact@hydrovolter
    '5ff8bd8475mshe5e6e79c491683ap16d313jsn6d3c2370ff4b' // dmca@hydrovolter
];




const LYRIC_EP = "https://api.lyrics.ovh/v1/";
const YT_EP = "https://www.googleapis.com/youtube/v3/search?part=snippet&q=";
//const YT_EP = "https://api.hydrovolter.workers.dev/music/?part=snippet&q=";
const SEARCH_EP = "https://itunes.apple.com/search?term=";

```

js/getYT.js
```js
// --- Global Counters and API Keys (ensure these are defined globally) ---
// ... (Your existing global definitions for YT_EP, RAPIDAPI_HOST, YT_KEYS, RAPIDAPI_KEYS) ...

let apiCallCounter = 0; // Cycles between Google API and RapidAPI
let rapidApiKeyCounter = 0; // Tracks the current RapidAPI key index
let googleApiKeyCounter = 0; // Tracks the current Google API key index

// GOOGLE API
async function getYTGoogleAPI(query) {
    // Keep track of the starting key index for this attempt to prevent infinite loops
    const initialKeyIndex = googleApiKeyCounter % YT_KEYS.length;
    let attempts = 0;
    let foundVideo = false;
    let lastError = null;

    // Loop through all available Google API keys
    while (attempts < YT_KEYS.length && !foundVideo) {
        const currentKeyIndex = googleApiKeyCounter % YT_KEYS.length;
        const currentGoogleAPIKey = YT_KEYS[currentKeyIndex];

        console.log(`Google API: Attempting with key index ${currentKeyIndex} (Attempt ${attempts + 1}/${YT_KEYS.length})`);

        const url = `${YT_EP}${encodeURIComponent(
            query
        )}&type=video&videoEmbeddable=true&key=${currentGoogleAPIKey}&maxResults=1`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Google API HTTP error! status: ${response.status} for key index ${currentKeyIndex}`);
            }
            const data = await response.json();

            console.log("Youtube results (Google API):", data);
            if (data.items && data.items.length > 0) {
                const videoId = data.items[0].id.videoId;
                loadVid(videoId);
                foundVideo = true; // Mark as successful
                // No need to increment googleApiKeyCounter here; it will naturally advance on next getYTGoogleAPI call
                // because of the final increment after the loop.
            } else {
                lastError = new Error(`No YouTube results found (Google API) for key index ${currentKeyIndex}`);
                console.error(lastError.message);
            }
        } catch (error) {
            lastError = error;
            console.error(`Error searching YouTube (Google API) with key index ${currentKeyIndex}:`, error);
        }

        if (!foundVideo) {
            // Only increment to try the next key if the current one didn't find a video
            googleApiKeyCounter++;
            attempts++;
        }
    }

    if (foundVideo) {
        return Promise.resolve(true); // Resolve if a video was found
    } else {
        // If no video was found after all key attempts
        return Promise.reject(lastError || new Error("Google API exhausted all keys without success."));
    }
}

// youtube-v3-alternative RAPIDAPI
async function getYTRapidAPI(query) {
    const initialKeyIndex = rapidApiKeyCounter % RAPIDAPI_KEYS.length;
    let attempts = 0;
    let foundVideo = false;
    let lastError = null;

    // Loop through all available RapidAPI keys
    while (attempts < RAPIDAPI_KEYS.length && !foundVideo) {
        const currentKeyIndex = rapidApiKeyCounter % RAPIDAPI_KEYS.length;
        const currentRapidAPIKey = RAPIDAPI_KEYS[currentKeyIndex];

        console.log(`RapidAPI: Attempting with key index ${currentKeyIndex} (Attempt ${attempts + 1}/${RAPIDAPI_KEYS.length})`);

        const url = `https://${RAPIDAPI_HOST}/search?query=${encodeURIComponent(
            query
        )}&geo=US&lang=en`;

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'x-rapidapi-host': RAPIDAPI_HOST,
                    'x-rapidapi-key': currentRapidAPIKey,
                },
            });
            if (!response.ok) {
                throw new Error(`RapidAPI HTTP error! status: ${response.status} for key index ${currentKeyIndex}`);
            }
            const data = await response.json();

            console.log("RapidAPI Youtube results:", data);
            if (data && data.data && data.data.length > 0) {
                const videoId = data.data[0].videoId;
                if (videoId) {
                    loadVid(videoId);
                    foundVideo = true; // Mark as successful
                    // No need to increment rapidApiKeyCounter here; it will naturally advance on next getYTRapidAPI call
                } else {
                    lastError = new Error(`Could not extract video ID from RapidAPI results for key index ${currentKeyIndex}`);
                    console.error(lastError.message, data.data[0]);
                }
            } else {
                lastError = new Error(`No RapidAPI YouTube results found or unexpected data structure for key index ${currentKeyIndex}`);
                console.error(lastError.message);
            }
        } catch (error) {
            lastError = error;
            console.error(`Error searching RapidAPI YouTube with key index ${currentKeyIndex}:`, error);
        }

        if (!foundVideo) {
            // Only increment to try the next key if the current one didn't find a video
            rapidApiKeyCounter++;
            attempts++;
        }
    }

    if (foundVideo) {
        return Promise.resolve(true); // Resolve if a video was found
    } else {
        // If no video was found after all key attempts
        return Promise.reject(lastError || new Error("RapidAPI exhausted all keys without success."));
    }
}


// --- Main getYT function with fallback logic (remains largely the same) ---
async function getYT(query) {
    let searchSuccessful = false;

    // Determine the primary API for this call
    const primaryApiIsGoogle = (apiCallCounter % 2 === 0);

    if (primaryApiIsGoogle) {
        console.log("Attempting with Google API (Primary)...");
        try {
            await getYTGoogleAPI(query); // This will now try all Google keys internally
            searchSuccessful = true; // Primary attempt succeeded
        } catch (error) {
            console.warn("Google API failed after trying all its keys. Attempting with RapidAPI (Fallback)...", error);
            try {
                await getYTRapidAPI(query); // This will now try all RapidAPI keys internally
                searchSuccessful = true; // Fallback attempt succeeded
            } catch (fallbackError) {
                console.error("Both Google API (all keys) and RapidAPI (all keys) failed:", fallbackError);
            }
        }
    } else { // Primary API is RapidAPI
        console.log("Attempting with RapidAPI (Primary)...");
        try {
            await getYTRapidAPI(query); // This will now try all RapidAPI keys internally
            searchSuccessful = true; // Primary attempt succeeded
        } catch (error) {
            console.warn("RapidAPI failed after trying all its keys. Attempting with Google API (Fallback)...", error);
            try {
                await getYTGoogleAPI(query); // This will now try all Google keys internally
                searchSuccessful = true; // Fallback attempt succeeded
            } catch (fallbackError) {
                console.error("Both RapidAPI (all keys) and Google API (all keys) failed:", fallbackError);
            }
        }
    }

    // Only increment the main API counter if at least one API call was successful
    if (searchSuccessful) {
        apiCallCounter++;
    } else {
        console.warn("No video loaded after all attempts across both APIs and all their keys. Next getYT call will re-attempt the same primary API.");
    }
}
```

js/history.js
```js
// js/history.js

const RECENT_SEARCHES_KEY = 'musicPlayer_recentSearches';
const MAX_RECENT_SEARCHES = 3;

/**
 * Retrieves the list of recent search queries from localStorage.
 * @returns {string[]} An array of recent search queries.
 */
function getRecentSearches() {
    const storedSearches = localStorage.getItem(RECENT_SEARCHES_KEY);
    return storedSearches ? JSON.parse(storedSearches) : [];
}

/**
 * Adds a search query to the recent searches list.
 * Moves existing query to the top if already present.
 * Limits the list to MAX_RECENT_SEARCHES.
 * @param {string} query The search query to add.
 */
function addRecentSearch(query) {
    if (!query || typeof query !== 'string' || query.trim() === "") return;
    query = query.trim(); // Normalize

    let searches = getRecentSearches();
    // Remove the query if it already exists, to move it to the top (most recent)
    searches = searches.filter(s => s.toLowerCase() !== query.toLowerCase());
    // Add the new query to the beginning
    searches.unshift(query);
    // Limit the number of recent searches
    if (searches.length > MAX_RECENT_SEARCHES) {
        searches = searches.slice(0, MAX_RECENT_SEARCHES);
    }
    localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));
}

/**
 * Removes a specific search query from the recent searches list.
 * @param {string} queryToRemove The search query to remove.
 */
function removeRecentSearch(queryToRemove) {
    if (!queryToRemove || typeof queryToRemove !== 'string' || queryToRemove.trim() === "") return;
    queryToRemove = queryToRemove.trim();

    let searches = getRecentSearches();
    searches = searches.filter(s => s.toLowerCase() !== queryToRemove.toLowerCase());
    localStorage.setItem(RECENT_SEARCHES_KEY, JSON.stringify(searches));

    // This function will be called from search.js, which can then decide to re-render
    // For example, after removing, if search input is focused and empty, search.js will call displayRecentSearches()
}
```

js/init.js
```js
// js/init.js

const searchInput = document.getElementById("searchInput");
const searchResults = document.getElementById("searchResults");
const trackTitle = document.getElementById("trackTitle");
const artistName = document.getElementById("artistName");
const albumCover = document.getElementById("albumCover");
const playPauseBtn = document.getElementById("playPause");
const volumeBtn = document.getElementById("volumeBtn");
const seekBar = document.getElementById("seekbar");
const progressBar = document.getElementById("progress");
const currentTimeSpan = document.getElementById("currentTime");
const remainingTimeSpan = document.getElementById("remainingTime");
const lyricsToggle = document.getElementById("lyricsToggle");
const lyricsIcon = lyricsToggle.querySelector("i");
const playerInfo = document.getElementById("playerInfo");
const lyricsInfo = document.getElementById("lyricsInfo");
const lyricsSongTitle = document.getElementById("lyricsSongTitle");
const lyricsArtistName = document.getElementById("lyricsArtistName");
const lyricsContent = document.getElementById("lyricsContent");
const loopBtn = document.getElementById("loopBtn");
const shuffleBtn = document.getElementById("shuffleBtn");


let showingLyrics = false;
let isMuted = false;
let loopState = 'none';
let isShuffleActive = false;

let player; // YouTube player instance
let isPlaying = false; // Player's playing state
let isDragging = false; // Seekbar dragging state
let searchTimeout;

// currentTrack will store details of the song currently loaded OR playing
let currentTrack = {
  id: null,       // Unique ID (e.g., iTunes trackId, crucial for liking)
  title: "Not Playing",
  artist: "Not Playing",
  artwork: "img/empty_art.png",    // URL to 100x100 artwork (for playlists, like button context)
  artworkLarge: "img/empty_art.png" // URL to 600x600 artwork (for main player display)
};

const colorThief = new ColorThief();

let currentColor = { r: 115, g: 98, b: 86 }; // Default bg color start
let targetColor = { r: 115, g: 98, b: 86 };  // Default bg color target
let animationId = null;

// --- Playlist System Variables ---
const LIKED_SONGS_PLAYLIST_ID = 'liked_songs';
const USER_PLAYLISTS_STORAGE_KEY = 'musicPlayer_userPlaylists';
const LIKED_PLAYLIST_STORAGE_KEY = 'musicPlayer_likedSongsPlaylist'; // Keep this for liked songs

let likedPlaylist = []; // Holds {id, title, artist, artwork} for liked songs
let userPlaylists = []; // Holds {id, name, songs: [...]} for user-created playlists

let currentPlayingPlaylistId = null; // ID of the playing playlist (e.g., 'liked_songs', or a user playlist ID)
let currentPlaylistTrackIndex = -1;   // Index in the currentPlayingPlaylistId's song array

let currentSidebarView = 'all_playlists'; // 'all_playlists' or 'single_playlist_view'
let selectedPlaylistToViewId = null;  // ID of the playlist being viewed in the sidebar (not necessarily playing)

// DOM Elements for playlist system (to be fetched in playlist.js's initializePlaylistSystem)
let playlistDisplayAreaElement;
let sidebarTitleElement;
let backToPlaylistsBtnElement;
let createNewPlaylistBtnElement;
let addToPlaylistBtnElement;
let addToPlaylistModalElement;
let modalPlaylistListElement;
let closeModalAddToPlaylistBtnElement;
let likeBtnElement; // Will be grabbed in playlist.js
let prevBtnElement; // Will be grabbed in playlist.js
let nextBtnElement; // Will be grabbed in playlist.js

// DOM Elements for General Modal
let generalModalElement;
let generalModalTitleElement;
let generalModalMessageElement;
let generalModalActionsElement;
let closeGeneralModalBtnElement;

// DOM Elements for Create Playlist Modal
let createPlaylistModalElement;
let createPlaylistModalTitleElement; // Though title is static here, good practice
let newPlaylistNameInputElement;
let confirmCreatePlaylistBtnElement;
let cancelCreatePlaylistBtnElement;
let closeCreatePlaylistModalBtnElement;

// DOM Elements for Rename Playlist Modal
let renamePlaylistModalElement;
let renamePlaylistModalTitleElement; // If you want to include the old name in the title
let renamePlaylistNameInputElement;
let confirmRenamePlaylistBtnElement;
let cancelRenamePlaylistBtnElement;
let closeRenamePlaylistModalBtnElement;
let playlistIdToRename = null; // To store the ID of the playlist being renamed
```

js/lyrics.js
```js
lyricsToggle.addEventListener("click", function () {
    showingLyrics = !showingLyrics;
  
    if (showingLyrics) {
      playerInfo.style.display = "none";
      lyricsInfo.style.display = "flex";
      fetchLyrics(currentTrack.artist, currentTrack.title);
      lyricsIcon.classList.remove("icon-lyrics");
      lyricsIcon.classList.add("icon-lyrics-on");
    } else {
      playerInfo.style.display = "flex";
      lyricsInfo.style.display = "none";
      lyricsIcon.classList.remove("icon-lyrics-on");
      lyricsIcon.classList.add("icon-lyrics");
    }
    
  });
  
  function fetchLyrics(artist, title) {
    lyricsSongTitle.textContent = title;
    lyricsArtistName.textContent = artist;
    lyricsContent.textContent = "Loading lyrics...";
  
    const cleanArtist = encodeURIComponent(artist.trim());
    const cleanTitle = encodeURIComponent(title.trim());
  
    fetch(`${LYRIC_EP}${cleanArtist}/${cleanTitle}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error("Lyrics not found");
        }
        return response.json();
      })
      .then((data) => {
        if (data.lyrics) {
          const normalizedLyrics = data.lyrics.replace(/\n{3,}/g, "\n\n");
          const formattedLyrics = normalizedLyrics.replace(/\n/g, "<br>");
          lyricsContent.innerHTML = formattedLyrics;
        } else {
          lyricsContent.textContent = "No lyrics available.";
        }
      })
      .catch((error) => {
        console.error("Error fetching lyrics:", error);
        lyricsContent.textContent = "No lyrics available.";
      });
  }
  ```

js/modals.js
```js
// Callbacks for confirm/cancel actions
let generalModalConfirmCallback = null; // Not strictly needed if callbacks are passed directly to buttons
let generalModalCancelCallback = null;  // Same as above

function initializeModals() {
    // Initialize General Modal Elements
    generalModalElement = document.getElementById('generalModal');
    generalModalTitleElement = document.getElementById('generalModalTitle');
    generalModalMessageElement = document.getElementById('generalModalMessage');
    generalModalActionsElement = document.getElementById('generalModalActions');
    closeGeneralModalBtnElement = document.getElementById('closeGeneralModal');

    if (!generalModalElement || !generalModalTitleElement || !generalModalMessageElement ||
        !generalModalActionsElement || !closeGeneralModalBtnElement) {
        console.error("General modal DOM elements not found. Modal functionality will be limited.");
        return; // Or handle gracefully
    }

    closeGeneralModalBtnElement.addEventListener('click', closeGeneralModal);
    generalModalElement.addEventListener('click', (event) => {
        // Close if clicked on the overlay (background)
        if (event.target === generalModalElement) {
            closeGeneralModal();
        }
    });
    console.log("General Modal system initialized.");


    // Initialize Create Playlist Modal Elements
    createPlaylistModalElement = document.getElementById('createPlaylistModal');
    // createPlaylistModalTitleElement = document.getElementById('createPlaylistModalTitle'); // If title is dynamic
    newPlaylistNameInputElement = document.getElementById('newPlaylistNameInput');
    confirmCreatePlaylistBtnElement = document.getElementById('confirmCreatePlaylistBtn');
    cancelCreatePlaylistBtnElement = document.getElementById('cancelCreatePlaylistBtn');
    closeCreatePlaylistModalBtnElement = document.getElementById('closeCreatePlaylistModal');

    if (!createPlaylistModalElement || !newPlaylistNameInputElement || !confirmCreatePlaylistBtnElement ||
        !cancelCreatePlaylistBtnElement || !closeCreatePlaylistModalBtnElement) {
        console.error("Create Playlist modal DOM elements not found. This functionality will be limited.");
    } else {
        closeCreatePlaylistModalBtnElement.addEventListener('click', closeCreatePlaylistModal);
        cancelCreatePlaylistBtnElement.addEventListener('click', closeCreatePlaylistModal);
        confirmCreatePlaylistBtnElement.addEventListener('click', handleConfirmCreatePlaylist);
        createPlaylistModalElement.addEventListener('click', (event) => {
            if (event.target === createPlaylistModalElement) {
                closeCreatePlaylistModal();
            }
        });
        // Allow 'Enter' key in input field to submit
        newPlaylistNameInputElement.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission if it were in a form
                handleConfirmCreatePlaylist();
            }
        });
        console.log("Create Playlist Modal system initialized.");
    }

    // Initialize Rename Playlist Modal Elements
    renamePlaylistModalElement = document.getElementById('renamePlaylistModal');
    renamePlaylistModalTitleElement = document.getElementById('renamePlaylistModalTitle'); // Get the title element
    renamePlaylistNameInputElement = document.getElementById('renamePlaylistNameInput');
    confirmRenamePlaylistBtnElement = document.getElementById('confirmRenamePlaylistBtn');
    cancelRenamePlaylistBtnElement = document.getElementById('cancelRenamePlaylistBtn');
    closeRenamePlaylistModalBtnElement = document.getElementById('closeRenamePlaylistModal');

    if (!renamePlaylistModalElement || !renamePlaylistNameInputElement || !confirmRenamePlaylistBtnElement ||
        !cancelRenamePlaylistBtnElement || !closeRenamePlaylistModalBtnElement || !renamePlaylistModalTitleElement) {
        console.error("Rename Playlist modal DOM elements not found. This functionality will be limited.");
    } else {
        closeRenamePlaylistModalBtnElement.addEventListener('click', closeRenamePlaylistModal);
        cancelRenamePlaylistBtnElement.addEventListener('click', closeRenamePlaylistModal);
        confirmRenamePlaylistBtnElement.addEventListener('click', handleConfirmRenamePlaylist);
        renamePlaylistModalElement.addEventListener('click', (event) => {
            if (event.target === renamePlaylistModalElement) {
                closeRenamePlaylistModal();
            }
        });
        renamePlaylistNameInputElement.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleConfirmRenamePlaylist();
            }
        });
        console.log("Rename Playlist Modal system initialized.");
    }
}

function showGeneralModal(title, message, buttonsConfig = []) {
    // buttonsConfig example:
    // [
    //   { text: 'OK', class: 'secondary', callback: () => console.log('OK clicked') },
    //   { text: 'Delete', class: 'primary', callback: handleDeleteFunction }
    // ]
    if (!generalModalElement || !generalModalTitleElement || !generalModalMessageElement || !generalModalActionsElement) {
        console.error("Cannot show general modal: elements not initialized.");
        // Fallback to alert if modal elements aren't ready (though they should be if init is called)
        alert(`${title}\n${message.replace(/<br\s*\/?>/gi, "\n").replace(/<strong>|<\/strong>/gi, "")}`);
        return;
    }

    generalModalTitleElement.textContent = title;
    generalModalMessageElement.innerHTML = message; // Use innerHTML if message might contain simple HTML like <br>, <strong>
    generalModalActionsElement.innerHTML = ''; // Clear previous buttons

    if (buttonsConfig.length === 0) {
        // Default OK button if no buttons are specified (for simple alerts)
        const okButton = document.createElement('button');
        okButton.textContent = 'OK';
        okButton.className = 'modal-button secondary'; // Assumes .modal-button and .secondary are globally styled
        okButton.onclick = closeGeneralModal;
        generalModalActionsElement.appendChild(okButton);
    } else {
        buttonsConfig.forEach(btnConfig => {
            const button = document.createElement('button');
            button.textContent = btnConfig.text;
            button.className = `modal-button ${btnConfig.class || 'secondary'}`;
            button.onclick = () => {
                closeGeneralModal(); // Always close modal on button click
                if (btnConfig.callback && typeof btnConfig.callback === 'function') {
                    btnConfig.callback();
                }
            };
            generalModalActionsElement.appendChild(button);
        });
    }
    generalModalElement.style.display = 'flex';
}

function closeGeneralModal() {
    if (!generalModalElement) return;
    generalModalElement.style.display = 'none';
    // Callbacks are tied to buttons, so no need to reset module-level generalModalConfirmCallback here
}

function openCreatePlaylistModal() {
    if (!createPlaylistModalElement || !newPlaylistNameInputElement) return;
    newPlaylistNameInputElement.value = "My Playlist " + (typeof userPlaylists !== 'undefined' ? userPlaylists.length + 1 : 1); // Suggest a name
    createPlaylistModalElement.style.display = 'flex';
    newPlaylistNameInputElement.focus(); // Focus on the input field
    newPlaylistNameInputElement.select(); // Select the suggested text
}

function closeCreatePlaylistModal() {
    if (!createPlaylistModalElement) return;
    createPlaylistModalElement.style.display = 'none';
    if(newPlaylistNameInputElement) newPlaylistNameInputElement.value = ''; // Clear input
}

function handleConfirmCreatePlaylist() {
    if (!newPlaylistNameInputElement) return;
    const playlistName = newPlaylistNameInputElement.value.trim();

    if (playlistName) {
        // Call the actual createPlaylist function (which should be in playlist.js)
        if (typeof createPlaylist === 'function') { // createPlaylist is from playlist.js
            createPlaylist(playlistName);
            if (typeof renderAllPlaylistsView === 'function') { // from playlist.js
                 renderAllPlaylistsView(); // Refresh the sidebar
            }
            closeCreatePlaylistModal();
        } else {
            console.error("createPlaylist function not found.");
            // Fallback to an alert if something is wrong with function availability
            showGeneralModal("Error", "Could not create playlist. Functionality missing.");
        }
    } else {
        // Use the general modal to show an error if the name is empty
        if (typeof showGeneralModal === 'function') {
            showGeneralModal("Invalid Name", "Playlist name cannot be empty.");
        } else {
            alert("Playlist name cannot be empty."); // Fallback
        }
        // Optionally, re-focus the input: newPlaylistNameInputElement.focus();
    }
}

function openRenamePlaylistModal(currentPlaylistId, currentName) {
    if (!renamePlaylistModalElement || !renamePlaylistNameInputElement || !renamePlaylistModalTitleElement) return;

    playlistIdToRename = currentPlaylistId; // Store the ID
    renamePlaylistModalTitleElement.textContent = `Rename "${escapeModalHtml(currentName)}"`; // Set dynamic title
    renamePlaylistNameInputElement.value = currentName; // Pre-fill with current name
    renamePlaylistModalElement.style.display = 'flex';
    renamePlaylistNameInputElement.focus();
    renamePlaylistNameInputElement.select();
}

function closeRenamePlaylistModal() {
    if (!renamePlaylistModalElement) return;
    renamePlaylistModalElement.style.display = 'none';
    if(renamePlaylistNameInputElement) renamePlaylistNameInputElement.value = '';
    playlistIdToRename = null; // Clear stored ID
}

function handleConfirmRenamePlaylist() {
    if (!renamePlaylistNameInputElement || !playlistIdToRename) return;

    const newPlaylistName = renamePlaylistNameInputElement.value.trim();
    const oldPlaylistData = typeof getPlaylistById === 'function' ? getPlaylistById(playlistIdToRename) : null; // getPlaylistById from playlist.js
    const oldName = oldPlaylistData ? oldPlaylistData.name : "";


    if (newPlaylistName && newPlaylistName !== oldName) {
        // Call the actual renamePlaylist function (which should be in playlist.js)
        if (typeof renamePlaylist === 'function') { // renamePlaylist is from playlist.js
            renamePlaylist(playlistIdToRename, newPlaylistName);
            // renderAllPlaylistsView() or renderSinglePlaylistView() will be called by renamePlaylist
            closeRenamePlaylistModal();
        } else {
            console.error("renamePlaylist function not found.");
            showGeneralModal("Error", "Could not rename playlist. Functionality missing.");
        }
    } else if (!newPlaylistName) {
        showGeneralModal("Invalid Name", "Playlist name cannot be empty.");
        // Optionally, re-focus: renamePlaylistNameInputElement.focus();
    } else { // Name is the same, or something else went wrong
        closeRenamePlaylistModal(); // Just close if name hasn't changed
    }
}





// Helper function for escaping HTML (can live here or in a general utils.js)
// Make sure this is accessible if other files need it, or they have their own.
function escapeModalHtml(unsafe) {
    if (typeof unsafe !== 'string') {
        return unsafe === null || typeof unsafe === 'undefined' ? '' : String(unsafe);
    }
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
}
```

js/play.js
```js
// js/play.js

// artworkUrl is expected to be the 100x100 version
// trackId should be a string if provided
function playSong(title, artist, artworkUrl, trackId = null) {
  // Generate a fallback ID if trackId is not provided (less reliable for liking/uniqueness)
  const newTrackId = trackId ? trackId.toString() : `${title}-${artist}`.toLowerCase().replace(/\s+/g, '-');

  currentTrack = {
      id: newTrackId,
      title: title,
      artist: artist,
      artwork: artworkUrl, // Store the 100x100
      artworkLarge: artworkUrl ? artworkUrl.replace("100x100", "600x600") : 'img/empty_art.png'
  };

  trackTitle.textContent = currentTrack.title;
  artistName.textContent = currentTrack.artist;

  lyricsSongTitle.textContent = currentTrack.title;
  lyricsArtistName.textContent = currentTrack.artist;

  if (showingLyrics) { // showingLyrics is global from init.js
      fetchLyrics(currentTrack.artist, currentTrack.title); // fetchLyrics is global from lyrics.js
  }

  albumCover.crossOrigin = "anonymous";
  albumCover.src = currentTrack.artworkLarge;

  albumCover.onload = function () {
      // Check if the source is not the default empty art before trying colorThief
      if (albumCover.src && !albumCover.src.endsWith('img/empty_art.png')) {
          try {
              const dominantColor = colorThief.getColor(albumCover); // colorThief is global
              applyColors(dominantColor); // applyColors is global from bg.js
          } catch (e) {
              console.error("Color extraction failed (onload):", e);
              applyColors([100, 100, 100]); // Fallback color
          }
      } else {
           applyColors([115, 98, 86]); // Default for empty art
      }
  };
  albumCover.onerror = function() {
      console.error("Failed to load album art:", currentTrack.artworkLarge);
      applyColors([100, 100, 100]); // Fallback color on error
      albumCover.src = 'img/empty_art.png'; // Revert to default art on error
  };

  // Update UI elements that depend on the current track
  if (typeof updateLikeButtonState === 'function') { // From playlist.js
      updateLikeButtonState();
  }
  // updatePlaylistControlsVisibility is called by playSongFromCurrentPlaylist or clearPlaylistContext
  // If playSong is called from search, clearPlaylistContext (in search.js) should have been called first.

  const searchQuery = `${currentTrack.title} - ${currentTrack.artist}`;
  getYT(searchQuery); // getYT is global from getYT.js
}

function loadVid(videoId) {
  // player is global from init.js (and player.js)
  // isMuted is global from init.js
  if (player && typeof player.loadVideoById === 'function') {
      player.loadVideoById(videoId);
      // Autoplay is handled by YouTube API or onPlayerStateChange (YT.PlayerState.CUED)

      if (isMuted && typeof player.mute === 'function') {
          player.mute();
      } else if (typeof player.unMute === 'function' && !isMuted) { // only unmute if not muted
          player.unMute();
      }
  } else {
      console.error("YouTube player not ready or loadVideoById not available.");
  }
}
```

js/playback.js
```js
function togglePlayback() {
    console.log("Toggle playback called");
    if (!player) return;
  
    if (isPlaying) {
      player.pauseVideo();
    } else {
      player.playVideo();
    }
  }
  
  function startSeek(e) {
    isDragging = true;
    seekBar.classList.add("active");
    updateSeekPosition(e);
  }
  
  function dragSeek(e) {
    if (isDragging) {
      updateSeekPosition(e);
    }
  }
  
  function endSeek() {
    if (isDragging) {
      isDragging = false;
      seekBar.classList.remove("active");
    }
  }
  
  function updateSeekPosition(e) {
    if (!player || !player.getDuration) return;
  
    const rect = seekBar.getBoundingClientRect();
    const position = (e.clientX - rect.left) / rect.width;
    const percent = Math.min(Math.max(position, 0), 1);
  
    progressBar.style.width = percent * 100 + "%";
  
    const duration = player.getDuration();
    player.seekTo(percent * duration, true);
  }
  
  function updateProgress() {
    if (!player || !player.getDuration || isDragging) return;
  
    try {
      const duration = player.getDuration() || 0;
      const currentTime = player.getCurrentTime() || 0;
      const percent = (currentTime / duration) * 100;
  
      progressBar.style.width = percent + "%";
  
      currentTimeSpan.textContent = formatTime(currentTime);
      remainingTimeSpan.textContent = "-" + formatTime(duration - currentTime);
    } catch (error) {
      console.error("Error updating progress:", error);
    }
  }
  
  function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60)
      .toString()
      .padStart(2, "0");
    return `${minutes}:${secs}`;
  }
  
```

js/player.js

```js
// js/player.js

// YouTube Iframe API setup (tag, firstScriptTag) - unchanged
const tag = document.createElement("script");
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName("script")[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

function onYouTubeIframeAPIReady() {
  player = new YT.Player("ytPlayer", { // player is global
    height: "1",
    width: "1",
    videoId: "-",
    playerVars: {
      playsinline: 1,
      controls: 0,
      enablejsapi: 1,
      modestbranding: 1,
      rel: 0,
      showinfo: 0,
      autoplay: 0,
    },
    events: {
      onReady: onPlayerReady,
      onStateChange: onPlayerStateChange,
      onError: onPlayerError
    },
  });
}

function onPlayerReady(event) {
  console.log("Player is ready");

  // playPauseBtn, volumeBtn, loopBtn are global from init.js
  // seekBar is global from init.js
  playPauseBtn.addEventListener("click", togglePlayback); // togglePlayback is global from playback.js
  volumeBtn.addEventListener("click", toggleMute);
  loopBtn.addEventListener("click", toggleLoop);
  if (shuffleBtn) shuffleBtn.addEventListener("click", toggleShuffle);

  seekBar.addEventListener("mousedown", startSeek); // startSeek from playback.js
  document.addEventListener("mousemove", dragSeek); // dragSeek from playback.js
  document.addEventListener("mouseup", endSeek);   // endSeek from playback.js

  setInterval(updateProgress, 500); // updateProgress from playback.js
  updateLoopButtonIcon(); // Initialize loop button icon based on global loopState
  updateShuffleButtonIcon();

  // Initial color logic - unchanged
  if (albumCover.complete && albumCover.src && !albumCover.src.endsWith('img/empty_art.png')) {
    try {
      const dominantColor = colorThief.getColor(albumCover);
      applyColors(dominantColor);
    } catch (e) {
      console.error("Initial color extraction failed (already complete):", e);
      applyColors([100,100,100]);
    }
  } else if (albumCover.src && albumCover.src.endsWith('img/empty_art.png')) {
    applyColors([115, 98, 86]);
  }
}

// Updates the visual state of the loop button based on global 'loopState'
function updateLoopButtonIcon() {
    if (!loopBtn) return; // loopBtn is global
    loopBtn.classList.remove('loop-active', 'loop-playlist-active');

    if (loopState === 'song') {
        loopBtn.classList.add('loop-active'); // For repeat-1.svg, green
    } else if (loopState === 'playlist') {
        loopBtn.classList.add('loop-playlist-active'); // For repeat.svg, green
    }
    // If 'none', no extra class, uses default .icon-loop style
}

// Manages cycling through loop states
function toggleLoop() {
    if (!player) return; // player is global

    // currentPlayingPlaylistId is global from init.js
    // likedPlaylist and userPlaylists are global from init.js
    const activePlaylist = getPlaylistById(currentPlayingPlaylistId); // from playlist.js
    const playlistIsEffectivelyActive = activePlaylist && activePlaylist.songs && activePlaylist.songs.length > 0;

    if (playlistIsEffectivelyActive) {
        if (loopState === 'none') loopState = 'playlist';
        else if (loopState === 'playlist') loopState = 'song';
        else loopState = 'none'; // 'song' -> 'none'
    } else { // No playlist active, or active playlist is empty
        if (loopState === 'none') loopState = 'song';
        else loopState = 'none'; // 'song' -> 'none'
    }
    console.log("Loop state changed to:", loopState, "| Playlist active for looping:", playlistIsEffectivelyActive);
    updateLoopButtonIcon();
}

function onPlayerStateChange(event) {
  console.log("Player state:", event.data, "| Loop:", loopState, "| Shuffle:", isShuffleActive, "| PlaylistID:", currentPlayingPlaylistId, "| TrackIdx:", currentPlaylistTrackIndex);

  if (event.data === YT.PlayerState.PLAYING) {
    isPlaying = true;
    playPauseBtn.classList.remove("icon-play");
    playPauseBtn.classList.add("icon-pause");
  } else if (event.data === YT.PlayerState.PAUSED) {
    isPlaying = false;
    playPauseBtn.classList.remove("icon-pause");
    playPauseBtn.classList.add("icon-play");
  } else if (event.data === YT.PlayerState.ENDED) {
    isPlaying = false;
    playPauseBtn.classList.remove("icon-pause");
    playPauseBtn.classList.add("icon-play");

    if (loopState === 'song' && player) {
      player.seekTo(0, true);
      player.playVideo();
    } else if (isShuffleActive && currentPlayingPlaylistId) { // SHUFFLE takes precedence over simple playlist next
        playNextTrackInCurrentPlaylist(); // This will use shuffle logic
    } else if (currentPlayingPlaylistId && typeof getPlaylistById === 'function' && typeof playNextTrackInCurrentPlaylist === 'function') {
        // Non-shuffled playlist logic
        const currentPlaylist = getPlaylistById(currentPlayingPlaylistId);
        if (currentPlaylist && currentPlaylist.songs && currentPlaylist.songs.length > 0) {
            const isLastTrack = currentPlaylistTrackIndex >= currentPlaylist.songs.length - 1;
            if (loopState === 'playlist') {
                playNextTrackInCurrentPlaylist();
            } else if (loopState === 'none' && !isLastTrack) {
                playNextTrackInCurrentPlaylist();
            } else {
                clearPlayerStateOnEnd();
            }
        } else {
             clearPlayerStateOnEnd();
        }
    } else {
      clearPlayerStateOnEnd();
    }
  } else if (event.data === YT.PlayerState.CUED && currentTrack && currentTrack.id !== null && !isPlaying) {
    if (player && typeof player.playVideo === 'function') player.playVideo();
  }
}

function clearPlayerStateOnEnd() {
    // progressBar, currentTimeSpan, remainingTimeSpan are global
    // formatTime is from playback.js
    if(progressBar) progressBar.style.width = "0%";
    if(currentTimeSpan) currentTimeSpan.textContent = formatTime(0);
    if (player && typeof player.getDuration === 'function') {
        const duration = player.getDuration();
        if(remainingTimeSpan) remainingTimeSpan.textContent = "-" + formatTime(duration || 0);
    } else {
        if(remainingTimeSpan) remainingTimeSpan.textContent = "-0:00";
    }
    // Optionally, clear current track display if desired, but typically not needed
    // as the UI still shows the last played song until a new one starts.
}

function onPlayerError(event) {
    console.error("YouTube Player Error:", event.data, "Song:", currentTrack ? currentTrack.title : "N/A");
    isPlaying = false;
    if (playPauseBtn) {
        playPauseBtn.classList.remove("icon-pause");
        playPauseBtn.classList.add("icon-play");
    }

    if (event.data === 101 || event.data === 150) {
      if (typeof showGeneralModal === 'function') {
          // Use escapeModalHtml from modals.js if available, or a local/global escapeHtml
          const songTitle = currentTrack ? (typeof escapeModalHtml === 'function' ? escapeModalHtml(currentTrack.title) : currentTrack.title) : "This song";
          showGeneralModal(
              "Playback Error",
              `"${songTitle}" cannot be played due to video embedding restrictions by the owner.`
          );
      } else {
          alert(`Error: "${currentTrack ? currentTrack.title : "This song"}" cannot be played due to embedding restrictions.`);
      }
  }

    if (loopState === 'playlist' && currentPlayingPlaylistId && typeof playNextTrackInCurrentPlaylist === 'function') {
        console.warn("Player error, attempting next track due to 'loop playlist' state.");
        playNextTrackInCurrentPlaylist();
    } else if (loopState === 'song' && (event.data === 101 || event.data === 150)) {
        // If looping a song that causes an embedding error, stop looping it.
        console.warn("Embedding error on a looping song. Disabling loop for this track.");
        loopState = 'none';
        updateLoopButtonIcon();
        clearPlayerStateOnEnd();
    } else if (loopState !== 'song') { // If not looping the current song (which would retry itself)
        clearPlayerStateOnEnd();
    }
    // If loopState is 'song' and it's a different error, it will try to replay and likely error again.
    // A counter for repeated errors on the same song might be useful for breaking such loops.
}

// Toggle Mute function
function toggleMute() {
  if (!player || typeof player.isMuted !== 'function') return;
  // isMuted is global
  // volumeBtn is global
  if (player.isMuted()) {
    player.unMute();
    volumeBtn.classList.remove("icon-muted");
    volumeBtn.classList.add("icon-volume");
    isMuted = false;
  } else {
    player.mute();
    volumeBtn.classList.remove("icon-volume");
    volumeBtn.classList.add("icon-muted");
    isMuted = true;
  }
}

// --- SHUFFLE FUNCTIONS ---
function updateShuffleButtonIcon() {
  if (!shuffleBtn) return;
  if (isShuffleActive) {
      shuffleBtn.classList.add('shuffle-active');
  } else {
      shuffleBtn.classList.remove('shuffle-active');
  }
}

function toggleShuffle() {
  if (!currentPlayingPlaylistId) { // Shuffle only makes sense with an active playlist
      // Optionally inform user or just do nothing
      console.warn("Shuffle toggled but no active playlist.");
      isShuffleActive = false; // Ensure it's off
      updateShuffleButtonIcon();
      return;
  }

  isShuffleActive = !isShuffleActive;
  console.log("Shuffle state changed to:", isShuffleActive);

  if (isShuffleActive) {
      // If shuffle is activated, and a playlist is playing, initialize shuffle queues
      const playlist = getPlaylistById(currentPlayingPlaylistId);
      if (playlist && playlist.songs.length > 0) {
          // Pass the currently playing track's ID so it can be handled correctly
          const currentTrackIdForShuffle = currentTrack && currentTrack.id ? currentTrack.id : null;
          initializeShuffleQueues(playlist.songs, currentTrackIdForShuffle);
      } else {
          // Playlist became empty or invalid, turn shuffle off
          isShuffleActive = false;
      }
  } else {
      // Shuffle turned off, clear queues
      shuffleUpcomingQueue = [];
      shufflePlayedQueue = [];
  }
  updateShuffleButtonIcon();
  // No need to immediately play next song; current song continues.
  // The next/prev or song end logic will use the new shuffle state.
}
```

js/playlist.js
```js
// js/playlist.js

// --- INITIALIZATION ---
function initializePlaylistSystem() {
    // Fetch DOM Elements
    playlistDisplayAreaElement = document.getElementById('playlistDisplayArea');
    sidebarTitleElement = document.getElementById('sidebarTitle');
    backToPlaylistsBtnElement = document.getElementById('backToPlaylistsBtn');
    createNewPlaylistBtnElement = document.getElementById('createNewPlaylistBtn');
    addToPlaylistBtnElement = document.getElementById('addToPlaylistBtn');
    addToPlaylistModalElement = document.getElementById('addToPlaylistModal');
    modalPlaylistListElement = document.getElementById('modalPlaylistList');
    closeModalAddToPlaylistBtnElement = document.getElementById('closeAddToPlaylistModal');
    likeBtnElement = document.getElementById('likeBtn');
    prevBtnElement = document.getElementById('prevBtn');
    nextBtnElement = document.getElementById('nextBtn');

    if (!playlistDisplayAreaElement || !sidebarTitleElement || !backToPlaylistsBtnElement ||
        !createNewPlaylistBtnElement || !addToPlaylistBtnElement || !addToPlaylistModalElement ||
        !modalPlaylistListElement || !closeModalAddToPlaylistBtnElement || !likeBtnElement ||
        !prevBtnElement || !nextBtnElement) {
        console.error("One or more playlist system DOM elements not found. Aborting.");
        return;
    }

    loadLikedPlaylist();
    loadUserPlaylists();

    renderSidebar(); // Initial render

    // Event Listeners
    likeBtnElement.addEventListener('click', toggleLikeCurrentSong);
    nextBtnElement.addEventListener('click', playNextTrackInCurrentPlaylist);
    prevBtnElement.addEventListener('click', playPreviousTrackInCurrentPlaylist);
    backToPlaylistsBtnElement.addEventListener('click', () => switchSidebarView('all_playlists'));
    createNewPlaylistBtnElement.addEventListener('click', handleCreateNewPlaylist);
    addToPlaylistBtnElement.addEventListener('click', () => { openAddToPlaylistModal(); });
    closeModalAddToPlaylistBtnElement.addEventListener('click', closeAddToPlaylistModal);

    window.addEventListener('click', (event) => {
        if (event.target === addToPlaylistModalElement) {
            closeAddToPlaylistModal();
        }
    });

    updatePlaylistControlsVisibility(); // Initial check for prev/next buttons
}

// --- DATA MANAGEMENT (LIKED SONGS) ---
function loadLikedPlaylist() {
    const stored = localStorage.getItem(LIKED_PLAYLIST_STORAGE_KEY); // From init.js
    likedPlaylist = stored ? JSON.parse(stored) : [];
}

function saveLikedPlaylist() {
    localStorage.setItem(LIKED_PLAYLIST_STORAGE_KEY, JSON.stringify(likedPlaylist));
}

function addSongToLikedPlaylist(songData) {
    if (!songData || !songData.id) {
        console.error("Cannot add to liked: missing song data or ID.", songData);
        // Optionally show an error toast here too if desired using showGeneralModal or showToast for errors
        return;
    }
    if (!likedPlaylist.find(s => s.id === songData.id)) {
        likedPlaylist.push(songData);
        saveLikedPlaylist();

        // Show success toast
        if (typeof showToast === 'function') { // Ensure showToast is available
            const message = `"${escapeHtml(songData.title)}" added to Liked Songs!`;
            showToast(message, 3000);
        }

        if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === LIKED_SONGS_PLAYLIST_ID) {
            renderSinglePlaylistView(LIKED_SONGS_PLAYLIST_ID);
        }
        updateLikeButtonState(true); // Update the like button for the current track if it's the one being liked
    } else {
        // Song is already liked - show an informational toast or general modal
        if (typeof showToast === 'function') {
            const message = `"${escapeHtml(songData.title)}" is already in Liked Songs.`;
            showToast(message, 3000);
        }
        // Or use showGeneralModal for a more prominent message:
        // showGeneralModal("Already Liked", `"${escapeHtml(songData.title)}" is already in your Liked Songs.`);
    }
}

function removeSongFromLikedPlaylist(songId) {
    const initialLength = likedPlaylist.length;
    const songBeingRemoved = likedPlaylist.find(s => s.id === songId);

    likedPlaylist = likedPlaylist.filter(s => s.id !== songId);

    if (likedPlaylist.length < initialLength) {
        saveLikedPlaylist();
        if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === LIKED_SONGS_PLAYLIST_ID) {
            renderSinglePlaylistView(LIKED_SONGS_PLAYLIST_ID);
        }
        if (currentPlayingPlaylistId === LIKED_SONGS_PLAYLIST_ID && currentTrack && currentTrack.id === songId) {
            // If the removed song was the one playing from liked playlist
            // The player.js onPlayerStateChange will handle song end. If more songs, it might play next.
            // We might need to adjust currentPlaylistTrackIndex if the removed song was *before* the current one.
            // For simplicity, let's assume if current playing is removed, player stops or plays next if available.
            // A more robust way would be to re-calculate currentPlaylistTrackIndex
            const oldPlayingSongId = currentTrack.id;
            const newIndex = likedPlaylist.findIndex(s => s.id === oldPlayingSongId);
            if (newIndex === -1 && likedPlaylist.length > 0 && currentPlaylistTrackIndex >= likedPlaylist.length) {
                // If the song was last and removed, try to point to new last or 0
                currentPlaylistTrackIndex = Math.max(0, likedPlaylist.length - 1);
            } else if (newIndex !== -1) {
                 currentPlaylistTrackIndex = newIndex; // If it was another song.
            } else if (likedPlaylist.length === 0) {
                clearPlaylistContext();
            }
        }
        if (currentTrack && currentTrack.id === songId) {
            updateLikeButtonState(false);
        }
    }
}

function isSongLiked(songId) {
    if (!songId) return false;
    return likedPlaylist.some(s => s.id === songId);
}

function toggleLikeCurrentSong() {
    if (!currentTrack || currentTrack.id == null) {
        console.warn("No current track to like/unlike, or track has no ID.");
        return;
    }
    if (isSongLiked(currentTrack.id)) {
        removeSongFromLikedPlaylist(currentTrack.id);
    } else {
        addSongToLikedPlaylist({
            id: currentTrack.id,
            title: currentTrack.title,
            artist: currentTrack.artist,
            artwork: currentTrack.artwork // Ensure this is the 100x100 artwork
        });
    }
}

function updateLikeButtonState(isLikedOverride) {
    if (!likeBtnElement) return;
    const liked = typeof isLikedOverride === 'boolean' ? isLikedOverride : (currentTrack && currentTrack.id != null ? isSongLiked(currentTrack.id) : false);

    if (liked) {
        likeBtnElement.classList.remove('icon-heart-empty');
        likeBtnElement.classList.add('icon-heart-filled');
    } else {
        likeBtnElement.classList.remove('icon-heart-filled');
        likeBtnElement.classList.add('icon-heart-empty');
    }
}

// --- DATA MANAGEMENT (USER PLAYLISTS) ---
function loadUserPlaylists() {
    const stored = localStorage.getItem(USER_PLAYLISTS_STORAGE_KEY); // From init.js
    userPlaylists = stored ? JSON.parse(stored) : [];
}

function saveUserPlaylists() {
    localStorage.setItem(USER_PLAYLISTS_STORAGE_KEY, JSON.stringify(userPlaylists));
}

function createPlaylist(name) {
    const newPlaylist = {
        id: `playlist_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: name || "New Playlist",
        songs: [],
        // artwork: 'img/empty_art.png' // Placeholder for future custom artwork
    };
    userPlaylists.push(newPlaylist);
    saveUserPlaylists();
    return newPlaylist;
}

function getPlaylistById(playlistId) {
    if (playlistId === LIKED_SONGS_PLAYLIST_ID) {
        return { id: LIKED_SONGS_PLAYLIST_ID, name: "Liked Songs", songs: [...likedPlaylist] }; // Return a copy for safety
    }
    return userPlaylists.find(p => p.id === playlistId);
}

function renamePlaylist(playlistId, newName) {
    const playlist = userPlaylists.find(p => p.id === playlistId);
    if (playlist && newName.trim() !== "") {
        playlist.name = newName.trim();
        saveUserPlaylists();
       // Always re-render the current sidebar view to reflect the name change
        if (currentSidebarView === 'all_playlists') {
            renderAllPlaylistsView();
        } else if (currentSidebarView === 'single_playlist_view') {
            if (selectedPlaylistToViewId === playlistId) {
                // If viewing the renamed playlist, update its title and re-render its content
                if (sidebarTitleElement) sidebarTitleElement.textContent = escapeHtml(playlist.name);
                renderSinglePlaylistView(playlistId); // Re-render to show updated name potentially in header or list item
            }
            // If viewing a different playlist, but the renamed one is in the overview,
            // renderAllPlaylistsView would be needed if the change should reflect there immediately
            // without navigating back. For simplicity now, it will update when navigating back.
            // A more robust solution would be a pub/sub or state management.
        }
    }
}

function deletePlaylist(playlistId) {
    const playlist = getPlaylistById(playlistId);
    if (!playlist) return;
    const playlistName = playlist.name || "this playlist";

    // Uses global showGeneralModal and escapeModalHtml (if needed within message)
    showGeneralModal(
        "Confirm Deletion",
        `Are you sure you want to delete the playlist "<strong>${escapeModalHtml(playlistName)}</strong>"?<br>This action cannot be undone.`,
        [
            {
                text: 'Delete',
                class: 'primary',
                callback: () => {
                    userPlaylists = userPlaylists.filter(p => p.id !== playlistId);
                    saveUserPlaylists();
                    if (selectedPlaylistToViewId === playlistId) switchSidebarView('all_playlists');
                    else if (currentSidebarView === 'all_playlists') renderAllPlaylistsView();
                    if (currentPlayingPlaylistId === playlistId) clearPlaylistContext();
                    console.log(`Playlist "${escapeModalHtml(playlistName)}" deleted.`);
                }
            },
            { text: 'Cancel', class: 'secondary', callback: () => console.log('Deletion cancelled.') }
        ]
    );
}

function addSongToUserPlaylist(playlistId, songData) {
    const playlist = userPlaylists.find(p => p.id === playlistId);
    if (playlist && songData && songData.id) {
        if (!playlist.songs.find(s => s.id === songData.id)) {
            playlist.songs.push(songData);
            saveUserPlaylists();

            // Show success toast
            if (typeof showToast === 'function') { // Ensure showToast is available
                const message = `"${escapeHtml(songData.title)}" added to ${escapeHtml(playlist.name)}!`;
                showToast(message, 3000);
            }

            if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
                renderSinglePlaylistView(playlistId);
            }
            console.log(`Song "${songData.title}" added to playlist "${playlist.name}"`);
        } else {
            // Song already exists in this specific user playlist
            if (typeof showToast === 'function') {
                const message = `"${escapeHtml(songData.title)}" is already in ${escapeHtml(playlist.name)}.`;
                showToast(message, 3000);
            }
            // Original showGeneralModal for this case:
            // showGeneralModal("Song Exists", `"${escapeHtml(songData.title)}" is already in the playlist "${escapeHtml(playlist.name)}".`);
            // You can choose whether a toast or a modal is better for this "already exists" message.
            // Toasts are less intrusive.
        }
    } else {
        if (!playlist) console.error("Playlist not found for ID:", playlistId);
        if (!songData || !songData.id) console.error("Invalid song data for addSongToUserPlaylist:", songData);
        // Optionally show an error toast/modal if playlist or songData is invalid
        if (typeof showToast === 'function') {
             showToast("Error: Could not add song to playlist.", 3000);
        }
    }
}

function removeSongFromUserPlaylist(playlistId, songId) {
    const playlist = userPlaylists.find(p => p.id === playlistId);
    if (playlist) {
        const initialLength = playlist.songs.length;
        playlist.songs = playlist.songs.filter(s => s.id !== songId);
        if (playlist.songs.length < initialLength) {
            saveUserPlaylists();
            if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
                renderSinglePlaylistView(playlistId);
            }
            // If the removed song was playing from this user playlist
            if (currentPlayingPlaylistId === playlistId && currentTrack && currentTrack.id === songId) {
                // More complex logic similar to removeSongFromLikedPlaylist might be needed here
                // For now, player.js will handle the ENDED state.
            }
        }
    }
}

function reorderSongInPlaylist(playlistId, oldIndex, newIndex) {
    const playlistRef = (playlistId === LIKED_SONGS_PLAYLIST_ID) ? likedPlaylist : userPlaylists.find(p => p.id === playlistId)?.songs;
    if (!playlistRef) return;

    const itemToMove = playlistRef.splice(oldIndex, 1)[0];
    playlistRef.splice(newIndex, 0, itemToMove);

    if (playlistId === LIKED_SONGS_PLAYLIST_ID) {
        saveLikedPlaylist();
    } else {
        saveUserPlaylists(); // Assumes playlistRef was a direct reference to a user playlist's songs array
    }

    if (currentPlayingPlaylistId === playlistId && currentTrack) {
        const newPlayingIndex = playlistRef.findIndex(song => song.id === currentTrack.id);
        if (newPlayingIndex !== -1) {
            currentPlaylistTrackIndex = newPlayingIndex;
        }
    }

    if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId === playlistId) {
        renderSinglePlaylistView(playlistId);
    }
}

// --- UI RENDERING ---
function renderSidebar() {
    if (!playlistDisplayAreaElement) return; // Guard if elements not ready
    if (currentSidebarView === 'all_playlists') {
        renderAllPlaylistsView();
    } else if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId) {
        renderSinglePlaylistView(selectedPlaylistToViewId);
    }
}

function switchSidebarView(view, playlistId = null) {
    currentSidebarView = view;
    selectedPlaylistToViewId = playlistId; // This is ID of playlist to *view*, not necessarily play
    renderSidebar();
}

function renderAllPlaylistsView() {
    if (!playlistDisplayAreaElement || !sidebarTitleElement || !backToPlaylistsBtnElement || !createNewPlaylistBtnElement) return;
    playlistDisplayAreaElement.innerHTML = '';
    sidebarTitleElement.textContent = "Your Playlists";
    backToPlaylistsBtnElement.style.display = 'none';
    createNewPlaylistBtnElement.style.display = 'inline-block';

    const ul = document.createElement('ul');
    // ul.className = 'playlist-list-overview'; // Ensure this class is defined in CSS

    const likedSongsData = { id: LIKED_SONGS_PLAYLIST_ID, name: "Liked Songs", songs: likedPlaylist };
    ul.appendChild(createPlaylistOverviewItem(likedSongsData));

    userPlaylists.forEach(playlist => {
        ul.appendChild(createPlaylistOverviewItem(playlist));
    });

    playlistDisplayAreaElement.appendChild(ul);
    playlistDisplayAreaElement.scrollTop = 0;
}

function createPlaylistOverviewItem(playlistData) {
    const li = document.createElement('li');
    li.className = 'playlist-overview-item';
    li.setAttribute('data-playlist-id', playlistData.id);

    const songsText = playlistData.songs.length === 1 ? "1 song" : `${playlistData.songs.length} songs`;
    let artworkSrc;

    if (playlistData.id === LIKED_SONGS_PLAYLIST_ID) {
        artworkSrc = 'img/liked_songs.png';
        // "Liked Songs" is not draggable
    } else {
        // This is a user-created playlist
        li.setAttribute('draggable', true); // <<< MAKE USER PLAYLISTS DRAGGABLE
        artworkSrc = playlistData.artwork ||
                     (playlistData.songs.length > 0 && playlistData.songs[0].artwork ? playlistData.songs[0].artwork : 'img/empty_art.png');
        
        // Add drag event listeners for user playlists
        li.addEventListener('dragstart', (event) => handlePlaylistDragStart(event, playlistData.id));
        li.addEventListener('dragover', handlePlaylistDragOver);
        li.addEventListener('drop', (event) => handlePlaylistDrop(event, playlistData.id)); // Pass targetPlaylistId
        li.addEventListener('dragend', handlePlaylistDragEnd);
    }

    let nameDisplay = `<div class="playlist-overview-item-name">${escapeHtml(playlistData.name)}</div>`;
    let actionsHtml = '';

    if (playlistData.id !== LIKED_SONGS_PLAYLIST_ID) {
        actionsHtml = `
            <div class="playlist-item-actions">
                <button class="rename-playlist-btn" title="Rename"><i class="icon icon-edit"></i></button>
                <button class="delete-playlist-btn" title="Delete"><i class="icon icon-trash"></i></button>
            </div>`;
    }

    li.innerHTML = `
        <img src="${artworkSrc}" alt="${escapeHtml(playlistData.name)}" class="playlist-overview-item-artwork">
        <div class="playlist-overview-item-info">
            ${nameDisplay}
            <div class="playlist-overview-item-count">${songsText}</div>
        </div>
        ${actionsHtml}
    `;

    // Keep existing click handlers for viewing playlist and actions, ensuring they don't interfere with drag
    const infoSection = li.querySelector('.playlist-overview-item-info');
    const artworkSection = li.querySelector('.playlist-overview-item-artwork');
    const viewPlaylistHandler = () => switchSidebarView('single_playlist_view', playlistData.id);

    // Modify click handlers to prevent triggering view change during a drag operation
    const combinedClickHandler = (e) => {
        // Check if the click originated from an action button or if a drag might be starting/active
        if (e.target.closest('.playlist-item-actions') || 
            e.target.closest('.playlist-name-input') ||
            (draggedPlaylistElement && draggedPlaylistElement.classList.contains('dragging'))) { // Check if currently dragging
            return;
        }
        viewPlaylistHandler();
    };
    
    if (infoSection) infoSection.addEventListener('click', combinedClickHandler);
    if (artworkSection) artworkSection.addEventListener('click', combinedClickHandler);


    if (playlistData.id !== LIKED_SONGS_PLAYLIST_ID) {
        const renameBtn = li.querySelector('.rename-playlist-btn');
        const deleteBtn = li.querySelector('.delete-playlist-btn');
        if(renameBtn) renameBtn.addEventListener('click', (e) => { e.stopPropagation(); handleRenamePlaylist(playlistData.id); });
        if(deleteBtn) deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); deletePlaylist(playlistData.id); });
    }
    return li;
}

function reorderUserPlaylists(draggedInitialIndex, targetVisualIndex) {
    // draggedInitialIndex: original index in userPlaylists
    // targetVisualIndex: the index where it should appear *after* the move, relative to the original array.
    // E.g., to move to the very start, targetVisualIndex = 0.
    // To move to be the item at index K (pushing K and subsequent down), targetVisualIndex = K.

    if (draggedInitialIndex < 0 || draggedInitialIndex >= userPlaylists.length ||
        targetVisualIndex < 0 || targetVisualIndex > userPlaylists.length) { // targetVisualIndex can be userPlaylists.length for appending
        console.warn("Invalid indices for playlist reorder", draggedInitialIndex, targetVisualIndex);
        return;
    }
    
    // If trying to drop in the same spot (no actual move needed)
    // Note: if targetVisualIndex is intended to be "insert before this index"
    // then if draggedInitialIndex === targetVisualIndex, no move.
    // if targetVisualIndex is "insert after this index (targetVisualIndex-1)", then no move if draggedInitialIndex === targetVisualIndex-1
    // Let's assume targetVisualIndex is "insert AT this index".
    if (draggedInitialIndex === targetVisualIndex || draggedInitialIndex === targetVisualIndex -1 && targetVisualIndex > draggedInitialIndex) { // No actual move
        // renderAllPlaylistsView(); // Still re-render to clear any drag artifacts
        return;
    }


    const itemToMove = userPlaylists.splice(draggedInitialIndex, 1)[0];

    // Adjust targetVisualIndex if the removal of itemToMove affected it
    let effectiveTargetIndex = targetVisualIndex;
    if (draggedInitialIndex < targetVisualIndex) {
        effectiveTargetIndex--; // The target position shifted left because an item before it was removed
    }
    
    // Clamp effectiveTargetIndex to be within the bounds of the (now shorter) array for insertion
    effectiveTargetIndex = Math.max(0, Math.min(effectiveTargetIndex, userPlaylists.length));

    userPlaylists.splice(effectiveTargetIndex, 0, itemToMove);

    saveUserPlaylists();
    renderAllPlaylistsView(); // Re-render the overview to reflect the new order and clear drag artifacts
}

function renderSinglePlaylistView(playlistId) {
    if (!playlistDisplayAreaElement || !sidebarTitleElement || !backToPlaylistsBtnElement || !createNewPlaylistBtnElement) return;

    const playlist = getPlaylistById(playlistId);
    if (!playlist) {
        switchSidebarView('all_playlists');
        return;
    }

    playlistDisplayAreaElement.innerHTML = '';
    sidebarTitleElement.textContent = escapeHtml(playlist.name);
    backToPlaylistsBtnElement.style.display = 'inline-block';
    createNewPlaylistBtnElement.style.display = 'none';

    if (playlist.songs.length === 0) {
        playlistDisplayAreaElement.innerHTML = `<p class="empty-playlist-message">This playlist is empty.</p>`;
        return;
    }

    const ul = document.createElement('ul');
    // ul.className = 'playlist-list'; // Ensure this class is in CSS

    playlist.songs.forEach((song, index) => {
        const li = document.createElement('li');
        li.className = 'playlist-item'; // Re-use for songs in a playlist
        li.setAttribute('data-song-id', song.id.toString());
        li.setAttribute('draggable', true);

        if (currentPlayingPlaylistId === playlistId && currentPlaylistTrackIndex === index && currentTrack && currentTrack.id === song.id) {
            li.classList.add('playing');
        }

        let removeButtonHtml = '';
        if (playlistId !== LIKED_SONGS_PLAYLIST_ID) {
            removeButtonHtml = `<button class="remove-song-from-playlist-btn icon-action-btn" title="Remove from playlist"><i class="icon icon-trash"></i></button>`;
        }


        li.innerHTML = `
            <img src="${song.artwork || 'img/empty_art.png'}" alt="${escapeHtml(song.title)}" class="playlist-item-artwork">
            <div class="playlist-item-info">
                <div class="playlist-item-title">${escapeHtml(song.title)}</div>
                <div class="playlist-item-artist">${escapeHtml(song.artist)}</div>
            </div>
            ${removeButtonHtml}
        `;

        li.addEventListener('click', (e) => {
            if (e.target.classList.contains('remove-song-from-playlist-btn')) {
                if (playlistId === LIKED_SONGS_PLAYLIST_ID) { // Should not happen due to button conditional
                    // removeSongFromLikedPlaylist(song.id); // This path should ideally not be taken
                } else {
                    removeSongFromUserPlaylist(playlistId, song.id);
                }
            } else {
                playSongFromCurrentPlaylist(playlistId, index);
            }
        });

        li.addEventListener('dragstart', (event) => handleSongDragStart(event, index, playlistId));
        li.addEventListener('dragover', handleSongDragOver);
        li.addEventListener('drop', (event) => handleSongDrop(event, index, playlistId)); // index here is the one dropped ON
        li.addEventListener('dragend', handleSongDragEnd);

        ul.appendChild(li);
    });
    playlistDisplayAreaElement.appendChild(ul);
    playlistDisplayAreaElement.scrollTop = 0;
}

// --- PLAYBACK LOGIC ADAPTATIONS ---
function playSongFromCurrentPlaylist(playlistId, songIndexInOriginalPlaylist) {
    const playlist = getPlaylistById(playlistId);
    if (!playlist || !playlist.songs || songIndexInOriginalPlaylist < 0 || songIndexInOriginalPlaylist >= playlist.songs.length) {
        console.warn(`Cannot play song: invalid playlist or index. Playlist ID: ${playlistId}, Index: ${songIndexInOriginalPlaylist}`);
        clearPlaylistContext();
        return;
    }

    const songToPlay = playlist.songs[songIndexInOriginalPlaylist];

    if (isShuffleActive && currentPlayingPlaylistId === playlistId) {
        // User manually selected a song from the playlist view while shuffle is on.
        // This song "jumps the queue" and becomes the current one.
        // It should be removed from upcoming and added to played.

        const upcomingIndex = shuffleUpcomingQueue.findIndex(s => s.id === songToPlay.id);
        if (upcomingIndex > -1) {
            shuffleUpcomingQueue.splice(upcomingIndex, 1);
        }

        const playedIndex = shufflePlayedQueue.findIndex(s => s.id === songToPlay.id);
        if (playedIndex > -1) {
            // If it was already played, remove it to avoid duplicate in playedQueue later
            // (though push will add it as most recent)
            shufflePlayedQueue.splice(playedIndex, 1);
        }
        shufflePlayedQueue.push(songToPlay); // Add to end of played queue (most recent)
        console.log(`Shuffle: User selected "${songToPlay.title}". Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
    } else if (isShuffleActive && currentPlayingPlaylistId !== playlistId) {
        // User started a new playlist while shuffle was on from a previous one.
        // Or, shuffle was just turned on by toggleShuffle before this call (less likely path here)
        initializeShuffleQueues(playlist.songs, songToPlay.id);
    }
    // If shuffle is NOT active OR shuffle was just initialized for THIS song:
    // The currentTrack, currentPlayingPlaylistId, currentPlaylistTrackIndex will be set below.

    currentPlayingPlaylistId = playlistId;
    currentPlaylistTrackIndex = songIndexInOriginalPlaylist; // Always store original index

    if (typeof playSong === 'function') {
        playSong(songToPlay.title, songToPlay.artist, songToPlay.artwork, songToPlay.id.toString());
    } else {
        console.error("Global playSong function not found!");
    }

    renderSidebar();
    updatePlaylistControlsVisibility(); // This now also updates shuffle button visibility
}

function playNextTrackInCurrentPlaylist() {
    if (!currentPlayingPlaylistId) return;

    const playlist = getPlaylistById(currentPlayingPlaylistId);
    if (!playlist || !playlist.songs || playlist.songs.length === 0) {
        clearPlaylistContext();
        return;
    }

    if (isShuffleActive) {
        if (shuffleUpcomingQueue.length === 0) {
            if (loopState === 'playlist') {
                console.log("Shuffle: Upcoming empty, looping playlist.");
                initializeShuffleQueues(playlist.songs);
                 // After re-initializing, check if there are still songs to play
                if (shuffleUpcomingQueue.length > 0) {
                    const nextSongToPlay = shuffleUpcomingQueue.shift();
                    shufflePlayedQueue.push(nextSongToPlay);
                    const originalIndexOfNextSong = playlist.songs.findIndex(s => s.id === nextSongToPlay.id);
                    currentPlaylistTrackIndex = originalIndexOfNextSong;
                    currentPlayingPlaylistId = playlist.id;
                    console.log(`Shuffle: Playing next "${nextSongToPlay.title}" after loop. Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
                    if (typeof playSong === 'function') {
                        playSong(nextSongToPlay.title, nextSongToPlay.artist, nextSongToPlay.artwork, nextSongToPlay.id.toString());
                    }
                    renderSidebar();
                    updatePlaylistControlsVisibility();
                    return; // Important: exit after handling the looped shuffle
                } else {
                    // Playlist became empty even after trying to loop shuffle (e.g. 0 songs playlist)
                    clearPlaylistContext();
                    return;
                }
            } else {
                console.log("Shuffle: Upcoming empty, no loop. Showing toast.");
                if (typeof showToast === 'function') { // <<<< ADDED TOAST
                    showToast("Last track in shuffle. Enable loop to replay.", 3500);
                }
                return; // Stop here, don't proceed to play
            }
        }

        // This block is for when shuffleUpcomingQueue.length > 0 (normal shuffle next)
        const nextSongToPlay = shuffleUpcomingQueue.shift();
        shufflePlayedQueue.push(nextSongToPlay);
        const originalIndexOfNextSong = playlist.songs.findIndex(s => s.id === nextSongToPlay.id);
        currentPlaylistTrackIndex = originalIndexOfNextSong;
        currentPlayingPlaylistId = playlist.id;
        console.log(`Shuffle: Playing next "${nextSongToPlay.title}". Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
        if (typeof playSong === 'function') {
            playSong(nextSongToPlay.title, nextSongToPlay.artist, nextSongToPlay.artwork, nextSongToPlay.id.toString());
        }
        renderSidebar();
        updatePlaylistControlsVisibility();

    } else { // Original non-shuffle logic
        let nextIndex = currentPlaylistTrackIndex + 1;
        if (nextIndex >= playlist.songs.length) {
            if (loopState === 'playlist') {
                nextIndex = 0;
            } else {
                console.log("Playlist: Last track, no loop. Showing toast.");
                if (typeof showToast === 'function') { // <<<< ADDED TOAST
                    showToast("End of playlist! Enable loop to continue.", 3500);
                }
                return; // Stop here, don't proceed to play
            }
        }
        playSongFromCurrentPlaylist(currentPlayingPlaylistId, nextIndex);
    }
}

function playPreviousTrackInCurrentPlaylist() {
    if (!currentPlayingPlaylistId) return;

    const playlist = getPlaylistById(currentPlayingPlaylistId);
     if (!playlist || !playlist.songs || playlist.songs.length === 0) {
        clearPlaylistContext();
        return;
    }

    if (isShuffleActive) {
        if (shufflePlayedQueue.length < 2) { // Need at least 2 songs in played: one current, one previous
            console.log("Shuffle: Not enough played history to go previous.");
            return; // Or play the first song of the shuffle cycle if desired
        }

        const currentSongFromPlayed = shufflePlayedQueue.pop(); // Remove current from played
        shuffleUpcomingQueue.unshift(currentSongFromPlayed); // Add it back to start of upcoming

        const previousSongToPlay = shufflePlayedQueue[shufflePlayedQueue.length - 1]; // Peek at new last (actual prev)
        
        const originalIndexOfPrevSong = playlist.songs.findIndex(s => s.id === previousSongToPlay.id);

        currentPlaylistTrackIndex = originalIndexOfPrevSong;
        currentPlayingPlaylistId = playlist.id;

        console.log(`Shuffle: Playing previous "${previousSongToPlay.title}". Upcoming: ${shuffleUpcomingQueue.length}, Played: ${shufflePlayedQueue.length}`);
        if (typeof playSong === 'function') {
            playSong(previousSongToPlay.title, previousSongToPlay.artist, previousSongToPlay.artwork, previousSongToPlay.id.toString());
        }
        renderSidebar();
        updatePlaylistControlsVisibility();

    } else { // Original non-shuffle logic
        let prevIndex = currentPlaylistTrackIndex - 1;
        if (prevIndex < 0) {
            // If loop playlist is active, wrap to last song, otherwise stop at first.
            if (loopState === 'playlist') {
                 prevIndex = playlist.songs.length - 1;
            } else {
                return; // Don't wrap if not looping playlist
            }
        }
        playSongFromCurrentPlaylist(currentPlayingPlaylistId, prevIndex);
    }
}
function updatePlaylistControlsVisibility() {
    if (!prevBtnElement || !nextBtnElement || !shuffleBtn) return; // Add shuffleBtn check
    const playlist = getPlaylistById(currentPlayingPlaylistId);
    const showControls = playlist && playlist.songs && playlist.songs.length > 0;

    prevBtnElement.style.display = showControls ? 'inline-block' : 'none';
    nextBtnElement.style.display = showControls ? 'inline-block' : 'none';
    shuffleBtn.style.display = showControls ? 'inline-block' : 'none'; // <<< ADD THIS

    if (typeof updateLoopButtonIcon === 'function') updateLoopButtonIcon();
    if (typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon(); // <<< ADD THIS
}

function clearPlaylistContext() {
    const wasPlayingPlaylist = currentPlayingPlaylistId !== null;
    currentPlayingPlaylistId = null;
    currentPlaylistTrackIndex = -1;

    isShuffleActive = false; // <<< ADD THIS
    shuffleUpcomingQueue = []; // <<< ADD THIS
    shufflePlayedQueue = [];   // <<< ADD THIS
    if(typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon(); // <<< ADD THIS

    if (currentSidebarView === 'single_playlist_view' && selectedPlaylistToViewId) {
         const playlistBeingViewed = getPlaylistById(selectedPlaylistToViewId);
         if(playlistBeingViewed) renderSinglePlaylistView(selectedPlaylistToViewId);
    }

    updatePlaylistControlsVisibility();

    if (wasPlayingPlaylist && typeof loopState !== 'undefined' && loopState === 'playlist') {
        loopState = 'none'; // If playlist context cleared, playlist loop should also conceptually reset
        if (typeof updateLoopButtonIcon === 'function') updateLoopButtonIcon();
    }
}

// --- "ADD TO PLAYLIST" MODAL ---
function openAddToPlaylistModal(songDataOverride = null) {
    const songToAdd = songDataOverride || currentTrack; // Use override if provided, else global currentTrack

    if (!songToAdd || songToAdd.id == null) { // Check songToAdd.id
        showGeneralModal("Cannot Add Song", "No song selected or currently playing to add to a playlist.");
        return;
    }
    // Ensure songToAdd has all necessary properties (id, title, artist, artwork)
    if (!songToAdd.title || !songToAdd.artist || !songToAdd.artwork) {
        console.error("Song data for modal is incomplete:", songToAdd);
        showGeneralModal("Error", "Cannot add song due to incomplete data.");
        return;
    }


    modalPlaylistListElement.innerHTML = '';

    // Option to add to Liked Songs
    const likedItem = document.createElement('div');
    likedItem.className = 'modal-playlist-item';
    likedItem.textContent = "Liked Songs";
    likedItem.onclick = () => {
        // Use the data from songToAdd
        addSongToLikedPlaylist({
            id: songToAdd.id.toString(),
            title: songToAdd.title,
            artist: songToAdd.artist,
            artwork: songToAdd.artwork
        });
        closeAddToPlaylistModal();
    };
    modalPlaylistListElement.appendChild(likedItem);

    userPlaylists.forEach(playlist => {
        const playlistItem = document.createElement('div');
        playlistItem.className = 'modal-playlist-item';
        playlistItem.textContent = escapeHtml(playlist.name);
        playlistItem.onclick = () => {
            // Use the data from songToAdd
            addSongToUserPlaylist(playlist.id, {
                id: songToAdd.id.toString(),
                title: songToAdd.title,
                artist: songToAdd.artist,
                artwork: songToAdd.artwork
            });
            closeAddToPlaylistModal();
        };
        modalPlaylistListElement.appendChild(playlistItem);
    });

    if (modalPlaylistListElement.children.length === 1 && userPlaylists.length === 0) {
         const noUserPlaylistsMsg = document.createElement('p');
         noUserPlaylistsMsg.textContent = 'No other playlists. Create one first!';
         noUserPlaylistsMsg.style.textAlign = 'center';
         noUserPlaylistsMsg.style.marginTop = '10px';
         modalPlaylistListElement.appendChild(noUserPlaylistsMsg);
    }

    addToPlaylistModalElement.style.display = 'flex';
}

function closeAddToPlaylistModal() {
    addToPlaylistModalElement.style.display = 'none';
}

// --- PLAYLIST MANAGEMENT UI HANDLERS ---
function handleCreateNewPlaylist() {
    if (typeof openCreatePlaylistModal === 'function') { // openCreatePlaylistModal is from modals.js
        openCreatePlaylistModal();
    } else {
        console.error("openCreatePlaylistModal function not found!");
        // Fallback to prompt if modal function isn't available
        const playlistNameFallback = prompt("Enter name for new playlist (modal error):", "My Playlist");
        if (playlistNameFallback && playlistNameFallback.trim() !== "") {
            createPlaylist(playlistNameFallback.trim());
            renderAllPlaylistsView();
        } else if (playlistNameFallback !== null) {
            alert("Playlist name cannot be empty.");
        }
    }
}

function handleRenamePlaylist(playlistIdToEdit /*, listItemElement - no longer needed */) {
    const playlist = getPlaylistById(playlistIdToEdit); // getPlaylistById is in this file
    if (!playlist || playlist.id === LIKED_SONGS_PLAYLIST_ID) { // Can't rename Liked Songs
        console.warn("Attempted to rename Liked Songs or non-existent playlist.");
        return;
    }

    // NEW: Call the function to open the dedicated modal
    // openRenamePlaylistModal is from modals.js
    if (typeof openRenamePlaylistModal === 'function') {
        openRenamePlaylistModal(playlist.id, playlist.name);
    } else {
        console.error("openRenamePlaylistModal function not found!");
        // Fallback to prompt if modal function isn't available (optional)
        const newNameFallback = prompt(`Enter new name for "${escapeHtml(playlist.name)}":`, playlist.name);
        if (newNameFallback && newNameFallback.trim() !== "" && newNameFallback.trim() !== playlist.name) {
            renamePlaylist(playlist.id, newNameFallback.trim());
            // renamePlaylist itself will call renderAllPlaylistsView or update title
        } else if (newNameFallback && newNameFallback.trim() === "") {
            // Using global showGeneralModal for error
            if(typeof showGeneralModal === 'function') showGeneralModal("Invalid Name", "Playlist name cannot be empty.");
            else alert("Playlist name cannot be empty.");
        }
    }
}

// --- DRAG AND DROP FOR SONGS (within a single playlist view) ---
let draggedSongIndex = null;
let draggedSongElement = null;
let dragOverPlaylistIdContext = null; // Stores playlist ID during drag operation

// New state variables for playlist dragging
let draggedPlaylistIndex = null;     // Index in the userPlaylists array
let draggedPlaylistElement = null;

function handleSongDragStart(event, index, playlistId) {
    draggedSongIndex = index;
    draggedSongElement = event.target;
    dragOverPlaylistIdContext = playlistId; // Set context for this drag operation
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', index.toString()); // Standard practice
    setTimeout(() => {
        if (draggedSongElement) draggedSongElement.classList.add('dragging');
    }, 0);
}

function handleSongDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    const currentTargetLi = event.target.closest('.playlist-item');

    if (!currentTargetLi || !draggedSongElement || currentTargetLi === draggedSongElement ||
        !playlistDisplayAreaElement.contains(currentTargetLi)) { // Ensure target is within the display area
        return;
    }
    clearGapIndicators(); // Clear previous gaps
    const rect = currentTargetLi.getBoundingClientRect();
    const offsetY = event.clientY - rect.top;
    currentTargetLi.classList.add(offsetY < rect.height / 2 ? 'show-gap-above' : 'show-gap-below');
}

function handleSongDrop(event, indexOfTheItemDroppedOn, playlistIdForDropTarget) {
    event.preventDefault();
    clearGapIndicators();

    if (draggedSongIndex === null || dragOverPlaylistIdContext !== playlistIdForDropTarget ||
        dragOverPlaylistIdContext !== selectedPlaylistToViewId) {
        // Dragged from different playlist context or something went wrong
        if (draggedSongElement) draggedSongElement.classList.remove('dragging');
        draggedSongIndex = null;
        draggedSongElement = null;
        dragOverPlaylistIdContext = null;
        return;
    }

    // At this point, playlistIdForDropTarget is the same as dragOverPlaylistIdContext
    const currentReorderingPlaylistId = dragOverPlaylistIdContext;

    reorderSongInPlaylist(currentReorderingPlaylistId, draggedSongIndex, indexOfTheItemDroppedOn);
    // reorderSongInPlaylist now handles saving and re-rendering the single playlist view.
    // The re-render will also clean up dragging classes.

    // Reset state variables in handleSongDragEnd
}

function handleSongDragEnd(event) {
    clearGapIndicators();
    if (draggedSongElement) {
        draggedSongElement.classList.remove('dragging');
    }
    // Failsafe: remove dragging from all items if something went wrong
    const allItems = playlistDisplayAreaElement.querySelectorAll('.playlist-item.dragging');
    allItems.forEach(item => item.classList.remove('dragging'));

    draggedSongIndex = null;
    draggedSongElement = null;
    dragOverPlaylistIdContext = null;
}

function clearGapIndicators() {
    const items = playlistDisplayAreaElement.querySelectorAll('.playlist-item');
    items.forEach(item => {
        item.classList.remove('show-gap-above', 'show-gap-below');
    });
}

// --- DRAG AND DROP FOR PLAYLIST OVERVIEW ITEMS ---

function handlePlaylistDragStart(event, playlistId) {
    draggedPlaylistIndex = userPlaylists.findIndex(p => p.id === playlistId);
    // Explicitly prevent dragging "Liked Songs" even if draggable was somehow set
    if (draggedPlaylistIndex === -1 || playlistId === LIKED_SONGS_PLAYLIST_ID) {
        event.preventDefault();
        return;
    }

    draggedPlaylistElement = event.target.closest('.playlist-overview-item');
    if (!draggedPlaylistElement) { // Should not happen if event is on the li
        event.preventDefault();
        return;
    }
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', playlistId); // Store playlistId

    setTimeout(() => { // Timeout to allow browser to render drag image before class change
        if (draggedPlaylistElement) draggedPlaylistElement.classList.add('dragging');
    }, 0);
}

function handlePlaylistDragOver(event) {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';

    const targetLiElement = event.target.closest('.playlist-overview-item');

    // Do not allow dropping on "Liked Songs" or on the item being dragged
    if (!targetLiElement || targetLiElement === draggedPlaylistElement || 
        targetLiElement.getAttribute('data-playlist-id') === LIKED_SONGS_PLAYLIST_ID) {
        clearPlaylistGapIndicators(); // Clear any gaps if hovering over an invalid target
        return;
    }

    clearPlaylistGapIndicators(); // Clear previous gaps

    const rect = targetLiElement.getBoundingClientRect();
    const offsetY = event.clientY - rect.top;
    const middleY = rect.height / 2;

    if (offsetY < middleY) {
        targetLiElement.classList.add('show-gap-above');
    } else {
        targetLiElement.classList.add('show-gap-below');
    }
}

function handlePlaylistDrop(event, targetPlaylistIdOnDrop) {
    event.preventDefault();
    clearPlaylistGapIndicators();

    if (!draggedPlaylistElement || draggedPlaylistIndex === -1 || targetPlaylistIdOnDrop === LIKED_SONGS_PLAYLIST_ID) {
        // Invalid drag operation or dropping on "Liked Songs"
        if (draggedPlaylistElement) draggedPlaylistElement.classList.remove('dragging');
        draggedPlaylistIndex = -1;
        draggedPlaylistElement = null;
        return;
    }

    const targetLiElement = event.target.closest('.playlist-overview-item');
    if (!targetLiElement) { // Should not happen if drop event is on a valid target
        if (draggedPlaylistElement) draggedPlaylistElement.classList.remove('dragging');
        draggedPlaylistIndex = -1;
        draggedPlaylistElement = null;
        return;
    }

    const targetPlaylistIndexInUserPlaylists = userPlaylists.findIndex(p => p.id === targetPlaylistIdOnDrop);
    if (targetPlaylistIndexInUserPlaylists === -1) { // Target playlist not found (error)
        if (draggedPlaylistElement) draggedPlaylistElement.classList.remove('dragging');
        draggedPlaylistIndex = -1;
        draggedPlaylistElement = null;
        return;
    }

    // Determine target insert position based on drop location relative to the target item's middle
    let visualTargetIndex = targetPlaylistIndexInUserPlaylists; // This is the index of the item we are dropping ONTO

    const rect = targetLiElement.getBoundingClientRect();
    const offsetY = event.clientY - rect.top;
    const middleY = rect.height / 2;

    if (offsetY > middleY) { // Dropped on the lower half, so insert AFTER this item
        visualTargetIndex++;
    }
    // If dropped on upper half, visualTargetIndex remains the index of the target item (insert BEFORE it)

    reorderUserPlaylists(draggedPlaylistIndex, visualTargetIndex);
    // Drag end will clean up remaining state and classes.
    // reorderUserPlaylists will call renderAllPlaylistsView which also helps clean up.
}

function handlePlaylistDragEnd(event) {
    clearPlaylistGapIndicators();
    if (draggedPlaylistElement) {
        draggedPlaylistElement.classList.remove('dragging');
    }
    // Failsafe removal
    const allDraggingItems = playlistDisplayAreaElement.querySelectorAll('.playlist-overview-item.dragging');
    allDraggingItems.forEach(item => item.classList.remove('dragging'));

    draggedPlaylistIndex = -1;
    draggedPlaylistElement = null;
}

function clearPlaylistGapIndicators() {
    const items = playlistDisplayAreaElement.querySelectorAll('.playlist-overview-item');
    items.forEach(item => {
        item.classList.remove('show-gap-above', 'show-gap-below');
    });
}

// --- SHUFFLE HELPER ---
function shuffleArray(array) {
    let newArray = [...array]; // Create a copy
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

// --- SHUFFLE QUEUE MANAGEMENT ---
function initializeShuffleQueues(playlistSongs, currentlyPlayingSongId = null) {
    if (!isShuffleActive || !playlistSongs || playlistSongs.length === 0) {
        shuffleUpcomingQueue = [];
        shufflePlayedQueue = [];
        isShuffleActive = false; // Turn off if no songs
        if (typeof updateShuffleButtonIcon === 'function') updateShuffleButtonIcon();
        return;
    }

    // Create a queue of song *objects* or just *IDs*. IDs are simpler for queue management.
    // Let's use song objects for now to easily access details later.
    shuffleUpcomingQueue = shuffleArray(playlistSongs);
    shufflePlayedQueue = [];

    if (currentlyPlayingSongId) {
        const currentSongIndexInUpcoming = shuffleUpcomingQueue.findIndex(s => s.id === currentlyPlayingSongId);
        if (currentSongIndexInUpcoming > -1) {
            const currentSongObject = shuffleUpcomingQueue.splice(currentSongIndexInUpcoming, 1)[0];
            shufflePlayedQueue.push(currentSongObject); // Current song is first in played queue
        } else {
            // If current song wasn't in the list for some reason, just proceed.
        }
    }
    console.log("Shuffle queues initialized. Upcoming:", shuffleUpcomingQueue.map(s=>s.title), "Played:", shufflePlayedQueue.map(s=>s.title));
}





// Helper to prevent XSS
function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') {
        // console.warn("escapeHtml called with non-string:", unsafe);
        return unsafe === null || typeof unsafe === 'undefined' ? '' : String(unsafe);
    }
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'")
}
```

js/search.js
```js
// --- Event Listeners for searchInput ---

searchInput.addEventListener("focus", function () {
  if (searchInput.value.trim() === "") {
      displayRecentSearches();
  }
  // If there's text, the 'input' event will handle regular search suggestions or actual search
});

searchInput.addEventListener("input", function () {
  clearTimeout(searchTimeout); // searchTimeout should be defined (e.g., in init.js or top of this file)
  const query = searchInput.value.trim();

  if (query.length > 1) {
      searchTimeout = setTimeout(() => {
          searchSongs(query);
      }, 300);
  } else if (query.length === 0) {
      displayRecentSearches(); // Show recent searches if input is cleared
  } else {
      // Query is 1 char, or just spaces - hide main song search results
      hideSearchResults(); 
      // Optionally, you could still show recent searches here if desired,
      // but typical behavior is to hide until input is empty or long enough for song search.
  }
});

searchInput.addEventListener("keypress", function (e) {
  if (e.key === "Enter") {
      clearTimeout(searchTimeout);
      const query = searchInput.value.trim();
      if (query.length > 1) {
          searchSongs(query); // searchSongs will handle adding to recent history on success
      } else if (query.length === 0) {
          hideSearchResults(); // Don't search an empty string on enter
      }
  }
});

// --- Main Search Function ---
function searchSongs(query) {
  if (!searchResults) { // Guard
      console.error("Search results element not found");
      return;
  }
  searchResults.innerHTML = '<div class="loading">Searching...</div>';
  showSearchResults();

  // SEARCH_EP should be globally available from endpoints.js
  const url = `${SEARCH_EP}${encodeURIComponent(query)}&media=music&entity=song&limit=10`;

  fetch(url)
      .then((response) => response.json())
      .then((data) => {
          console.log("iTunes search results:", data);
          // displaySearchResults is for song results. displayRecentSearches is for history.
          if (data.results && data.results.length > 0) {
              // Uses addRecentSearch() from history.js
              addRecentSearch(query); 
              displaySongSearchResults(data.results); // Renamed for clarity
          } else {
              // Don't add to history if no song results found for this query
              displaySongSearchResults(data.results); // Will show "No results found"
          }
      })
      .catch((error) => {
          console.error("Error searching iTunes:", error);
          searchResults.innerHTML =
              '<div class="loading">Search failed. Please try again.</div>';
      });
}

// Renamed your original displaySearchResults to avoid conflict with the new one for history
// This function displays actual song search results from iTunes.
function displaySongSearchResults(results) {
  if (!searchResults) return; 

  if (!results || results.length === 0) {
      searchResults.innerHTML = '<div class="loading">No results found</div>';
      // showSearchResults(); // Already called by searchSongs which calls this
      return;
  }

  searchResults.innerHTML = ""; // Clear loading message or recent searches

  results.forEach((item) => {
      if (!item.trackName || !item.artistName || !item.trackId || !item.artworkUrl100) {
          console.warn("Skipping search result due to missing data:", item);
          return;
      }

      const resultElement = document.createElement("div");
      resultElement.className = "result-item"; // For actual song results

      resultElement.dataset.trackId = item.trackId.toString();
      resultElement.dataset.trackName = item.trackName;
      resultElement.dataset.artistName = item.artistName;
      resultElement.dataset.artworkUrl100 = item.artworkUrl100;

      resultElement.innerHTML = `
          <div class="result-img">
              <img src="${item.artworkUrl100}" alt="${escapeHtml(item.trackName)}" crossorigin="anonymous">
          </div>
          <div class="result-info">
              <div class="result-title">${escapeHtml(item.trackName)}</div>
              <div class="result-artist">${escapeHtml(item.artistName)}</div>
          </div>
          <button class="add-to-playlist-search-btn icon-action-btn" title="Add to playlist">
              <i class="icon icon-plus-circle"></i>
          </button>
      `;
      
      // Click listener for the main result item (plays the song)
      resultElement.addEventListener("click", (event) => {
          // Only play if the click was not on the "add to playlist" button
          if (event.target.closest('.add-to-playlist-search-btn')) {
              // The button's own click listener (below) will handle its action and stop propagation.
              return; 
          }

          // Clicked on song info/artwork area to play
          if (typeof clearPlaylistContext === 'function') clearPlaylistContext();
          playSong(item.trackName, item.artistName, item.artworkUrl100, item.trackId.toString());
          hideSearchResults();
          if (searchInput) searchInput.value = "";

          // IMPORTANT: Stop this click from bubbling up to the document listener
          event.stopPropagation();
      });

      const addToPlaylistBtnForResult = resultElement.querySelector('.add-to-playlist-search-btn');
      if (addToPlaylistBtnForResult) {
          addToPlaylistBtnForResult.addEventListener('click', (event) => {
              event.stopPropagation(); // Crucial: Prevent parent (resultElement) click and document click
              const songDataForModal = {
                  id: item.trackId.toString(),
                  title: item.trackName,
                  artist: item.artistName,
                  artwork: item.artworkUrl100
              };
              if (typeof openAddToPlaylistModal === 'function') {
                  openAddToPlaylistModal(songDataForModal);
              } else {
                  console.error("openAddToPlaylistModal function not found");
              }
          });
      }
      searchResults.appendChild(resultElement);
  });
  // showSearchResults(); // Already called by searchSongs which calls this
}

// --- Utility functions (showSearchResults, hideSearchResults) ---
// These should be your existing functions:
function showSearchResults() {
  if (searchResults) searchResults.classList.add("active");
}

function hideSearchResults() {
  if (searchResults) searchResults.classList.remove("active");
}

// --- Display Logic for Recent Searches ---
function displayRecentSearches() {
  // Uses getRecentSearches() from history.js or this file
  const recentSearches = getRecentSearches(); 

  if (!searchResults) return; 

  if (recentSearches.length === 0) {
      searchResults.innerHTML = '<div class="loading" style="padding: 10px 0;">No recent searches.</div>';
      showSearchResults(); 
      return;
  }

  searchResults.innerHTML = ''; 
  const title = document.createElement('div');
  title.className = 'recent-searches-title';
  title.textContent = 'Recent Searches';
  searchResults.appendChild(title);

  recentSearches.forEach(query => {
      const recentItem = document.createElement('div');
      recentItem.className = 'recent-search-item result-item'; 

      recentItem.innerHTML = `
          <span class="recent-search-query">${escapeHtml(query)}</span>
          <button class="remove-recent-search-btn icon-action-btn" title="Remove from history">
              <i class="icon icon-close"></i>
          </button>
      `;

      // Event listener for the entire recentItem (covers clicking the query text area)
      recentItem.addEventListener('click', (event) => {
          // If the click was specifically on the remove button,
          // let its own handler (which also stops propagation) do the work.
          if (event.target.closest('.remove-recent-search-btn')) {
              return;
          }
          
          // This click is on the recent search item (likely the query text area) to initiate a search
          searchInput.value = query; 
          searchSongs(query); // This will refresh the searchResults content
          
          // IMPORTANT: Stop this click from bubbling up to the document listener
          event.stopPropagation(); 
      });

      const removeBtn = recentItem.querySelector('.remove-recent-search-btn');
      if (removeBtn) {
          removeBtn.addEventListener('click', (event) => {
              event.stopPropagation(); // Crucial: Prevent parent (recentItem) click and document click
              removeRecentSearch(query); 
              displayRecentSearches();   // Re-render the recent searches list immediately
          });
      }
      searchResults.appendChild(recentItem);
  });
  showSearchResults(); 
}
```

js/toast.js
```js
// js/toast.js

const toastContainer = document.getElementById('toastContainer');
const MAX_TOASTS = 1; // Define the maximum number of toasts allowed

// Store references to active toasts and their removal timeouts
let activeToasts = []; // Array of { element: toastElement, timeoutId: id }

/**
 * Displays a toast message, managing the maximum number of toasts.
 * @param {string} message The message to display.
 * @param {number} duration How long the toast should be visible in milliseconds (default: 3000).
 */
function showToast(message, duration = 3000) {
    if (!toastContainer) {
        console.error("Toast container not found!");
        alert(message); // Fallback
        return;
    }

    // If max toasts (or more) are considered active, remove the oldest one.
    // "Oldest" here refers to the one added first to our activeToasts array.
    if (activeToasts.length >= MAX_TOASTS) {
        const oldestToastEntry = activeToasts.shift(); // Remove from beginning of our tracking array
        if (oldestToastEntry) {
            clearTimeout(oldestToastEntry.timeoutId); // Stop its scheduled removal
            // Force remove its 'show' class and then remove from DOM without waiting for transition
            // This is to make space immediately.
            if (oldestToastEntry.element.parentNode) {
                oldestToastEntry.element.classList.remove('show'); // Start fade if desired, but removal is next
                oldestToastEntry.element.remove(); // Immediate DOM removal
            }
        }
    }

    const toastElement = document.createElement('div');
    toastElement.className = 'toast-message';
    toastElement.textContent = message;

    toastContainer.appendChild(toastElement);

    // Trigger the animation for showing
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            toastElement.classList.add('show');
        });
    });

    const removalTimeoutId = setTimeout(() => {
        // Start fade out animation
        toastElement.classList.remove('show');

        // Remove from DOM after transition
        const transitionEndHandler = () => {
            if (toastElement.parentNode) {
                toastElement.parentNode.removeChild(toastElement);
            }
            // Clean up from our activeToasts array
            activeToasts = activeToasts.filter(t => t.element !== toastElement);
            toastElement.removeEventListener('transitionend', transitionEndHandler); // Clean up listener
        };
        toastElement.addEventListener('transitionend', transitionEndHandler);

        // Fallback: if transitionend doesn't fire (e.g. element removed by other means, or no transition)
        // remove it from activeToasts after a bit longer than the transition duration
        setTimeout(() => {
            activeToasts = activeToasts.filter(t => t.element !== toastElement);
            if (toastElement.parentNode) { // If still in DOM and transitionend didn't fire
                 toastElement.remove();
            }
        }, duration + 500); // duration of show + css transition time (e.g., 300ms) + buffer

    }, duration);

    // Add to our tracking array
    activeToasts.push({ element: toastElement, timeoutId: removalTimeoutId });
}
```

image paths:
img/liked_songs.png
img/empty_art.png
img/favicon.ico
img/icons/arrow-left.svg
img/icons/edit.svg
img/icons/heart-empty.svg
img/icons/heart-filled.svg
img/icons/lyrics.svg
img/icons/music.svg
img/icons/mute.svg
img/icons/next.svg
img/icons/pause.svg
img/icons/play.svg
img/icons/plus-circle.svg
img/icons/prev.svg
img/icons/repeat-1.svg
img/icons/repeat.svg
img/icons/trash.svg
img/icons/volume-loud.svg
img/icons/shuffle.svg
img/icons/close.svg